<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Modules Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://docs.julialang.org/en/v1/manual/modules/index.html" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="The Julia Language logo" class="docs-light-only" src="../../assets/logo.svg"/><img alt="The Julia Language logo" class="docs-dark-only" src="../../assets/logo-dark.svg"/></a><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input checked="" class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../strings/">Strings</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../control-flow/">Control Flow</a></li><li><a class="tocitem" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li class="is-active"><a class="tocitem" href="">Modules</a><ul class="internal"><li><a class="tocitem" href="#Summary-of-module-usage-1"><span>Summary of module usage</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">Documentation</a></li><li><a class="tocitem" href="../metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../arrays/">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="../missing/">Missing Values</a></li><li><a class="tocitem" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="tocitem" href="../environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../code-loading/">Code Loading</a></li><li><a class="tocitem" href="../profile/">Profiling</a></li><li><a class="tocitem" href="../stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../style-guide/">Style Guide</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../unicode-input/">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">Essentials</a></li><li><a class="tocitem" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../../base/math/">Mathematics</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">Strings</a></li><li><a class="tocitem" href="../../base/arrays/">Arrays</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">Constants</a></li><li><a class="tocitem" href="../../base/file/">Filesystem</a></li><li><a class="tocitem" href="../../base/io-network/">I/O and Network</a></li><li><a class="tocitem" href="../../base/punctuation/">Punctuation</a></li><li><a class="tocitem" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../../base/iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../../base/c/">C Interface</a></li><li><a class="tocitem" href="../../base/libc/">C Standard Library</a></li><li><a class="tocitem" href="../../base/stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">Logging</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">Profiling</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="tocitem" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">Inference</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="">Modules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Modules</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/manual/modules.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="modules-1"><a class="docs-heading-anchor" href="#modules-1">Modules</a><a class="docs-heading-anchor-permalink" href="#modules-1" title="Permalink"></a></h1><p>Modules in Julia are separate variable workspaces, i.e. they introduce a new global scope. They are delimited syntactically, inside <code>module Name ... end</code>. Modules allow you to create top-level definitions (aka global variables) without worrying about name conflicts when your code is used together with somebody else's. Within a module, you can control which names from other modules are visible (via importing), and specify which of your names are intended to be public (via exporting).</p><p>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</p><pre><code class="language-julia">module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end</code></pre><p>Note that the style is not to indent the body of the module, since that would typically lead to whole files being indented.</p><p>This module defines a type <code>MyType</code>, and two functions. Function <code>foo</code> and type <code>MyType</code> are exported, and so will be available for importing into other modules.  Function <code>bar</code> is private to <code>MyModule</code>.</p><p>The statement <code>using Lib</code> means that a module called <code>Lib</code> will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by <code>Lib</code> and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in <code>Lib</code>.</p><p>The statement <code>using BigLib: thing1, thing2</code> brings just the identifiers <code>thing1</code> and <code>thing2</code> into scope from module <code>BigLib</code>. If these names refer to functions, adding methods to them will not be allowed (you may only "use" them, not extend them).</p><p>The <a href="../../base/base/#import"><code>import</code></a> keyword supports the same syntax as <a href="../../base/base/#using"><code>using</code></a>. It does not add modules to be searched the way <code>using</code> does. <code>import</code> also differs from <code>using</code> in that functions imported using <code>import</code> can be extended with new methods.</p><p>In <code>MyModule</code> above we wanted to add a method to the standard <a href="../../base/io-network/#Base.show-Tuple{Any}"><code>show</code></a> function, so we had to write <code>import Base.show</code>. Functions whose names are only visible via <code>using</code> cannot be extended.</p><p>Once a variable is made visible via <code>using</code> or <code>import</code>, a module may not create its own variable with the same name. Imported variables are read-only; assigning to a global variable always affects a variable owned by the current module, or else raises an error.</p><h2 id="Summary-of-module-usage-1"><a class="docs-heading-anchor" href="#Summary-of-module-usage-1">Summary of module usage</a><a class="docs-heading-anchor-permalink" href="#Summary-of-module-usage-1" title="Permalink"></a></h2><p>To load a module, two main keywords can be used: <code>using</code> and <code>import</code>. To understand their differences, consider the following example:</p><pre><code class="language-julia">module MyModule

export x, y

x() = "x"
y() = "y"
p() = "p"

end</code></pre><p>In this module we export the <code>x</code> and <code>y</code> functions (with the keyword <code>export</code>), and also have the non-exported function <code>p</code>. There are several different ways to load the Module and its inner functions into the current workspace:</p><table><tbody><tr><th style="text-align: left">Import Command</th><th style="text-align: left">What is brought into scope</th><th style="text-align: left">Available for method extension</th></tr><tr><td style="text-align: left"><code>using MyModule</code></td><td style="text-align: left">All <code>export</code>ed names (<code>x</code> and <code>y</code>), <code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td style="text-align: left"><code>using MyModule: x, p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><code>import MyModule</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td><td style="text-align: left"><code>MyModule.x</code>, <code>MyModule.y</code> and <code>MyModule.p</code></td></tr><tr><td style="text-align: left"><code>import MyModule.x, MyModule.p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td></tr><tr><td style="text-align: left"><code>import MyModule: x, p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td><td style="text-align: left"><code>x</code> and <code>p</code></td></tr></tbody></table><h3 id="Modules-and-files-1"><a class="docs-heading-anchor" href="#Modules-and-files-1">Modules and files</a><a class="docs-heading-anchor-permalink" href="#Modules-and-files-1" title="Permalink"></a></h3><p>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:</p><pre><code class="language-julia">module Foo

include("file1.jl")
include("file2.jl")

end</code></pre><p>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with "safe" versions of some operators:</p><pre><code class="language-julia">module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end</code></pre><h3 id="Standard-modules-1"><a class="docs-heading-anchor" href="#Standard-modules-1">Standard modules</a><a class="docs-heading-anchor-permalink" href="#Standard-modules-1" title="Permalink"></a></h3><p>There are three important standard modules:</p><ul><li><a href="../../base/base/#Core"><code>Core</code></a> contains all functionality "built into" the language.</li><li><a href="../../base/base/#Base"><code>Base</code></a> contains basic functionality that is useful in almost all cases.</li><li><a href="../../base/base/#Main"><code>Main</code></a> is the top-level module and the current module, when Julia is started.</li></ul><h3 id="Default-top-level-definitions-and-bare-modules-1"><a class="docs-heading-anchor" href="#Default-top-level-definitions-and-bare-modules-1">Default top-level definitions and bare modules</a><a class="docs-heading-anchor-permalink" href="#Default-top-level-definitions-and-bare-modules-1" title="Permalink"></a></h3><p>In addition to <code>using Base</code>, modules also automatically contain definitions of the <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> and <a href="../../base/base/#Base.MainInclude.include"><code>include</code></a> functions, which evaluate expressions/files within the global scope of that module.</p><p>If these default definitions are not wanted, modules can be defined using the keyword <a href="../../base/base/#baremodule"><code>baremodule</code></a> instead (note: <code>Core</code> is still imported, as per above). In terms of <code>baremodule</code>, a standard <code>module</code> looks like this:</p><pre><code class="language-none">baremodule Mod

using Base

eval(x) = Core.eval(Mod, x)
include(p) = Base.include(Mod, p)

...

end</code></pre><h3 id="Relative-and-absolute-module-paths-1"><a class="docs-heading-anchor" href="#Relative-and-absolute-module-paths-1">Relative and absolute module paths</a><a class="docs-heading-anchor-permalink" href="#Relative-and-absolute-module-paths-1" title="Permalink"></a></h3><p>Given the statement <code>using Foo</code>, the system consults an internal table of top-level modules to look for one named <code>Foo</code>. If the module does not exist, the system attempts to <code>require(:Foo)</code>, which typically results in loading code from an installed package.</p><p>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example <code>using Base.Sort</code>. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</p><pre><code class="language-none">module Parent

module Utils
...
end

using .Utils

...
end</code></pre><p>Here module <code>Parent</code> contains a submodule <code>Utils</code>, and code in <code>Parent</code> wants the contents of <code>Utils</code> to be visible. This is done by starting the <code>using</code> path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example <code>using ..Utils</code> would look for <code>Utils</code> in <code>Parent</code>'s enclosing module rather than in <code>Parent</code> itself.</p><p>Note that relative-import qualifiers are only valid in <code>using</code> and <code>import</code> statements.</p><h3 id="Namespace-miscellanea-1"><a class="docs-heading-anchor" href="#Namespace-miscellanea-1">Namespace miscellanea</a><a class="docs-heading-anchor-permalink" href="#Namespace-miscellanea-1" title="Permalink"></a></h3><p>If a name is qualified (e.g. <code>Base.sin</code>), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, <code>Base.+</code> for example, you must use <code>Base.:+</code> to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: <code>Base.:(==)</code>.</p><p>Macro names are written with <code>@</code> in import and export statements, e.g. <code>import Mod.@mac</code>. Macros in other modules can be invoked as <code>Mod.@mac</code> or <code>@Mod.mac</code>.</p><p>The syntax <code>M.x = y</code> does not work to assign a global in another module; global assignment is always module-local.</p><p>A variable name can be "reserved" without assigning to it by declaring it as <code>global x</code>. This prevents name conflicts for globals initialized after load time.</p><h3 id="Module-initialization-and-precompilation-1"><a class="docs-heading-anchor" href="#Module-initialization-and-precompilation-1">Module initialization and precompilation</a><a class="docs-heading-anchor-permalink" href="#Module-initialization-and-precompilation-1" title="Permalink"></a></h3><p>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</p><p>The incremental precompiled module file are created and used automatically when using <code>import</code> or <code>using</code> to load a module.  This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call <a href="../../base/base/#Base.compilecache"><code>Base.compilecache(modulename)</code></a>. The resulting cache files will be stored in <code>DEPOT_PATH[1]/compiled/</code>. Subsequently, the module is automatically recompiled upon <code>using</code> or <code>import</code> whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by <a href="../../base/base/#Base.include_dependency"><code>include_dependency(path)</code></a> in the module file(s).</p><p>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by <code>include</code> or added explicitly by <code>include_dependency</code> is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in <code>require</code> matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</p><p>If you know that a module is <em>not</em> safe to precompile your module (for example, for one of the reasons described below), you should put <code>__precompile__(false)</code> in the module file (typically placed at the top). This will cause <code>Base.compilecache</code> to throw an error, and will cause <code>using</code> / <code>import</code> to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</p><p>You may need to be aware of certain behaviors inherent in the creation of incremental shared libraries which may require care when writing your module. For example, external state is not preserved. To accommodate this, explicitly separate any initialization steps that must occur at <em>runtime</em> from steps that can occur at <em>compile time</em>. For this purpose, Julia allows you to define an <code>__init__()</code> function in your module that executes any initialization steps that must occur at runtime. This function will not be called during compilation (<code>--output-*</code>). Effectively, you can assume it will be run exactly once in the lifetime of the code. You may, of course, call it manually if necessary, but the default is to assume this function deals with computing state for the local machine, which does not need to be â or even should not be â captured in the compiled image. It will be called after the module is loaded into a process, including if it is being loaded into an incremental compile (<code>--output-incremental=yes</code>), but not if it is being loaded into a full-compilation process.</p><p>In particular, if you define a <code>function __init__()</code> in a module, then Julia will call <code>__init__()</code> immediately <em>after</em> the module is loaded (e.g., by <code>import</code>, <code>using</code>, or <code>require</code>) at runtime for the <em>first</em> time (i.e., <code>__init__</code> is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their <code>__init__</code> functions called <em>before</em> the <code>__init__</code> of the enclosing module.</p><p>Two typical uses of <code>__init__</code> are calling runtime initialization functions of external C libraries and initializing global constants that involve pointers returned by external libraries.  For example, suppose that we are calling a C library <code>libfoo</code> that requires us to call a <code>foo_init()</code> initialization function at runtime. Suppose that we also want to define a global constant <code>foo_data_ptr</code> that holds the return value of a <code>void *foo_data()</code> function defined by <code>libfoo</code> â this constant must be initialized at runtime (not at compile time) because the pointer address will change from run to run.  You could accomplish this by defining the following <code>__init__</code> function in your module:</p><pre><code class="language-julia">const foo_data_ptr = Ref{Ptr{Cvoid}}(0)
function __init__()
    ccall((:foo_init, :libfoo), Cvoid, ())
    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())
    nothing
end</code></pre><p>Notice that it is perfectly possible to define a global inside a function like <code>__init__</code>; this is one of the advantages of using a dynamic language. But by making it a constant at global scope, we can ensure that the type is known to the compiler and allow it to generate better optimized code. Obviously, any other globals in your module that depends on <code>foo_data_ptr</code> would also have to be initialized in <code>__init__</code>.</p><p>Constants involving most Julia objects that are not produced by <a href="../../base/c/#ccall"><code>ccall</code></a> do not need to be placed in <code>__init__</code>: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (<a href="../../base/c/#Core.Ptr"><code>Ptr</code></a> objects will turn into null pointers unless they are hidden inside an <a href="../../base/base/#Base.isbits"><code>isbits</code></a> object). This includes the return values of the Julia functions <code>cfunction</code> and <a href="../../base/c/#Base.pointer"><code>pointer</code></a>.</p><p>Dictionary and set types, or in general anything that depends on the output of a <code>hash(key)</code> method, are a trickier case.  In the common case where the keys are numbers, strings, symbols, ranges, <code>Expr</code>, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile.  However, for a few other key types, such as <code>Function</code> or <code>DataType</code> and generic user-defined types where you haven't defined a <code>hash</code> method, the fallback <code>hash</code> method depends on the memory address of the object (via its <code>objectid</code>) and hence may change from run to run. If you have one of these key types, or if you aren't sure, to be safe you can initialize this dictionary from within your <code>__init__</code> function. Alternatively, you can use the <a href="../../base/collections/#Base.IdDict"><code>IdDict</code></a> dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.</p><p>When using precompilation, it is important to keep a clear sense of the distinction between the compilation phase and the execution phase. In this mode, it will often be much more clearly apparent that Julia is a compiler which allows execution of arbitrary Julia code, not a standalone interpreter that also generates compiled code.</p><p>Other known potential failure scenarios include:</p><ol><li><p>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</p><pre><code class="language-julia">mutable struct UniquedById
    myid::Int
    let counter = 0
        UniquedById() = new(counter += 1)
    end
end</code></pre><p>while the intent of this code was to give every instance a unique id, the counter value is recorded at the end of compilation. All subsequent usages of this incrementally compiled module will start from that same counter value.</p><p>Note that <code>objectid</code> (which works by hashing the memory pointer) has similar issues (see notes on <code>Dict</code> usage below).</p><p>One alternative is to use a macro to capture <a href="../../base/base/#Base.@__MODULE__"><code>@__MODULE__</code></a> and store it alone with the current <code>counter</code> value, however, it may be better to redesign the code to not depend on this global state.</p></li><li><p>Associative collections (such as <code>Dict</code> and <code>Set</code>) need to be re-hashed in <code>__init__</code>. (In the future, a mechanism may be provided to register an initializer function.)</p></li><li><p>Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</p></li><li><p>Creating accidental "copies" of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</p><pre><code class="language-julia">#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#
# instead use accessor functions:
getstdout() = Base.stdout #= best option =#
# or move the assignment into the runtime:
__init__() = global mystdout = Base.stdout #= also works =#</code></pre></li></ol><p>Several additional restrictions are placed on the operations that can be done while precompiling code to help the user avoid other wrong-behavior situations:</p><ol><li>Calling <a href="../../base/base/#Base.MainInclude.eval"><code>eval</code></a> to cause a side-effect in another module. This will also cause a warning to be emitted when the incremental precompile flag is set.</li><li><code>global const</code> statements from local scope after <code>__init__()</code> has been started (see issue #12010 for plans to add an error for this)</li><li>Replacing a module is a runtime error while doing an incremental precompile.</li></ol><p>A few other points to be aware of:</p><ol><li>No code reload / cache invalidation is performed after changes are made to the source files themselves, (including by <code>Pkg.update</code>), and no cleanup is done after <code>Pkg.rm</code></li><li>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</li><li>Expecting the filesystem to be unchanged between compile-time and runtime e.g. <a href="../../base/file/#Base.@__FILE__"><code>@__FILE__</code></a>/<code>source_path()</code> to find resources at runtime, or the BinDeps <code>@checked_lib</code> macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</li><li><code>WeakRef</code> objects and finalizers are not currently handled properly by the serializer (this will be fixed in an upcoming release).</li><li>It is usually best to avoid capturing references to instances of internal metadata objects such as <code>Method</code>, <code>MethodInstance</code>, <code>MethodTable</code>, <code>TypeMapLevel</code>, <code>TypeMapEntry</code> and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</li></ol><p>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag <code>--compiled-modules={yes|no}</code> enables you to toggle module precompilation on and off. When Julia is started with <code>--compiled-modules=no</code> the serialized modules in the compile cache are ignored when loading modules and module dependencies. <code>Base.compilecache</code> can still be called manually. The state of this command line flag is passed to <code>Pkg.build</code> to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">Â« Interfaces</a><a class="docs-footer-nextpage" href="../documentation/">Documentation Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 23 May 2020 19:14">Saturday 23 May 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>