<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="noindex" name="robots"/><title>Control Flow — Julia Language 0.5.1-pre documentation</title><link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css"/><link href="../../_static/julia.css" rel="stylesheet" type="text/css"/><link href="../../_static/julia.css" rel="stylesheet" type="text/css"/><link href="../../" rel="top" title="Julia Language 0.5.1-pre documentation"/><link href="../variables-and-scoping/" rel="next" title="Scope of Variables"/><link href="../functions/" rel="prev" title="Functions"/><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a href="http://julialang.org/"><img class="logo" src="../../_static/julia-logo.svg"/></a><div role="search"><form action="../../search/" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li><li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul><li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li><li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numerical-conversions">Numerical Conversions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li><li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul><li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics">String Basics</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#id2">Byte Array Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#operators-are-functions">Operators Are Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#dot-syntax-for-vectorizing-functions">Dot Syntax for Vectorizing Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li></ul></li><li class="toctree-l1 current"><a class="current reference internal" href="">Control Flow</a><ul><li class="toctree-l2"><a class="reference internal" href="#compound-expressions">Compound Expressions</a></li><li class="toctree-l2"><a class="reference internal" href="#conditional-evaluation">Conditional Evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li><li class="toctree-l2"><a class="reference internal" href="#exception-handling">Exception Handling</a></li><li class="toctree-l2"><a class="reference internal" href="#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#global-scope">Global Scope</a></li><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#local-scope">Local Scope</a></li><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul><li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#value-types">“Value types”</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul><li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#parametrically-constrained-varargs-methods">Parametrically-constrained Varargs methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#function-like-objects">Function-like objects</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#empty-generic-functions">Empty generic functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul><li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#constructors-and-conversion">Constructors and Conversion</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-only-constructors">Outer-only constructors</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul><li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li><li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../interfaces/">Interfaces</a><ul><li class="toctree-l2"><a class="reference internal" href="../interfaces/#iteration">Iteration</a></li><li class="toctree-l2"><a class="reference internal" href="../interfaces/#indexing">Indexing</a></li><li class="toctree-l2"><a class="reference internal" href="../interfaces/#abstract-arrays">Abstract Arrays</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul><li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../documentation/">Documentation</a><ul><li class="toctree-l2"><a class="reference internal" href="../documentation/#accessing-documentation">Accessing Documentation</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#functions-methods">Functions &amp; Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#advanced-usage">Advanced Usage</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#syntax-guide">Syntax Guide</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax">Markdown syntax</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax-extensions">Markdown Syntax Extensions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#generated-functions">Generated functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../arrays/">Multi-dimensional Arrays</a><ul><li class="toctree-l2"><a class="reference internal" href="../arrays/#arrays">Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul><li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li><li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#io-output-contextual-properties">IO Output Contextual Properties</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#channels">Channels</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#id2">Shared Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays-and-distributed-garbage-collection">Shared Arrays and Distributed Garbage Collection</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#network-requirements-for-localmanager-and-sshmanager">Network requirements for LocalManager and SSHManager</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-cookie">Cluster cookie</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#multi-threading-experimental">Multi-threading (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#threadcall-experimental">@threadcall (Experimental)</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../dates/">Date and DateTime</a><ul><li class="toctree-l2"><a class="reference internal" href="../dates/#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#durations-comparisons">Durations/Comparisons</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#accessor-functions">Accessor Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#query-functions">Query Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#adjuster-functions">Adjuster Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#period-types">Period Types</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#rounding">Rounding</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a><ul><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-types-to-julia">Mapping C Types to Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#garbage-collection-safety">Garbage Collection Safety</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#non-constant-function-specifications">Non-constant Function Specifications</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#indirect-calls">Indirect Calls</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#calling-convention">Calling Convention</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-global-variables">Accessing Global Variables</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#thread-safety">Thread-safety</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#more-about-callbacks">More About Callbacks</a></li><li class="toctree-l2"><a class="reference internal" href="../calling-c-and-fortran-code/#c">C++</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#customizing-colors">Customizing Colors</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul><li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul><li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#offline-installation-of-packages">Offline Installation of Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#custom-metadata-repository">Custom METADATA Repository</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul><li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul><li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li><li class="toctree-l1"><a class="reference internal" href="../stacktraces/">Stack Traces</a><ul><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#viewing-a-stack-trace">Viewing a stack trace</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#extracting-useful-information">Extracting useful information</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#error-handling">Error handling</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#comparison-with-backtrace">Comparison with <code class="docutils literal"><span class="pre">backtrace()</span></code></a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">@time</span></code> and pay attention to memory allocation</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write “type-stable” functions</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions-aka-function-barriers">Separate kernel functions (aka, function barriers)</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#types-with-values-as-parameters">Types with values-as-parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">@code_warntype</span></code></a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul><li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li><li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul><li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia’s <code class="docutils literal"><span class="pre">base/</span></code></a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don’t overuse try-catch</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don’t parenthesize conditions</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don’t overuse ...</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don’t use unnecessary static parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don’t overuse macros</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don’t expose unsafe operations at the interface level</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don’t overload methods of base container types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul><li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#packages-and-modules">Packages and Modules</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li></ul><ul><li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#nullables">Nullables</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-vectors-and-matrices">Sparse Vectors and Matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays">Shared Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#multi-threading">Multi-Threading</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#ccall-using-a-threadpool-experimental">ccall using a threadpool (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#synchronization-primitives">Synchronization Primitives</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#cluster-manager-interface">Cluster Manager Interface</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#low-level-matrix-operations">Low-level matrix operations</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/dates/">Dates and Time</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-and-time-types">Dates and Time Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-functions">Dates Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit Testing</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#basic-unit-tests">Basic Unit Tests</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#working-with-test-sets">Working with Test Sets</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#other-test-macros">Other Test Macros</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#broken-tests">Broken Tests</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#creating-custom-abstracttestset-types">Creating Custom <code class="docutils literal"><span class="pre">AbstractTestSet</span></code> Types</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/#llvm-interface">LLVM Interface</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/libc/">C Standard Library</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/libdl/">Dynamic Linker</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/stacktraces/">StackTraces</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/simd-types/">SIMD Support</a></li></ul><ul><li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li><li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia’s Internals</a><ul><li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/functions/">Julia Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/callconv/">Calling Conventions</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/boundscheck/">Bounds checking</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia’s C code</a><ul><li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="../../">Julia Language</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="../../">Docs</a> »</li><li>Control Flow</li><li class="wy-breadcrumbs-aside"><a href="../../_sources/manual/control-flow.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" role="main"><div class="section" id="control-flow"><span id="man-control-flow"></span><h1>Control Flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h1><p>Julia provides a variety of control flow constructs:</p><ul class="simple"><li><a class="reference internal" href="#man-compound-expressions"><span>Compound Expressions</span></a>: <code class="docutils literal"><span class="pre">begin</span></code> and <code class="docutils literal"><span class="pre">(;)</span></code>.</li><li><a class="reference internal" href="#man-conditional-evaluation"><span>Conditional Evaluation</span></a>:
<code class="docutils literal"><span class="pre">if</span></code>-<code class="docutils literal"><span class="pre">elseif</span></code>-<code class="docutils literal"><span class="pre">else</span></code> and <code class="docutils literal"><span class="pre">?:</span></code> (ternary operator).</li><li><a class="reference internal" href="#man-short-circuit-evaluation"><span>Short-Circuit Evaluation</span></a>:
<code class="docutils literal"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal"><span class="pre">||</span></code> and chained comparisons.</li><li><a class="reference internal" href="#man-loops"><span>Repeated Evaluation: Loops</span></a>: <code class="docutils literal"><span class="pre">while</span></code> and <code class="docutils literal"><span class="pre">for</span></code>.</li><li><a class="reference internal" href="#man-exception-handling"><span>Exception Handling</span></a>:
<code class="docutils literal"><span class="pre">try</span></code>-<code class="docutils literal"><span class="pre">catch</span></code>, <a class="reference internal" href="../../stdlib/base/#Base.error" title="Base.error"><code class="xref jl jl-func docutils literal"><span class="pre">error()</span></code></a> and <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code class="xref jl jl-func docutils literal"><span class="pre">throw()</span></code></a>.</li><li><a class="reference internal" href="#man-tasks"><span>Tasks (aka Coroutines)</span></a>: <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a>.</li></ul><p>The first five control flow mechanisms are standard to high-level
programming languages. <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a>s are not so standard: they provide non-local
control flow, making it possible to switch between temporarily-suspended
computations. This is a powerful construct: both exception handling and
cooperative multitasking are implemented in Julia using tasks. Everyday
programming requires no direct usage of tasks, but certain problems can
be solved much more easily by using tasks.</p><div class="section" id="compound-expressions"><span id="man-compound-expressions"></span><h2>Compound Expressions<a class="headerlink" href="#compound-expressions" title="Permalink to this headline">¶</a></h2><p>Sometimes it is convenient to have a single expression which evaluates
several subexpressions in order, returning the value of the last
subexpression as its value. There are two Julia constructs that
accomplish this: <code class="docutils literal"><span class="pre">begin</span></code> blocks and <code class="docutils literal"><span class="pre">(;)</span></code> chains. The value of both
compound expression constructs is that of the last subexpression. Here’s
an example of a <code class="docutils literal"><span class="pre">begin</span></code> block:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">z</span><span class="o">=</span><span class="k">begin</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="k">end</span><span class="mi">3</span></pre></div></div><p>Since these are fairly small, simple expressions, they could easily be
placed onto a single line, which is where the <code class="docutils literal"><span class="pre">(;)</span></code> chain syntax comes
in handy:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="mi">3</span></pre></div></div><p>This syntax is particularly useful with the terse single-line function
definition form introduced in <a class="reference internal" href="../functions/#man-functions"><span>Functions</span></a>. Although it
is typical, there is no requirement that <code class="docutils literal"><span class="pre">begin</span></code> blocks be multiline
or that <code class="docutils literal"><span class="pre">(;)</span></code> chains be single-line:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">begin</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="k">end</span><span class="mi">3</span><span class="n">julia</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="mi">3</span></pre></div></div></div><div class="section" id="conditional-evaluation"><span id="man-conditional-evaluation"></span><h2>Conditional Evaluation<a class="headerlink" href="#conditional-evaluation" title="Permalink to this headline">¶</a></h2><p>Conditional evaluation allows portions of code to be evaluated or not
evaluated depending on the value of a boolean expression. Here is the
anatomy of the <code class="docutils literal"><span class="pre">if</span></code>-<code class="docutils literal"><span class="pre">elseif</span></code>-<code class="docutils literal"><span class="pre">else</span></code> conditional syntax:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">if</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="n">println</span><span class="p">(</span><span class="s">"x is less than y"</span><span class="p">)</span><span class="k">elseif</span><span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="n">println</span><span class="p">(</span><span class="s">"x is greater than y"</span><span class="p">)</span><span class="k">else</span><span class="n">println</span><span class="p">(</span><span class="s">"x is equal to y"</span><span class="p">)</span><span class="k">end</span></pre></div></div><p>If the condition expression <code class="docutils literal"><span class="pre">x</span><span class="pre">&lt;</span><span class="pre">y</span></code> is <code class="docutils literal"><span class="pre">true</span></code>, then the corresponding block
is evaluated; otherwise the condition expression <code class="docutils literal"><span class="pre">x</span><span class="pre">&gt;</span><span class="pre">y</span></code> is evaluated, and if
it is <code class="docutils literal"><span class="pre">true</span></code>, the corresponding block is evaluated; if neither expression is
true, the <code class="docutils literal"><span class="pre">else</span></code> block is evaluated. Here it is in action:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="k">if</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="n">println</span><span class="p">(</span><span class="s">"x is less than y"</span><span class="p">)</span><span class="k">elseif</span><span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="n">println</span><span class="p">(</span><span class="s">"x is greater than y"</span><span class="p">)</span><span class="k">else</span><span class="n">println</span><span class="p">(</span><span class="s">"x is equal to y"</span><span class="p">)</span><span class="k">end</span><span class="k">end</span><span class="n">test</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">less</span><span class="n">than</span><span class="n">y</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">greater</span><span class="n">than</span><span class="n">y</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">equal</span><span class="n">to</span><span class="n">y</span></pre></div></div><p>The <code class="docutils literal"><span class="pre">elseif</span></code> and <code class="docutils literal"><span class="pre">else</span></code> blocks are optional, and as many <code class="docutils literal"><span class="pre">elseif</span></code>
blocks as desired can be used. The condition expressions in the
<code class="docutils literal"><span class="pre">if</span></code>-<code class="docutils literal"><span class="pre">elseif</span></code>-<code class="docutils literal"><span class="pre">else</span></code> construct are evaluated until the first one
evaluates to <code class="docutils literal"><span class="pre">true</span></code>, after which the associated block is evaluated,
and no further condition expressions or blocks are evaluated.</p><p><code class="docutils literal"><span class="pre">if</span></code> blocks are “leaky”, i.e. they do not introduce a local scope.
This means that new variables defined inside the <code class="docutils literal"><span class="pre">ìf</span></code> clauses can
be used after the <code class="docutils literal"><span class="pre">if</span></code> block, even if they weren’t defined before.
So, we could have defined the <code class="docutils literal"><span class="pre">test</span></code> function above as</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="k">if</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="n">relation</span><span class="o">=</span><span class="s">"less than"</span><span class="k">elseif</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="n">relation</span><span class="o">=</span><span class="s">"equal to"</span><span class="k">else</span><span class="n">relation</span><span class="o">=</span><span class="s">"greater than"</span><span class="k">end</span><span class="n">println</span><span class="p">(</span><span class="s">"x is "</span><span class="p">,</span><span class="n">relation</span><span class="p">,</span><span class="s">" y."</span><span class="p">)</span><span class="k">end</span><span class="n">test</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span></pre></div></div><p>The variable <code class="docutils literal"><span class="pre">relation</span></code> is declared inside the <code class="docutils literal"><span class="pre">if</span></code> block, but used
outside. However, when depending on this behavior, make sure all possible
code paths define a value for the variable. The following change to
the above function results in a runtime error</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="k">if</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="n">relation</span><span class="o">=</span><span class="s">"less than"</span><span class="k">elseif</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="n">relation</span><span class="o">=</span><span class="s">"equal to"</span><span class="k">end</span><span class="n">println</span><span class="p">(</span><span class="s">"x is "</span><span class="p">,</span><span class="n">relation</span><span class="p">,</span><span class="s">" y."</span><span class="p">)</span><span class="k">end</span><span class="n">test</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">less</span><span class="n">than</span><span class="n">y</span><span class="o">.</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">UndefVarError</span><span class="p">:</span><span class="n">relation</span><span class="n">not</span><span class="n">defined</span><span class="k">in</span><span class="n">test</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">,</span><span class="p">::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">7</span><span class="o">...</span></pre></div></div><p><code class="docutils literal"><span class="pre">if</span></code> blocks also return a value, which may seem unintuitive to users
coming from many other languages. This value is simply the return value
of the last executed statement in the branch that was chosen, so</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="mi">3</span><span class="n">julia</span><span class="o">&gt;</span><span class="k">if</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="s">"positive!"</span><span class="k">else</span><span class="s">"negative..."</span><span class="k">end</span><span class="s">"positive!"</span></pre></div></div><p>Note that very short conditional statements (one-liners) are frequently expressed using
Short-Circuit Evaluation in Julia, as outlined in the next section.</p><p>Unlike C, MATLAB, Perl, Python, and Ruby — but like Java, and a few
other stricter, typed languages — it is an error if the value of a
conditional expression is anything but <code class="docutils literal"><span class="pre">true</span></code> or <code class="docutils literal"><span class="pre">false</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">if</span><span class="mi">1</span><span class="n">println</span><span class="p">(</span><span class="s">"true"</span><span class="p">)</span><span class="k">end</span><span class="n">ERROR</span><span class="p">:</span><span class="n">TypeError</span><span class="p">:</span><span class="n">non</span><span class="o">-</span><span class="n">boolean</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span class="n">used</span><span class="k">in</span><span class="n">boolean</span><span class="n">context</span><span class="o">...</span></pre></div></div><p>This error indicates that the conditional was of the wrong type:
<code class="xref jl jl-obj docutils literal"><span class="pre">Int64</span></code> rather than the required <code class="xref jl jl-obj docutils literal"><span class="pre">Bool</span></code>.</p><p>The so-called “ternary operator”, <code class="docutils literal"><span class="pre">?:</span></code>, is closely related to the
<code class="docutils literal"><span class="pre">if</span></code>-<code class="docutils literal"><span class="pre">elseif</span></code>-<code class="docutils literal"><span class="pre">else</span></code> syntax, but is used where a conditional
choice between single expression values is required, as opposed to
conditional execution of longer blocks of code. It gets its name from
being the only operator in most languages taking three operands:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">?</span><span class="n">b</span><span class="p">:</span><span class="n">c</span></pre></div></div><p>The expression <code class="docutils literal"><span class="pre">a</span></code>, before the <code class="docutils literal"><span class="pre">?</span></code>, is a condition expression, and
the ternary operation evaluates the expression <code class="docutils literal"><span class="pre">b</span></code>, before the <code class="docutils literal"><span class="pre">:</span></code>,
if the condition <code class="docutils literal"><span class="pre">a</span></code> is <code class="docutils literal"><span class="pre">true</span></code> or the expression <code class="docutils literal"><span class="pre">c</span></code>, after the
<code class="docutils literal"><span class="pre">:</span></code>, if it is <code class="docutils literal"><span class="pre">false</span></code>.</p><p>The easiest way to understand this behavior is to see an example. In the
previous example, the <code class="docutils literal"><span class="pre">println</span></code> call is shared by all three branches:
the only real choice is which literal string to print. This could be
written more concisely using the ternary operator. For the sake of
clarity, let’s try a two-way version first:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">?</span><span class="s">"less than"</span><span class="p">:</span><span class="s">"not less than"</span><span class="p">)</span><span class="n">less</span><span class="n">than</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">?</span><span class="s">"less than"</span><span class="p">:</span><span class="s">"not less than"</span><span class="p">)</span><span class="n">not</span><span class="n">less</span><span class="n">than</span></pre></div></div><p>If the expression <code class="docutils literal"><span class="pre">x</span><span class="pre">&lt;</span><span class="pre">y</span></code> is true, the entire ternary operator
expression evaluates to the string <code class="docutils literal"><span class="pre">"less</span><span class="pre">than"</span></code> and otherwise it
evaluates to the string <code class="docutils literal"><span class="pre">"not</span><span class="pre">less</span><span class="pre">than"</span></code>. The original three-way
example requires chaining multiple uses of the ternary operator
together:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">=</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">y</span><span class="o">?</span><span class="s">"x is less than y"</span><span class="p">:</span><span class="n">x</span><span class="o">&gt;</span><span class="n">y</span><span class="o">?</span><span class="s">"x is greater than y"</span><span class="p">:</span><span class="s">"x is equal to y"</span><span class="p">)</span><span class="n">test</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">less</span><span class="n">than</span><span class="n">y</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">greater</span><span class="n">than</span><span class="n">y</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="n">x</span><span class="nb">is</span><span class="n">equal</span><span class="n">to</span><span class="n">y</span></pre></div></div><p>To facilitate chaining, the operator associates from right to left.</p><p>It is significant that like <code class="docutils literal"><span class="pre">if</span></code>-<code class="docutils literal"><span class="pre">elseif</span></code>-<code class="docutils literal"><span class="pre">else</span></code>, the expressions
before and after the <code class="docutils literal"><span class="pre">:</span></code> are only evaluated if the condition
expression evaluates to <code class="docutils literal"><span class="pre">true</span></code> or <code class="docutils literal"><span class="pre">false</span></code>, respectively:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">x</span><span class="p">)</span><span class="n">v</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">?</span><span class="n">v</span><span class="p">(</span><span class="s">"yes"</span><span class="p">)</span><span class="p">:</span><span class="n">v</span><span class="p">(</span><span class="s">"no"</span><span class="p">)</span><span class="n">yes</span><span class="s">"yes"</span><span class="n">julia</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="mi">2</span><span class="o">?</span><span class="n">v</span><span class="p">(</span><span class="s">"yes"</span><span class="p">)</span><span class="p">:</span><span class="n">v</span><span class="p">(</span><span class="s">"no"</span><span class="p">)</span><span class="n">no</span><span class="s">"no"</span></pre></div></div></div><div class="section" id="short-circuit-evaluation"><span id="man-short-circuit-evaluation"></span><h2>Short-Circuit Evaluation<a class="headerlink" href="#short-circuit-evaluation" title="Permalink to this headline">¶</a></h2><p>Short-circuit evaluation is quite similar to conditional evaluation. The
behavior is found in most imperative programming languages having the
<code class="docutils literal"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal"><span class="pre">||</span></code> boolean operators: in a series of boolean expressions
connected by these operators, only the minimum number of expressions are
evaluated as are necessary to determine the final boolean value of the
entire chain. Explicitly, this means that:</p><ul class="simple"><li>In the expression <code class="docutils literal"><span class="pre">a</span><span class="pre">&amp;&amp;</span><span class="pre">b</span></code>, the subexpression <code class="docutils literal"><span class="pre">b</span></code> is only
evaluated if <code class="docutils literal"><span class="pre">a</span></code> evaluates to <code class="docutils literal"><span class="pre">true</span></code>.</li><li>In the expression <code class="docutils literal"><span class="pre">a</span><span class="pre">||</span><span class="pre">b</span></code>, the subexpression <code class="docutils literal"><span class="pre">b</span></code> is only
evaluated if <code class="docutils literal"><span class="pre">a</span></code> evaluates to <code class="docutils literal"><span class="pre">false</span></code>.</li></ul><p>The reasoning is that <code class="docutils literal"><span class="pre">a</span><span class="pre">&amp;&amp;</span><span class="pre">b</span></code> must be <code class="docutils literal"><span class="pre">false</span></code> if <code class="docutils literal"><span class="pre">a</span></code> is
<code class="docutils literal"><span class="pre">false</span></code>, regardless of the value of <code class="docutils literal"><span class="pre">b</span></code>, and likewise, the value of
<code class="docutils literal"><span class="pre">a</span><span class="pre">||</span><span class="pre">b</span></code> must be true if <code class="docutils literal"><span class="pre">a</span></code> is <code class="docutils literal"><span class="pre">true</span></code>, regardless of the value of
<code class="docutils literal"><span class="pre">b</span></code>. Both <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal"><span class="pre">||</span></code> associate to the right, but <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> has
higher precedence than <code class="docutils literal"><span class="pre">||</span></code> does. It’s easy to experiment with
this behavior:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">true</span><span class="p">)</span><span class="n">t</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="n">false</span><span class="p">)</span><span class="n">f</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">true</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">false</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="n">false</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="n">false</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="n">true</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="n">true</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">true</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">false</span></pre></div></div><p>You can easily experiment in the same way with the associativity and
precedence of various combinations of <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> and <code class="docutils literal"><span class="pre">||</span></code> operators.</p><p>This behavior is frequently used in Julia to form an alternative to very short
<code class="docutils literal"><span class="pre">if</span></code> statements. Instead of <code class="docutils literal"><span class="pre">if</span><span class="pre">&lt;cond&gt;</span><span class="pre">&lt;statement&gt;</span><span class="pre">end</span></code>, one can write
<code class="docutils literal"><span class="pre">&lt;cond&gt;</span><span class="pre">&amp;&amp;</span><span class="pre">&lt;statement&gt;</span></code> (which could be read as: &lt;cond&gt; <em>and then</em> &lt;statement&gt;).
Similarly, instead of <code class="docutils literal"><span class="pre">if</span><span class="pre">!</span><span class="pre">&lt;cond&gt;</span><span class="pre">&lt;statement&gt;</span><span class="pre">end</span></code>, one can write
<code class="docutils literal"><span class="pre">&lt;cond&gt;</span><span class="pre">||</span><span class="pre">&lt;statement&gt;</span></code> (which could be read as: &lt;cond&gt; <em>or else</em> &lt;statement&gt;).</p><p>For example, a recursive factorial routine could be defined like this:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> fact</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="kt">Int</span><span class="p">)</span><span class="n">n</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">||</span><span class="nb">error</span><span class="p">(</span><span class="s">"n must be non-negative"</span><span class="p">)</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="k">return</span><span class="mi">1</span><span class="n">n</span><span class="o">*</span><span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="k">end</span><span class="n">fact</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fact</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="mi">120</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fact</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="mi">1</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fact</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">n</span><span class="n">must</span><span class="n">be</span><span class="n">non</span><span class="o">-</span><span class="n">negative</span><span class="k">in</span><span class="n">fact</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">2</span><span class="o">...</span></pre></div></div><p>Boolean operations <em>without</em> short-circuit evaluation can be done with the
bitwise boolean operators introduced in <a class="reference internal" href="../mathematical-operations/#man-mathematical-operations"><span>Mathematical Operations and Elementary Functions</span></a>:
<code class="docutils literal"><span class="pre">&amp;</span></code> and <code class="docutils literal"><span class="pre">|</span></code>. These are normal functions, which happen to support
infix operator syntax, but always evaluate their arguments:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">false</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mi">1</span><span class="mi">2</span><span class="n">true</span></pre></div></div><p>Just like condition expressions used in <code class="docutils literal"><span class="pre">if</span></code>, <code class="docutils literal"><span class="pre">elseif</span></code> or the
ternary operator, the operands of <code class="docutils literal"><span class="pre">&amp;&amp;</span></code> or <code class="docutils literal"><span class="pre">||</span></code> must be boolean
values (<code class="docutils literal"><span class="pre">true</span></code> or <code class="docutils literal"><span class="pre">false</span></code>). Using a non-boolean value anywhere
except for the last entry in a conditional chain is an error:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="n">true</span><span class="n">ERROR</span><span class="p">:</span><span class="n">TypeError</span><span class="p">:</span><span class="n">non</span><span class="o">-</span><span class="n">boolean</span><span class="p">(</span><span class="kt">Int64</span><span class="p">)</span><span class="n">used</span><span class="k">in</span><span class="n">boolean</span><span class="n">context</span><span class="o">...</span></pre></div></div><p>On the other hand, any type of expression can be used at the end of a conditional chain.
It will be evaluated and returned depending on the preceding conditionals:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">true</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="mi">2</span><span class="n">×2</span><span class="n">Array</span><span class="p">{</span><span class="kt">Float64</span><span class="p">,</span><span class="mi">2</span><span class="p">}:</span><span class="mf">0.768448</span><span class="mf">0.673959</span><span class="mf">0.940515</span><span class="mf">0.395453</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">false</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="n">false</span></pre></div></div></div><div class="section" id="repeated-evaluation-loops"><span id="man-loops"></span><h2>Repeated Evaluation: Loops<a class="headerlink" href="#repeated-evaluation-loops" title="Permalink to this headline">¶</a></h2><p>There are two constructs for repeated evaluation of expressions: the
<code class="docutils literal"><span class="pre">while</span></code> loop and the <code class="docutils literal"><span class="pre">for</span></code> loop. Here is an example of a <code class="docutils literal"><span class="pre">while</span></code>
loop:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">julia</span><span class="o">&gt;</span><span class="k">while</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">5</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="k">end</span><span class="mi">1</span><span class="mi">2</span><span class="mi">3</span><span class="mi">4</span><span class="mi">5</span></pre></div></div><p>The <code class="docutils literal"><span class="pre">while</span></code> loop evaluates the condition expression (<code class="docutils literal"><span class="pre">i</span><span class="pre">&lt;=</span><span class="pre">5</span></code> in this
case), and as long it remains <code class="docutils literal"><span class="pre">true</span></code>, keeps also evaluating the body
of the <code class="docutils literal"><span class="pre">while</span></code> loop. If the condition expression is <code class="docutils literal"><span class="pre">false</span></code> when the
<code class="docutils literal"><span class="pre">while</span></code> loop is first reached, the body is never evaluated.</p><p>The <code class="docutils literal"><span class="pre">for</span></code> loop makes common repeated evaluation idioms easier to
write. Since counting up and down like the above <code class="docutils literal"><span class="pre">while</span></code> loop does is
so common, it can be expressed more concisely with a <code class="docutils literal"><span class="pre">for</span></code> loop:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="k">end</span><span class="mi">1</span><span class="mi">2</span><span class="mi">3</span><span class="mi">4</span><span class="mi">5</span></pre></div></div><p>Here the <code class="docutils literal"><span class="pre">1:5</span></code> is a <code class="docutils literal"><span class="pre">Range</span></code> object, representing the sequence of
numbers 1, 2, 3, 4, 5. The <code class="docutils literal"><span class="pre">for</span></code> loop iterates through these values,
assigning each one in turn to the variable <code class="docutils literal"><span class="pre">i</span></code>. One rather important
distinction between the previous <code class="docutils literal"><span class="pre">while</span></code> loop form and the <code class="docutils literal"><span class="pre">for</span></code>
loop form is the scope during which the variable is visible. If the
variable <code class="docutils literal"><span class="pre">i</span></code> has not been introduced in an other scope, in the <code class="docutils literal"><span class="pre">for</span></code>
loop form, it is visible only inside of the <code class="docutils literal"><span class="pre">for</span></code> loop, and not
afterwards. You’ll either need a new interactive session instance or a
different variable name to test this:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="n">println</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="k">end</span><span class="mi">1</span><span class="mi">2</span><span class="mi">3</span><span class="mi">4</span><span class="mi">5</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">j</span><span class="n">ERROR</span><span class="p">:</span><span class="n">UndefVarError</span><span class="p">:</span><span class="n">j</span><span class="n">not</span><span class="n">defined</span><span class="o">...</span></pre></div></div><p>See <a class="reference internal" href="../variables-and-scoping/#man-variables-and-scoping"><span>Scope of Variables</span></a> for a detailed
explanation of variable scope and how it works in Julia.</p><p>In general, the <code class="docutils literal"><span class="pre">for</span></code> loop construct can iterate over any container.
In these cases, the alternative (but fully equivalent) keyword <code class="docutils literal"><span class="pre">in</span></code>
or <code class="docutils literal"><span class="pre">∈</span></code> is typically used instead of <code class="docutils literal"><span class="pre">=</span></code>, since it makes the code read more
clearly:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">i</span><span class="k">in</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="k">end</span><span class="mi">1</span><span class="mi">4</span><span class="mi">0</span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">s</span><span class="n">∈</span><span class="p">[</span><span class="s">"foo"</span><span class="p">,</span><span class="s">"bar"</span><span class="p">,</span><span class="s">"baz"</span><span class="p">]</span><span class="n">println</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="k">end</span><span class="n">foo</span><span class="n">bar</span><span class="n">baz</span></pre></div></div><p>Various types of iterable containers will be introduced and discussed in
later sections of the manual (see, e.g., <a class="reference internal" href="../arrays/#man-arrays"><span>Multi-dimensional Arrays</span></a>).</p><p>It is sometimes convenient to terminate the repetition of a <code class="docutils literal"><span class="pre">while</span></code>
before the test condition is falsified or stop iterating in a <code class="docutils literal"><span class="pre">for</span></code>
loop before the end of the iterable object is reached. This can be
accomplished with the <code class="docutils literal"><span class="pre">break</span></code> keyword:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">julia</span><span class="o">&gt;</span><span class="k">while</span><span class="n">true</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="k">if</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">5</span><span class="k">break</span><span class="k">end</span><span class="n">i</span><span class="o">+=</span><span class="mi">1</span><span class="k">end</span><span class="mi">1</span><span class="mi">2</span><span class="mi">3</span><span class="mi">4</span><span class="mi">5</span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">1000</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="k">if</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">5</span><span class="k">break</span><span class="k">end</span><span class="k">end</span><span class="mi">1</span><span class="mi">2</span><span class="mi">3</span><span class="mi">4</span><span class="mi">5</span></pre></div></div><p>The above <code class="docutils literal"><span class="pre">while</span></code> loop would never terminate on its own, and the
<code class="docutils literal"><span class="pre">for</span></code> loop would iterate up to 1000. These loops are both exited early
by using the <code class="docutils literal"><span class="pre">break</span></code> keyword.</p><p>In other circumstances, it is handy to be able to stop an iteration and
move on to the next one immediately. The <code class="docutils literal"><span class="pre">continue</span></code> keyword
accomplishes this:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="k">if</span><span class="n">i</span><span class="o">%</span><span class="mi">3</span><span class="o">!=</span><span class="mi">0</span><span class="k">continue</span><span class="k">end</span><span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="k">end</span><span class="mi">3</span><span class="mi">6</span><span class="mi">9</span></pre></div></div><p>This is a somewhat contrived example since we could produce the same
behavior more clearly by negating the condition and placing the
<code class="docutils literal"><span class="pre">println</span></code> call inside the <code class="docutils literal"><span class="pre">if</span></code> block. In realistic usage there is
more code to be evaluated after the <code class="docutils literal"><span class="pre">continue</span></code>, and often there are
multiple points from which one calls <code class="docutils literal"><span class="pre">continue</span></code>.</p><p>Multiple nested <code class="docutils literal"><span class="pre">for</span></code> loops can be combined into a single outer loop,
forming the cartesian product of its iterables:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="n">println</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="k">end</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span></pre></div></div><p>A <code class="docutils literal"><span class="pre">break</span></code> statement inside such a loop exits the entire nest of loops,
not just the inner one.</p></div><div class="section" id="exception-handling"><span id="man-exception-handling"></span><h2>Exception Handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h2><p>When an unexpected condition occurs, a function may be unable to return
a reasonable value to its caller. In such cases, it may be best for the
exceptional condition to either terminate the program, printing a
diagnostic error message, or if the programmer has provided code to
handle such exceptional circumstances, allow that code to take the
appropriate action.</p><div class="section" id="built-in-exceptions"><h3>Built-in <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s<a class="headerlink" href="#built-in-exceptions" title="Permalink to this headline">¶</a></h3><p><code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s are thrown when an unexpected condition has occurred. The
built-in <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s listed below all interrupt the normal flow of control.</p><table border="1" class="docutils"><colgroup><col width="100%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head"><code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code></th></tr></thead><tbody valign="top"><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.ArgumentError" title="Base.ArgumentError"><code class="xref jl jl-exc docutils literal"><span class="pre">ArgumentError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.BoundsError" title="Base.BoundsError"><code class="xref jl jl-exc docutils literal"><span class="pre">BoundsError</span></code></a></td></tr><tr class="row-even"><td><code class="xref jl jl-exc docutils literal"><span class="pre">CompositeException</span></code></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.DivideError" title="Base.DivideError"><code class="xref jl jl-exc docutils literal"><span class="pre">DivideError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code class="xref jl jl-exc docutils literal"><span class="pre">DomainError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.EOFError" title="Base.EOFError"><code class="xref jl jl-exc docutils literal"><span class="pre">EOFError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.ErrorException" title="Base.ErrorException"><code class="xref jl jl-exc docutils literal"><span class="pre">ErrorException</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.InexactError" title="Base.InexactError"><code class="xref jl jl-exc docutils literal"><span class="pre">InexactError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.InitError" title="Base.InitError"><code class="xref jl jl-exc docutils literal"><span class="pre">InitError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.InterruptException" title="Base.InterruptException"><code class="xref jl jl-exc docutils literal"><span class="pre">InterruptException</span></code></a></td></tr><tr class="row-even"><td><code class="xref jl jl-exc docutils literal"><span class="pre">InvalidStateException</span></code></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.KeyError" title="Base.KeyError"><code class="xref jl jl-exc docutils literal"><span class="pre">KeyError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.LoadError" title="Base.LoadError"><code class="xref jl jl-exc docutils literal"><span class="pre">LoadError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.OutOfMemoryError" title="Base.OutOfMemoryError"><code class="xref jl jl-exc docutils literal"><span class="pre">OutOfMemoryError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.ReadOnlyMemoryError" title="Base.ReadOnlyMemoryError"><code class="xref jl jl-exc docutils literal"><span class="pre">ReadOnlyMemoryError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/parallel/#Base.RemoteException" title="Base.RemoteException"><code class="xref jl jl-exc docutils literal"><span class="pre">RemoteException</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.MethodError" title="Base.MethodError"><code class="xref jl jl-exc docutils literal"><span class="pre">MethodError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.OverflowError" title="Base.OverflowError"><code class="xref jl jl-exc docutils literal"><span class="pre">OverflowError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.ParseError" title="Base.ParseError"><code class="xref jl jl-exc docutils literal"><span class="pre">ParseError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.SystemError" title="Base.SystemError"><code class="xref jl jl-exc docutils literal"><span class="pre">SystemError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.TypeError" title="Base.TypeError"><code class="xref jl jl-exc docutils literal"><span class="pre">TypeError</span></code></a></td></tr><tr class="row-odd"><td><a class="reference internal" href="../../stdlib/base/#Base.UndefRefError" title="Base.UndefRefError"><code class="xref jl jl-exc docutils literal"><span class="pre">UndefRefError</span></code></a></td></tr><tr class="row-even"><td><a class="reference internal" href="../../stdlib/base/#Base.UndefVarError" title="Base.UndefVarError"><code class="xref jl jl-exc docutils literal"><span class="pre">UndefVarError</span></code></a></td></tr><tr class="row-odd"><td><code class="xref jl jl-exc docutils literal"><span class="pre">UnicodeError</span></code></td></tr></tbody></table><p>For example, the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></code></a> function throws a <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code class="xref jl jl-exc docutils literal"><span class="pre">DomainError</span></code></a> if applied to a
negative real value:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">DomainError</span><span class="p">:</span><span class="n">sqrt</span><span class="n">will</span><span class="n">only</span><span class="k">return</span><span class="n">a</span><span class="n">complex</span><span class="n">result</span><span class="k">if</span><span class="n">called</span><span class="n">with</span><span class="n">a</span><span class="n">complex</span><span class="n">argument</span><span class="o">.</span><span class="n">Try</span><span class="n">sqrt</span><span class="p">(</span><span class="n">complex</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="k">in</span><span class="n">sqrt</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">math</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">211</span><span class="o">...</span></pre></div></div><p>You may define your own exceptions in the following way:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">type</span><span class="nc"> MyCustomException</span><span class="o">&lt;:</span><span class="n">Exception</span><span class="k">end</span></pre></div></div></div><div class="section" id="the-throw-function"><h3>The <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code class="xref jl jl-func docutils literal"><span class="pre">throw()</span></code></a> function<a class="headerlink" href="#the-throw-function" title="Permalink to this headline">¶</a></h3><p>Exceptions can be created explicitly with <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code class="xref jl jl-func docutils literal"><span class="pre">throw()</span></code></a>. For example, a function
defined only for nonnegative numbers could be written to <a class="reference internal" href="../../stdlib/base/#Base.throw" title="Base.throw"><code class="xref jl jl-func docutils literal"><span class="pre">throw()</span></code></a> a <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code class="xref jl jl-exc docutils literal"><span class="pre">DomainError</span></code></a>
if the argument is negative:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">?</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="p">:</span><span class="nb">throw</span><span class="p">(</span><span class="n">DomainError</span><span class="p">())</span><span class="n">f</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="mf">0.36787944117144233</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">DomainError</span><span class="p">:</span><span class="k">in</span><span class="n">f</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">1</span><span class="o">...</span></pre></div></div><p>Note that <a class="reference internal" href="../../stdlib/base/#Base.DomainError" title="Base.DomainError"><code class="xref jl jl-exc docutils literal"><span class="pre">DomainError</span></code></a> without parentheses is not an exception, but a type of
exception. It needs to be called to obtain an <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code> object:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="nb">typeof</span><span class="p">(</span><span class="n">DomainError</span><span class="p">())</span><span class="o">&lt;:</span><span class="n">Exception</span><span class="n">true</span><span class="n">julia</span><span class="o">&gt;</span><span class="nb">typeof</span><span class="p">(</span><span class="n">DomainError</span><span class="p">)</span><span class="o">&lt;:</span><span class="n">Exception</span><span class="n">false</span></pre></div></div><p>Additionally, some exception types take one or more arguments that are used for
error reporting:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="nb">throw</span><span class="p">(</span><span class="n">UndefVarError</span><span class="p">(:</span><span class="n">x</span><span class="p">))</span><span class="n">ERROR</span><span class="p">:</span><span class="n">UndefVarError</span><span class="p">:</span><span class="n">x</span><span class="n">not</span><span class="n">defined</span><span class="o">...</span></pre></div></div><p>This mechanism can be implemented easily by custom exception types following
the way <a class="reference internal" href="../../stdlib/base/#Base.UndefVarError" title="Base.UndefVarError"><code class="xref jl jl-exc docutils literal"><span class="pre">UndefVarError</span></code></a> is written:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">type</span><span class="nc"> MyUndefVarError</span><span class="o">&lt;:</span><span class="n">Exception</span><span class="n">var</span><span class="p">::</span><span class="n">Symbol</span><span class="k">end</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">Base</span><span class="o">.</span><span class="n">showerror</span><span class="p">(</span><span class="n">io</span><span class="p">::</span><span class="n">IO</span><span class="p">,</span><span class="n">e</span><span class="p">::</span><span class="n">MyUndefVarError</span><span class="p">)</span><span class="o">=</span><span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span><span class="n">e</span><span class="o">.</span><span class="n">var</span><span class="p">,</span><span class="s">" not defined"</span><span class="p">);</span></pre></div></div></div><div class="section" id="errors"><h3>Errors<a class="headerlink" href="#errors" title="Permalink to this headline">¶</a></h3><p>The <a class="reference internal" href="../../stdlib/base/#Base.error" title="Base.error"><code class="xref jl jl-func docutils literal"><span class="pre">error()</span></code></a> function is used to produce an <a class="reference internal" href="../../stdlib/base/#Base.ErrorException" title="Base.ErrorException"><code class="xref jl jl-exc docutils literal"><span class="pre">ErrorException</span></code></a> that
interrupts the normal flow of control.</p><p>Suppose we want to stop execution immediately if the square root of a
negative number is taken. To do this, we can define a fussy version of
the <a class="reference internal" href="../../stdlib/math/#Base.sqrt" title="Base.sqrt"><code class="xref jl jl-func docutils literal"><span class="pre">sqrt()</span></code></a> function that raises an error if its argument is negative:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fussy_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">?</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">:</span><span class="nb">error</span><span class="p">(</span><span class="s">"negative x not allowed"</span><span class="p">)</span><span class="n">fussy_sqrt</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fussy_sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="mf">1.4142135623730951</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">fussy_sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">negative</span><span class="n">x</span><span class="n">not</span><span class="n">allowed</span><span class="k">in</span><span class="n">fussy_sqrt</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">1</span><span class="o">...</span></pre></div></div><p>If <code class="docutils literal"><span class="pre">fussy_sqrt</span></code> is called with a negative value from another function,
instead of trying to continue execution of the calling function, it
returns immediately, displaying the error message in the interactive
session:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> verbose_fussy_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"before fussy_sqrt"</span><span class="p">)</span><span class="n">r</span><span class="o">=</span><span class="n">fussy_sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="s">"after fussy_sqrt"</span><span class="p">)</span><span class="k">return</span><span class="n">r</span><span class="k">end</span><span class="n">verbose_fussy_sqrt</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">verbose_fussy_sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="n">before</span><span class="n">fussy_sqrt</span><span class="n">after</span><span class="n">fussy_sqrt</span><span class="mf">1.4142135623730951</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">verbose_fussy_sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="n">before</span><span class="n">fussy_sqrt</span><span class="n">ERROR</span><span class="p">:</span><span class="n">negative</span><span class="n">x</span><span class="n">not</span><span class="n">allowed</span><span class="k">in</span><span class="n">fussy_sqrt</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">1</span><span class="p">[</span><span class="n">inlined</span><span class="p">]</span><span class="k">in</span><span class="n">verbose_fussy_sqrt</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">3</span><span class="o">...</span></pre></div></div></div><div class="section" id="warnings-and-informational-messages"><h3>Warnings and informational messages<a class="headerlink" href="#warnings-and-informational-messages" title="Permalink to this headline">¶</a></h3><p>Julia also provides other functions that write messages to the standard error
I/O, but do not throw any <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s and hence do not interrupt
execution:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">info</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">);</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">INFO</span><span class="p">:</span><span class="n">Hi</span><span class="mi">2</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">warn</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">);</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">WARNING</span><span class="p">:</span><span class="n">Hi</span><span class="mi">2</span><span class="n">julia</span><span class="o">&gt;</span><span class="nb">error</span><span class="p">(</span><span class="s">"Hi"</span><span class="p">);</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">ERROR</span><span class="p">:</span><span class="n">Hi</span><span class="k">in</span><span class="nb">error</span><span class="p">(::</span><span class="n">String</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="nb">error</span><span class="o">.</span><span class="n">jl</span><span class="p">:</span><span class="mi">21</span><span class="o">...</span></pre></div></div></div><div class="section" id="the-try-catch-statement"><h3>The <code class="docutils literal"><span class="pre">try/catch</span></code> statement<a class="headerlink" href="#the-try-catch-statement" title="Permalink to this headline">¶</a></h3><p>The <code class="docutils literal"><span class="pre">try/catch</span></code> statement allows for <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s to be tested for. For
example, a customized square root function can be written to automatically
call either the real or complex square root method on demand using
<code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code>s :</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="k">try</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">catch</span><span class="n">sqrt</span><span class="p">(</span><span class="n">complex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="k">end</span><span class="n">f</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="mf">1.0</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">f</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="mf">0.0</span><span class="o">+</span><span class="mf">1.0</span><span class="nb">im</span></pre></div></div><p>It is important to note that in real code computing this function, one would
compare <code class="docutils literal"><span class="pre">x</span></code> to zero instead of catching an exception. The exception is much
slower than simply comparing and branching.</p><p><code class="docutils literal"><span class="pre">try/catch</span></code> statements also allow the <code class="xref jl jl-exc docutils literal"><span class="pre">Exception</span></code> to be saved in a
variable. In this contrived example, the following example calculates the
square root of the second element of <code class="docutils literal"><span class="pre">x</span></code> if <code class="docutils literal"><span class="pre">x</span></code> is indexable, otherwise
assumes <code class="docutils literal"><span class="pre">x</span></code> is a real number and returns its square root:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt_second</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="k">try</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="k">catch</span><span class="n">y</span><span class="k">if</span><span class="nb">isa</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">DomainError</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">complex</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">))</span><span class="k">elseif</span><span class="nb">isa</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">BoundsError</span><span class="p">)</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">end</span><span class="k">end</span><span class="n">sqrt_second</span><span class="p">(</span><span class="n">generic</span><span class="k">function</span><span class="nf"> with</span><span class="mi">1</span><span class="n">method</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt_second</span><span class="p">([</span><span class="mi">1</span><span class="mi">4</span><span class="p">])</span><span class="mf">2.0</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt_second</span><span class="p">([</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span><span class="mf">0.0</span><span class="o">+</span><span class="mf">2.0</span><span class="nb">im</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt_second</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="mf">3.0</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">sqrt_second</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span><span class="n">ERROR</span><span class="p">:</span><span class="n">DomainError</span><span class="p">:</span><span class="k">in</span><span class="n">sqrt_second</span><span class="p">(::</span><span class="kt">Int64</span><span class="p">)</span><span class="n">at</span><span class="o">./</span><span class="n">none</span><span class="p">:</span><span class="mi">7</span><span class="o">...</span></pre></div></div><p>Note that the symbol following <code class="docutils literal"><span class="pre">catch</span></code> will always be interpreted as a
name for the exception, so care is needed when writing <code class="docutils literal"><span class="pre">try/catch</span></code> expressions
on a single line. The following code will <em>not</em> work to return the value of <code class="docutils literal"><span class="pre">x</span></code>
in case of an error:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">try</span><span class="n">bad</span><span class="p">()</span><span class="k">catch</span><span class="n">x</span><span class="k">end</span></pre></div></div><p>Instead, use a semicolon or insert a line break after <code class="docutils literal"><span class="pre">catch</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">try</span><span class="n">bad</span><span class="p">()</span><span class="k">catch</span><span class="p">;</span><span class="n">x</span><span class="k">end</span><span class="k">try</span><span class="n">bad</span><span class="p">()</span><span class="k">catch</span><span class="n">x</span><span class="k">end</span></pre></div></div><p>The <code class="docutils literal"><span class="pre">catch</span></code> clause is not strictly necessary; when omitted, the default
return value is <code class="docutils literal"><span class="pre">nothing</span></code>.</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">try</span><span class="nb">error</span><span class="p">()</span><span class="k">end</span><span class="c">#Returns nothing</span></pre></div></div><p>The power of the <code class="docutils literal"><span class="pre">try/catch</span></code> construct lies in the ability to unwind a deeply
nested computation immediately to a much higher level in the stack of calling
functions. There are situations where no error has occurred, but the ability to
unwind the stack and pass a value to a higher level is desirable. Julia
provides the <a class="reference internal" href="../../stdlib/base/#Base.rethrow" title="Base.rethrow"><code class="xref jl jl-func docutils literal"><span class="pre">rethrow()</span></code></a>, <a class="reference internal" href="../../stdlib/base/#Base.backtrace" title="Base.backtrace"><code class="xref jl jl-func docutils literal"><span class="pre">backtrace()</span></code></a> and <a class="reference internal" href="../../stdlib/base/#Base.catch_backtrace" title="Base.catch_backtrace"><code class="xref jl jl-func docutils literal"><span class="pre">catch_backtrace()</span></code></a> functions for
more advanced error handling.</p></div><div class="section" id="finally-clauses"><h3>finally Clauses<a class="headerlink" href="#finally-clauses" title="Permalink to this headline">¶</a></h3><p>In code that performs state changes or uses resources like files, there is
typically clean-up work (such as closing files) that needs to be done when the
code is finished. Exceptions potentially complicate this task, since they can
cause a block of code to exit before reaching its normal end. The <code class="docutils literal"><span class="pre">finally</span></code>
keyword provides a way to run some code when a given block of code exits,
regardless of how it exits.</p><p>For example, here is how we can guarantee that an opened file is closed:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">f</span><span class="o">=</span><span class="n">open</span><span class="p">(</span><span class="s">"file"</span><span class="p">)</span><span class="k">try</span><span class="c"># operate on file f</span><span class="n">finally</span><span class="n">close</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="k">end</span></pre></div></div><p>When control leaves the <code class="docutils literal"><span class="pre">try</span></code> block (for example due to a <code class="docutils literal"><span class="pre">return</span></code>, or
just finishing normally), <code class="docutils literal"><span class="pre">close(f)</span></code> will be executed. If
the <code class="docutils literal"><span class="pre">try</span></code> block exits due to an exception, the exception will continue
propagating. A <code class="docutils literal"><span class="pre">catch</span></code> block may be combined with <code class="docutils literal"><span class="pre">try</span></code> and <code class="docutils literal"><span class="pre">finally</span></code>
as well. In this case the <code class="docutils literal"><span class="pre">finally</span></code> block will run after <code class="docutils literal"><span class="pre">catch</span></code> has
handled the error.</p></div></div><div class="section" id="tasks-aka-coroutines"><span id="man-tasks"></span><h2>Tasks (aka Coroutines)<a class="headerlink" href="#tasks-aka-coroutines" title="Permalink to this headline">¶</a></h2><p>Tasks are a control flow feature that allows computations to be
suspended and resumed in a flexible manner. This feature is sometimes
called by other names, such as symmetric coroutines, lightweight
threads, cooperative multitasking, or one-shot continuations.</p><p>When a piece of computing work (in practice, executing a particular
function) is designated as a <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a>, it becomes possible to interrupt
it by switching to another <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a>. The original <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a> can later be
resumed, at which point it will pick up right where it left off. At
first, this may seem similar to a function call. However there are two
key differences. First, switching tasks does not use any space, so any
number of task switches can occur without consuming the call stack.
Second, switching among tasks can occur in any order, unlike function calls,
where the called function must finish executing before control returns
to the calling function.</p><p>This kind of control flow can make it much easier to solve certain
problems. In some problems, the various pieces of required work are not
naturally related by function calls; there is no obvious “caller” or
“callee” among the jobs that need to be done. An example is the
producer-consumer problem, where one complex procedure is generating
values and another complex procedure is consuming them. The consumer
cannot simply call a producer function to get a value, because the
producer may have more values to generate and so might not yet be ready
to return. With tasks, the producer and consumer can both run as long as
they need to, passing values back and forth as necessary.</p><p>Julia provides the functions <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code class="xref jl jl-func docutils literal"><span class="pre">consume()</span></code></a> for solving
this problem. A producer is a function that calls <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> on each
value it needs to produce:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">function</span><span class="nf"> producer</span><span class="p">()</span><span class="n">produce</span><span class="p">(</span><span class="s">"start"</span><span class="p">)</span><span class="k">for</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="n">produce</span><span class="p">(</span><span class="mi">2</span><span class="n">n</span><span class="p">)</span><span class="k">end</span><span class="n">produce</span><span class="p">(</span><span class="s">"stop"</span><span class="p">)</span><span class="k">end</span><span class="p">;</span></pre></div></div><p>To consume values, first the producer is wrapped in a <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a>,
then <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code class="xref jl jl-func docutils literal"><span class="pre">consume()</span></code></a> is called repeatedly on that object:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">p</span><span class="o">=</span><span class="n">Task</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="s">"start"</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="mi">2</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="mi">4</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="mi">6</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="mi">8</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">consume</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="s">"stop"</span></pre></div></div><p>One way to think of this behavior is that <code class="docutils literal"><span class="pre">producer</span></code> was able to
return multiple times. Between calls to <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a>, the producer’s
execution is suspended and the consumer has control.</p><p>A Task can be used as an iterable object in a <code class="docutils literal"><span class="pre">for</span></code> loop, in which
case the loop variable takes on all the produced values:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="k">for</span><span class="n">x</span><span class="k">in</span><span class="n">Task</span><span class="p">(</span><span class="n">producer</span><span class="p">)</span><span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="k">end</span><span class="n">start</span><span class="mi">2</span><span class="mi">4</span><span class="mi">6</span><span class="mi">8</span><span class="n">stop</span></pre></div></div><p>Note that the <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-func docutils literal"><span class="pre">Task()</span></code></a> constructor expects a 0-argument function. A
common pattern is for the producer to be parameterized, in which case a
partial function application is needed to create a 0-argument <a class="reference internal" href="../functions/#man-anonymous-functions"><span>anonymous
function</span></a>. This can be done either
directly or by use of a convenience macro:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> mytask</span><span class="p">(</span><span class="n">myarg</span><span class="p">)</span><span class="o">...</span><span class="k">end</span><span class="n">taskHdl</span><span class="o">=</span><span class="n">Task</span><span class="p">(()</span><span class="o">-&gt;</span><span class="n">mytask</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span><span class="c"># or, equivalently</span><span class="n">taskHdl</span><span class="o">=</span><span class="p">@</span><span class="n">task</span><span class="n">mytask</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span></pre></div></div><p><a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code class="xref jl jl-func docutils literal"><span class="pre">consume()</span></code></a> do not launch threads that can run on separate CPUs.
True kernel threads are discussed under the topic of <a class="reference internal" href="../parallel-computing/#man-parallel-computing"><span>Parallel Computing</span></a>.</p><div class="section" id="core-task-operations"><h3>Core task operations<a class="headerlink" href="#core-task-operations" title="Permalink to this headline">¶</a></h3><p>While <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> and <a class="reference internal" href="../../stdlib/parallel/#Base.consume" title="Base.consume"><code class="xref jl jl-func docutils literal"><span class="pre">consume()</span></code></a> illustrate the essential nature of tasks, they
are actually implemented as library functions using a more primitive function,
<a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a>. <code class="docutils literal"><span class="pre">yieldto(task,value)</span></code> suspends the current task, switches
to the specified <code class="docutils literal"><span class="pre">task</span></code>, and causes that task’s last <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a> call to return
the specified <code class="docutils literal"><span class="pre">value</span></code>. Notice that <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a> is the only operation required
to use task-style control flow; instead of calling and returning we are always
just switching to a different task. This is why this feature is also called
“symmetric coroutines”; each task is switched to and from using the same mechanism.</p><p><a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a> is powerful, but most uses of tasks do not invoke it directly.
Consider why this might be. If you switch away from the current task, you will
probably want to switch back to it at some point, but knowing when to switch
back, and knowing which task has the responsibility of switching back, can
require considerable coordination. For example, <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> needs to maintain
some state to remember who the consumer is. Not needing to manually keep track
of the consuming task is what makes <a class="reference internal" href="../../stdlib/parallel/#Base.produce" title="Base.produce"><code class="xref jl jl-func docutils literal"><span class="pre">produce()</span></code></a> easier to use than <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a>.</p><p>In addition to <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a>, a few other basic functions are needed to use tasks
effectively.</p><ul class="simple"><li><a class="reference internal" href="../../stdlib/parallel/#Base.current_task" title="Base.current_task"><code class="xref jl jl-func docutils literal"><span class="pre">current_task()</span></code></a> gets a reference to the currently-running task.</li><li><a class="reference internal" href="../../stdlib/parallel/#Base.istaskdone" title="Base.istaskdone"><code class="xref jl jl-func docutils literal"><span class="pre">istaskdone()</span></code></a> queries whether a task has exited.</li><li><a class="reference internal" href="../../stdlib/parallel/#Base.istaskstarted" title="Base.istaskstarted"><code class="xref jl jl-func docutils literal"><span class="pre">istaskstarted()</span></code></a> queries whether a task has run yet.</li><li><a class="reference internal" href="../../stdlib/parallel/#Base.task_local_storage" title="Base.task_local_storage"><code class="xref jl jl-func docutils literal"><span class="pre">task_local_storage()</span></code></a> manipulates a key-value store specific to the current task.</li></ul></div><div class="section" id="tasks-and-events"><h3>Tasks and events<a class="headerlink" href="#tasks-and-events" title="Permalink to this headline">¶</a></h3><p>Most task switches occur as a result of waiting for events such as I/O
requests, and are performed by a scheduler included in the standard library.
The scheduler maintains a queue of runnable tasks, and executes an event loop
that restarts tasks based on external events such as message arrival.</p><p>The basic function for waiting for an event is <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a>. Several objects
implement <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a>; for example, given a <code class="xref jl jl-class docutils literal"><span class="pre">Process</span></code> object, <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> will
wait for it to exit. <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> is often implicit; for example, a <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a>
can happen inside a call to <a class="reference internal" href="../../stdlib/io-network/#Base.read" title="Base.read"><code class="xref jl jl-func docutils literal"><span class="pre">read()</span></code></a> to wait for data to be available.</p><p>In all of these cases, <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> ultimately operates on a <a class="reference internal" href="../../stdlib/parallel/#Base.Condition" title="Base.Condition"><code class="xref jl jl-class docutils literal"><span class="pre">Condition</span></code></a>
object, which is in charge of queueing and restarting tasks. When a task
calls <a class="reference internal" href="../../stdlib/parallel/#Base.wait" title="Base.wait"><code class="xref jl jl-func docutils literal"><span class="pre">wait()</span></code></a> on a <a class="reference internal" href="../../stdlib/parallel/#Base.Condition" title="Base.Condition"><code class="xref jl jl-class docutils literal"><span class="pre">Condition</span></code></a>, the task is marked as non-runnable, added
to the condition’s queue, and switches to the scheduler. The scheduler will
then pick another task to run, or block waiting for external events.
If all goes well, eventually an event handler will call <a class="reference internal" href="../../stdlib/parallel/#Base.notify" title="Base.notify"><code class="xref jl jl-func docutils literal"><span class="pre">notify()</span></code></a> on the
condition, which causes tasks waiting for that condition to become runnable
again.</p><p>A task created explicitly by calling <a class="reference internal" href="../../stdlib/parallel/#Base.Task" title="Base.Task"><code class="xref jl jl-class docutils literal"><span class="pre">Task</span></code></a> is initially not known to the
scheduler. This allows you to manage tasks manually using <a class="reference internal" href="../../stdlib/parallel/#Base.yieldto" title="Base.yieldto"><code class="xref jl jl-func docutils literal"><span class="pre">yieldto()</span></code></a> if
you wish. However, when such a task waits for an event, it still gets restarted
automatically when the event happens, as you would expect. It is also
possible to make the scheduler run a task whenever it can, without necessarily
waiting for any events. This is done by calling <a class="reference internal" href="../../stdlib/parallel/#Base.schedule" title="Base.schedule"><code class="xref jl jl-func docutils literal"><span class="pre">schedule()</span></code></a>, or using
the <a class="reference internal" href="../../stdlib/parallel/#Base.@schedule" title="Base.@schedule"><code class="xref jl jl-obj docutils literal"><span class="pre">@schedule</span></code></a> or <a class="reference internal" href="../../stdlib/parallel/#Base.@async" title="Base.@async"><code class="xref jl jl-obj docutils literal"><span class="pre">@async</span></code></a> macros (see <a class="reference internal" href="../parallel-computing/#man-parallel-computing"><span>Parallel Computing</span></a> for
more details).</p></div><div class="section" id="task-states"><h3>Task states<a class="headerlink" href="#task-states" title="Permalink to this headline">¶</a></h3><p>Tasks have a <code class="docutils literal"><span class="pre">state</span></code> field that describes their execution status. A task
state is one of the following symbols:</p><table border="1" class="docutils"><colgroup><col width="21%"/><col width="79%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">Symbol</th><th class="head">Meaning</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">:runnable</span></code></td><td>Currently running, or available to be switched to</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">:waiting</span></code></td><td>Blocked waiting for a specific event</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">:queued</span></code></td><td>In the scheduler’s run queue about to be restarted</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">:done</span></code></td><td>Successfully finished executing</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">:failed</span></code></td><td>Finished with an uncaught exception</td></tr></tbody></table></div></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a class="btn btn-neutral float-right" href="../variables-and-scoping/" title="Scope of Variables">Next <span class="fa fa-arrow-circle-right"></span></a><a class="btn btn-neutral" href="../functions/" title="Functions"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p></p></div><a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a></footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.5.1-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script><script src="../../_static/jquery.js" type="text/javascript"></script><script src="../../_static/underscore.js" type="text/javascript"></script><script src="../../_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="../../_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script></body></HTML>