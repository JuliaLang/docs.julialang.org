<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="noindex" name="robots"/><title>Calling C and Fortran Code — Julia Language 0.5.1-pre documentation</title><link href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css"/><link href="../../_static/julia.css" rel="stylesheet" type="text/css"/><link href="../../_static/julia.css" rel="stylesheet" type="text/css"/><link href="../../" rel="top" title="Julia Language 0.5.1-pre documentation"/><link href="../handling-operating-system-variation/" rel="next" title="Handling Operating System Variation"/><link href="../running-external-programs/" rel="prev" title="Running External Programs"/><script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body class="wy-body-for-nav" role="document"><div class="wy-grid-for-nav"><nav class="wy-nav-side" data-toggle="wy-nav-shift"><div class="wy-side-nav-search"><a href="http://julialang.org/"><img class="logo" src="../../_static/julia-logo.svg"/></a><div role="search"><form action="../../search/" class="wy-form" id="rtd-search-form" method="get"><input name="q" placeholder="Search docs" type="text"/><input name="check_keywords" type="hidden" value="yes"/><input name="area" type="hidden" value="default"/></form></div></div><div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation"><ul class="current"><li class="toctree-l1"><a class="reference internal" href="../introduction/">Introduction</a></li><li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a><ul><li class="toctree-l2"><a class="reference internal" href="../getting-started/#resources">Resources</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../variables/">Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="../variables/#allowed-variable-names">Allowed Variable Names</a></li><li class="toctree-l2"><a class="reference internal" href="../variables/#stylistic-conventions">Stylistic Conventions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#integers">Integers</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#floating-point-numbers">Floating-Point Numbers</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#arbitrary-precision-arithmetic">Arbitrary Precision Arithmetic</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#numeric-literal-coefficients">Numeric Literal Coefficients</a></li><li class="toctree-l2"><a class="reference internal" href="../integers-and-floating-point-numbers/#literal-zero-and-one">Literal zero and one</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#arithmetic-operators">Arithmetic Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#bitwise-operators">Bitwise Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#updating-operators">Updating operators</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numeric-comparisons">Numeric Comparisons</a></li><li class="toctree-l2"><a class="reference internal" href="../mathematical-operations/#numerical-conversions">Numerical Conversions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#complex-numbers">Complex Numbers</a></li><li class="toctree-l2"><a class="reference internal" href="../complex-and-rational-numbers/#rational-numbers">Rational Numbers</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../strings/">Strings</a><ul><li class="toctree-l2"><a class="reference internal" href="../strings/#characters">Characters</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#string-basics">String Basics</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#unicode-and-utf-8">Unicode and UTF-8</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#interpolation">Interpolation</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#triple-quoted-string-literals">Triple-Quoted String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#common-operations">Common Operations</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#non-standard-string-literals">Non-Standard String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#regular-expressions">Regular Expressions</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#id2">Byte Array Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../strings/#version-number-literals">Version Number Literals</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../functions/">Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../functions/#argument-passing-behavior">Argument Passing Behavior</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#the-return-keyword">The <code class="docutils literal"><span class="pre">return</span></code> Keyword</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#operators-are-functions">Operators Are Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#operators-with-special-names">Operators With Special Names</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#anonymous-functions">Anonymous Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#multiple-return-values">Multiple Return Values</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#varargs-functions">Varargs Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#optional-arguments">Optional Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#keyword-arguments">Keyword Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#evaluation-scope-of-default-values">Evaluation Scope of Default Values</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#do-block-syntax-for-function-arguments">Do-Block Syntax for Function Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#dot-syntax-for-vectorizing-functions">Dot Syntax for Vectorizing Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../functions/#further-reading">Further Reading</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../control-flow/">Control Flow</a><ul><li class="toctree-l2"><a class="reference internal" href="../control-flow/#compound-expressions">Compound Expressions</a></li><li class="toctree-l2"><a class="reference internal" href="../control-flow/#conditional-evaluation">Conditional Evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="../control-flow/#short-circuit-evaluation">Short-Circuit Evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="../control-flow/#repeated-evaluation-loops">Repeated Evaluation: Loops</a></li><li class="toctree-l2"><a class="reference internal" href="../control-flow/#exception-handling">Exception Handling</a></li><li class="toctree-l2"><a class="reference internal" href="../control-flow/#tasks-aka-coroutines">Tasks (aka Coroutines)</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../variables-and-scoping/">Scope of Variables</a><ul><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#global-scope">Global Scope</a></li><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#local-scope">Local Scope</a></li><li class="toctree-l2"><a class="reference internal" href="../variables-and-scoping/#constants">Constants</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../types/">Types</a><ul><li class="toctree-l2"><a class="reference internal" href="../types/#type-declarations">Type Declarations</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#abstract-types">Abstract Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#bits-types">Bits Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#composite-types">Composite Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#immutable-composite-types">Immutable Composite Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#declared-types">Declared Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#type-unions">Type Unions</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#man-parametric-types">Parametric Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#type-aliases">Type Aliases</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#operations-on-types">Operations on Types</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#value-types">“Value types”</a></li><li class="toctree-l2"><a class="reference internal" href="../types/#nullable-types-representing-missing-values">Nullable Types: Representing Missing Values</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../methods/">Methods</a><ul><li class="toctree-l2"><a class="reference internal" href="../methods/#defining-methods">Defining Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#method-ambiguities">Method Ambiguities</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#parametric-methods">Parametric Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#parametrically-constrained-varargs-methods">Parametrically-constrained Varargs methods</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#note-on-optional-and-keyword-arguments">Note on Optional and keyword Arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#function-like-objects">Function-like objects</a></li><li class="toctree-l2"><a class="reference internal" href="../methods/#empty-generic-functions">Empty generic functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../constructors/">Constructors</a><ul><li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-constructor-methods">Outer Constructor Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#inner-constructor-methods">Inner Constructor Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#incomplete-initialization">Incomplete Initialization</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#parametric-constructors">Parametric Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#case-study-rational">Case Study: Rational</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#constructors-and-conversion">Constructors and Conversion</a></li><li class="toctree-l2"><a class="reference internal" href="../constructors/#outer-only-constructors">Outer-only constructors</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../conversion-and-promotion/">Conversion and Promotion</a><ul><li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#conversion">Conversion</a></li><li class="toctree-l2"><a class="reference internal" href="../conversion-and-promotion/#promotion">Promotion</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../interfaces/">Interfaces</a><ul><li class="toctree-l2"><a class="reference internal" href="../interfaces/#iteration">Iteration</a></li><li class="toctree-l2"><a class="reference internal" href="../interfaces/#indexing">Indexing</a></li><li class="toctree-l2"><a class="reference internal" href="../interfaces/#abstract-arrays">Abstract Arrays</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../modules/">Modules</a><ul><li class="toctree-l2"><a class="reference internal" href="../modules/#summary-of-module-usage">Summary of module usage</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../documentation/">Documentation</a><ul><li class="toctree-l2"><a class="reference internal" href="../documentation/#accessing-documentation">Accessing Documentation</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#functions-methods">Functions &amp; Methods</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#advanced-usage">Advanced Usage</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#syntax-guide">Syntax Guide</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax">Markdown syntax</a></li><li class="toctree-l2"><a class="reference internal" href="../documentation/#markdown-syntax-extensions">Markdown Syntax Extensions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../metaprogramming/">Metaprogramming</a><ul><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#program-representation">Program representation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#expressions-and-evaluation">Expressions and evaluation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#macros">Macros</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#code-generation">Code Generation</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#non-standard-string-literals">Non-Standard String Literals</a></li><li class="toctree-l2"><a class="reference internal" href="../metaprogramming/#generated-functions">Generated functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../arrays/">Multi-dimensional Arrays</a><ul><li class="toctree-l2"><a class="reference internal" href="../arrays/#arrays">Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../arrays/#sparse-matrices">Sparse Matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../linear-algebra/">Linear algebra</a><ul><li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#matrix-factorizations">Matrix factorizations</a></li><li class="toctree-l2"><a class="reference internal" href="../linear-algebra/#special-matrices">Special matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../networking-and-streams/">Networking and Streams</a><ul><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#basic-stream-i-o">Basic Stream I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#text-i-o">Text I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#io-output-contextual-properties">IO Output Contextual Properties</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#working-with-files">Working with Files</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#a-simple-tcp-example">A simple TCP example</a></li><li class="toctree-l2"><a class="reference internal" href="../networking-and-streams/#resolving-ip-addresses">Resolving IP Addresses</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../parallel-computing/">Parallel Computing</a><ul><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#code-availability-and-loading-packages">Code Availability and Loading Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#data-movement">Data Movement</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#parallel-map-and-loops">Parallel Map and Loops</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#synchronization-with-remote-references">Synchronization With Remote References</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#scheduling">Scheduling</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#channels">Channels</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remote-references-and-abstractchannels">Remote references and AbstractChannels</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#remote-references-and-distributed-garbage-collection">Remote References and Distributed Garbage Collection</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#id2">Shared Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#shared-arrays-and-distributed-garbage-collection">Shared Arrays and Distributed Garbage Collection</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#clustermanagers">ClusterManagers</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-managers-with-custom-transports">Cluster Managers with custom transports</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#network-requirements-for-localmanager-and-sshmanager">Network requirements for LocalManager and SSHManager</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#cluster-cookie">Cluster cookie</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#specifying-network-topology-experimental">Specifying network topology (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#multi-threading-experimental">Multi-threading (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../parallel-computing/#threadcall-experimental">@threadcall (Experimental)</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../dates/">Date and DateTime</a><ul><li class="toctree-l2"><a class="reference internal" href="../dates/#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#durations-comparisons">Durations/Comparisons</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#accessor-functions">Accessor Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#query-functions">Query Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#timetype-period-arithmetic">TimeType-Period Arithmetic</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#adjuster-functions">Adjuster Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#period-types">Period Types</a></li><li class="toctree-l2"><a class="reference internal" href="../dates/#rounding">Rounding</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../running-external-programs/">Running External Programs</a><ul><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#interpolation">Interpolation</a></li><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#quoting">Quoting</a></li><li class="toctree-l2"><a class="reference internal" href="../running-external-programs/#pipelines">Pipelines</a></li></ul></li><li class="toctree-l1 current"><a class="current reference internal" href="">Calling C and Fortran Code</a><ul><li class="toctree-l2"><a class="reference internal" href="#creating-c-compatible-julia-function-pointers">Creating C-Compatible Julia Function Pointers</a></li><li class="toctree-l2"><a class="reference internal" href="#mapping-c-types-to-julia">Mapping C Types to Julia</a></li><li class="toctree-l2"><a class="reference internal" href="#mapping-c-functions-to-julia">Mapping C Functions to Julia</a></li><li class="toctree-l2"><a class="reference internal" href="#some-examples-of-c-wrappers">Some Examples of C Wrappers</a></li><li class="toctree-l2"><a class="reference internal" href="#garbage-collection-safety">Garbage Collection Safety</a></li><li class="toctree-l2"><a class="reference internal" href="#non-constant-function-specifications">Non-constant Function Specifications</a></li><li class="toctree-l2"><a class="reference internal" href="#indirect-calls">Indirect Calls</a></li><li class="toctree-l2"><a class="reference internal" href="#calling-convention">Calling Convention</a></li><li class="toctree-l2"><a class="reference internal" href="#accessing-global-variables">Accessing Global Variables</a></li><li class="toctree-l2"><a class="reference internal" href="#accessing-data-through-a-pointer">Accessing Data through a Pointer</a></li><li class="toctree-l2"><a class="reference internal" href="#thread-safety">Thread-safety</a></li><li class="toctree-l2"><a class="reference internal" href="#more-about-callbacks">More About Callbacks</a></li><li class="toctree-l2"><a class="reference internal" href="#c">C++</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li class="toctree-l1"><a class="reference internal" href="../interacting-with-julia/">Interacting With Julia</a><ul><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#the-different-prompt-modes">The different prompt modes</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#key-bindings">Key bindings</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#tab-completion">Tab completion</a></li><li class="toctree-l2"><a class="reference internal" href="../interacting-with-julia/#customizing-colors">Customizing Colors</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../embedding/">Embedding Julia</a><ul><li class="toctree-l2"><a class="reference internal" href="../embedding/#high-level-embedding">High-Level Embedding</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#converting-types">Converting Types</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#calling-julia-functions">Calling Julia Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#memory-management">Memory Management</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#working-with-arrays">Working with Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../embedding/#exceptions">Exceptions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../packages/">Packages</a><ul><li class="toctree-l2"><a class="reference internal" href="../packages/#package-status">Package Status</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#adding-and-removing-packages">Adding and Removing Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#offline-installation-of-packages">Offline Installation of Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#installing-unregistered-packages">Installing Unregistered Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#updating-packages">Updating Packages</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#checkout-pin-and-free">Checkout, Pin and Free</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#custom-metadata-repository">Custom METADATA Repository</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../packages/#package-development">Package Development</a><ul><li class="toctree-l2"><a class="reference internal" href="../packages/#initial-setup">Initial Setup</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#making-changes-to-an-existing-package">Making changes to an existing package</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#creating-a-new-package">Creating a new Package</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#fixing-package-requirements">Fixing Package Requirements</a></li><li class="toctree-l2"><a class="reference internal" href="../packages/#man-package-requirements">Requirements Specification</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../profile/">Profiling</a><ul><li class="toctree-l2"><a class="reference internal" href="../profile/#basic-usage">Basic usage</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#accumulation-and-clearing">Accumulation and clearing</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#options-for-controlling-the-display-of-profile-results">Options for controlling the display of profile results</a></li><li class="toctree-l2"><a class="reference internal" href="../profile/#configuration">Configuration</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../profile/#memory-allocation-analysis">Memory allocation analysis</a></li><li class="toctree-l1"><a class="reference internal" href="../stacktraces/">Stack Traces</a><ul><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#viewing-a-stack-trace">Viewing a stack trace</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#extracting-useful-information">Extracting useful information</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#error-handling">Error handling</a></li><li class="toctree-l2"><a class="reference internal" href="../stacktraces/#comparison-with-backtrace">Comparison with <code class="docutils literal"><span class="pre">backtrace()</span></code></a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../performance-tips/">Performance Tips</a><ul><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-global-variables">Avoid global variables</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#measure-performance-with-time-and-pay-attention-to-memory-allocation">Measure performance with <code class="docutils literal"><span class="pre">@time</span></code> and pay attention to memory allocation</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tools">Tools</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-containers-with-abstract-type-parameters">Avoid containers with abstract type parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#type-declarations">Type declarations</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#break-functions-into-multiple-definitions">Break functions into multiple definitions</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#write-type-stable-functions">Write “type-stable” functions</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-changing-the-type-of-a-variable">Avoid changing the type of a variable</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#separate-kernel-functions-aka-function-barriers">Separate kernel functions (aka, function barriers)</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#types-with-values-as-parameters">Types with values-as-parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#the-dangers-of-abusing-multiple-dispatch-aka-more-on-types-with-values-as-parameters">The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#access-arrays-in-memory-order-along-columns">Access arrays in memory order, along columns</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#pre-allocating-outputs">Pre-allocating outputs</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#avoid-string-interpolation-for-i-o">Avoid string interpolation for I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#optimize-network-i-o-during-parallel-execution">Optimize network I/O during parallel execution</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#fix-deprecation-warnings">Fix deprecation warnings</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#tweaks">Tweaks</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#performance-annotations">Performance Annotations</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#treat-subnormal-numbers-as-zeros">Treat Subnormal Numbers as Zeros</a></li><li class="toctree-l2"><a class="reference internal" href="../performance-tips/#code-warntype"><code class="docutils literal"><span class="pre">@code_warntype</span></code></a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../workflow-tips/">Workflow Tips</a><ul><li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#repl-based-workflow">REPL-based workflow</a></li><li class="toctree-l2"><a class="reference internal" href="../workflow-tips/#browser-based-workflow">Browser-based workflow</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../style-guide/">Style Guide</a><ul><li class="toctree-l2"><a class="reference internal" href="../style-guide/#write-functions-not-just-scripts">Write functions, not just scripts</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-writing-overly-specific-types">Avoid writing overly-specific types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#handle-excess-argument-diversity-in-the-caller">Handle excess argument diversity in the caller</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#append-to-names-of-functions-that-modify-their-arguments">Append <code class="docutils literal"><span class="pre">!</span></code> to names of functions that modify their arguments</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-strange-type-unions">Avoid strange type Unions</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-type-unions-in-fields">Avoid type Unions in fields</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-elaborate-container-types">Avoid elaborate container types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#use-naming-conventions-consistent-with-julia-s-base">Use naming conventions consistent with Julia’s <code class="docutils literal"><span class="pre">base/</span></code></a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-try-catch">Don’t overuse try-catch</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-parenthesize-conditions">Don’t parenthesize conditions</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse">Don’t overuse ...</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-use-unnecessary-static-parameters">Don’t use unnecessary static parameters</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-confusion-about-whether-something-is-an-instance-or-a-type">Avoid confusion about whether something is an instance or a type</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overuse-macros">Don’t overuse macros</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-expose-unsafe-operations-at-the-interface-level">Don’t expose unsafe operations at the interface level</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#don-t-overload-methods-of-base-container-types">Don’t overload methods of base container types</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#be-careful-with-type-equality">Be careful with type equality</a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#do-not-write-x-f-x">Do not write <code class="docutils literal"><span class="pre">x-&gt;f(x)</span></code></a></li><li class="toctree-l2"><a class="reference internal" href="../style-guide/#avoid-using-floats-for-numeric-literals-in-generic-code-when-possible">Avoid using floats for numeric literals in generic code when possible</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../faq/">Frequently Asked Questions</a><ul><li class="toctree-l2"><a class="reference internal" href="../faq/#sessions-and-the-repl">Sessions and the REPL</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#functions">Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#types-type-declarations-and-constructors">Types, type declarations, and constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#packages-and-modules">Packages and Modules</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#nothingness-and-missing-values">Nothingness and missing values</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#memory">Memory</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#asynchronous-io-and-concurrent-synchronous-writes">Asynchronous IO and concurrent synchronous writes</a></li><li class="toctree-l2"><a class="reference internal" href="../faq/#julia-releases">Julia Releases</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a><ul><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-matlab">Noteworthy differences from MATLAB</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-r">Noteworthy differences from R</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-python">Noteworthy differences from Python</a></li><li class="toctree-l2"><a class="reference internal" href="../noteworthy-differences/#noteworthy-differences-from-c-c">Noteworthy differences from C/C++</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../unicode-input/">Unicode Input</a></li></ul><ul><li class="toctree-l1"><a class="reference internal" href="../../stdlib/base/">Essentials</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#introduction">Introduction</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#getting-around">Getting Around</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#all-objects">All Objects</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#types">Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#generic-functions">Generic Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#syntax">Syntax</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#nullables">Nullables</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#system">System</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#errors">Errors</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#events">Events</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#reflection">Reflection</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/base/#internals">Internals</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/collections/">Collections and Data Structures</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iteration">Iteration</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#general-collections">General Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#iterable-collections">Iterable Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#indexable-collections">Indexable Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#associative-collections">Associative Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#set-like-collections">Set-Like Collections</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#dequeues">Dequeues</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#priorityqueue">PriorityQueue</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/collections/#heap-functions">Heap Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/math/">Mathematics</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-operators">Mathematical Operators</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#mathematical-functions">Mathematical Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#statistics">Statistics</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#signal-processing">Signal Processing</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/math/#numerical-integration">Numerical Integration</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/numbers/">Numbers</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#standard-numeric-types">Standard Numeric Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#data-formats">Data Formats</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#general-number-functions-and-constants">General Number Functions and Constants</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#bigfloats">BigFloats</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/numbers/#random-numbers">Random Numbers</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/strings/">Strings</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/arrays/">Arrays</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#basic-functions">Basic functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#constructors">Constructors</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#mathematical-operators-and-functions">Mathematical operators and functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#indexing-assignment-and-concatenation">Indexing, Assignment, and Concatenation</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#array-functions">Array functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#combinatorics">Combinatorics</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#bitarrays">BitArrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/arrays/#sparse-vectors-and-matrices">Sparse Vectors and Matrices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/parallel/">Tasks and Parallel Computing</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#tasks">Tasks</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#general-parallel-computing-support">General Parallel Computing Support</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#shared-arrays">Shared Arrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#multi-threading">Multi-Threading</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#ccall-using-a-threadpool-experimental">ccall using a threadpool (Experimental)</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#synchronization-primitives">Synchronization Primitives</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/parallel/#cluster-manager-interface">Cluster Manager Interface</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/linalg/">Linear Algebra</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg">Standard Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#low-level-matrix-operations">Low-level matrix operations</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.BLAS">BLAS Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/linalg/#module-Base.LinAlg.LAPACK">LAPACK Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/constants/">Constants</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/file/">Filesystem</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/io-network/">I/O and Network</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#general-i-o">General I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#text-i-o">Text I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#multimedia-i-o">Multimedia I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#memory-mapped-i-o">Memory-mapped I/O</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/io-network/#network-i-o">Network I/O</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/punctuation/">Punctuation</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/sort/">Sorting and Related Functions</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-functions">Sorting Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#order-related-functions">Order-Related Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/sort/#sorting-algorithms">Sorting Algorithms</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/pkg/">Package Manager Functions</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/dates/">Dates and Time</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-and-time-types">Dates and Time Types</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/dates/#dates-functions">Dates Functions</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/test/">Unit Testing</a><ul><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#testing-base-julia">Testing Base Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#basic-unit-tests">Basic Unit Tests</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#working-with-test-sets">Working with Test Sets</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#other-test-macros">Other Test Macros</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#broken-tests">Broken Tests</a></li><li class="toctree-l2"><a class="reference internal" href="../../stdlib/test/#creating-custom-abstracttestset-types">Creating Custom <code class="docutils literal"><span class="pre">AbstractTestSet</span></code> Types</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/">C Interface</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/c/#llvm-interface">LLVM Interface</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/libc/">C Standard Library</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/libdl/">Dynamic Linker</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/profile/">Profiling</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/stacktraces/">StackTraces</a></li><li class="toctree-l1"><a class="reference internal" href="../../stdlib/simd-types/">SIMD Support</a></li></ul><ul><li class="toctree-l1"><a class="reference internal" href="../../devdocs/reflection/">Reflection and introspection</a></li><li class="toctree-l1"><a class="reference internal" href="../../devdocs/julia/">Documentation of Julia’s Internals</a><ul><li class="toctree-l2"><a class="reference internal" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/eval/">Eval of Julia code</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/ast/">Julia ASTs</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/types/">More about types</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/functions/">Julia Functions</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/callconv/">Calling Conventions</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/meta/">Talking to the compiler (the <code class="docutils literal"><span class="pre">:meta</span></code> mechanism)</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/subarrays/">SubArrays</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/sysimg/">System Image Building</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/llvm/">Working with LLVM</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/boundscheck/">Bounds checking</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li></ul></li><li class="toctree-l1"><a class="reference internal" href="../../devdocs/C/">Developing/debugging Julia’s C code</a><ul><li class="toctree-l2"><a class="reference internal" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li class="toctree-l2"><a class="reference internal" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></div>
       
    </nav><section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="top navigation" class="wy-nav-top" role="navigation"><i class="fa fa-bars" data-toggle="wy-nav-top"></i><a href="../../">Julia Language</a></nav><div class="wy-nav-content"><div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation"><ul class="wy-breadcrumbs"><li><a href="../../">Docs</a> »</li><li>Calling C and Fortran Code</li><li class="wy-breadcrumbs-aside"><a href="../../_sources/manual/calling-c-and-fortran-code.txt" rel="nofollow"> View page source</a></li></ul><hr/></div><div class="document" role="main"><div class="section" id="calling-c-and-fortran-code"><span id="man-calling-c-and-fortran-code"></span><h1>Calling C and Fortran Code<a class="headerlink" href="#calling-c-and-fortran-code" title="Permalink to this headline">¶</a></h1><p>Though most code can be written in Julia, there are many high-quality,
mature libraries for numerical computing already written in C and
Fortran. To allow easy use of this existing code, Julia makes it simple
and efficient to call C and Fortran functions. Julia has a “no
boilerplate” philosophy: functions can be called directly from Julia
without any “glue” code, code generation, or compilation — even from the
interactive prompt. This is accomplished just by making an appropriate call
with <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> syntax, which looks like an ordinary function call.</p><p>The code to be called must be available as a shared library. Most C and
Fortran libraries ship compiled as shared libraries already, but if you
are compiling the code yourself using GCC (or Clang), you will need to
use the <code class="docutils literal"><span class="pre">-shared</span></code> and <code class="docutils literal"><span class="pre">-fPIC</span></code> options. The machine instructions
generated by Julia’s JIT are the same as a native C call would be, so
the resulting overhead is the same as calling a library function from C
code. (Non-library function calls in both C and Julia can be inlined and
thus may have even less overhead than calls to shared library functions.
When both libraries and executables are generated by LLVM, it is
possible to perform whole-program optimizations that can even optimize
across this boundary, but Julia does not yet support that. In the
future, however, it may do so, yielding even greater performance gains.)</p><p>Shared libraries and functions are referenced by a tuple of the
form <code class="docutils literal"><span class="pre">(:function,</span><span class="pre">"library")</span></code> or <code class="docutils literal"><span class="pre">("function",</span><span class="pre">"library")</span></code> where <code class="docutils literal"><span class="pre">function</span></code>
is the C-exported function name. <code class="docutils literal"><span class="pre">library</span></code> refers to the shared library
name: shared libraries available in the (platform-specific) load path
will be resolved by name, and if necessary a direct path may be specified.</p><p>A function name may be used alone in place of the tuple (just
<code class="docutils literal"><span class="pre">:function</span></code> or <code class="docutils literal"><span class="pre">"function"</span></code>). In this case the name is resolved within
the current process. This form can be used to call C library functions,
functions in the Julia runtime, or functions in an application linked to
Julia.</p><p>By default, Fortran compilers <a class="reference external" href="https://en.wikipedia.org/wiki/Name_mangling#Fortran">generate mangled names</a>
(for example, converting function names to lowercase or uppercase,
often appending an underscore), and so to call a Fortran function via
<a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> you must pass the mangled identifier corresponding to the rule
followed by your Fortran compiler.  Also, when calling a Fortran
function, all inputs must be passed by reference.</p><p>Finally, you can use <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> to actually generate a call to the
library function. Arguments to <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> are as follows:</p><ol class="arabic simple"><li>(:function, “library”) pair (must be a constant, but see below).</li><li>Return type (see below for mapping the declared C type to Julia)<ul><li>This argument will be evaluated at compile-time.</li></ul></li><li>A tuple of input types. The input types must be written as a literal tuple,
not a tuple-valued variable or expression.<ul><li>This argument will be evaluated at compile-time.</li></ul></li><li>The following arguments, if any, are the actual argument values
passed to the function.</li></ol><p>As a complete but simple example, the following calls the <code class="docutils literal"><span class="pre">clock</span></code>
function from the standard C library:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="o">=</span><span class="k">ccall</span><span class="p">(</span><span class="p">(:</span><span class="n">clock</span><span class="p">,</span><span class="s">"libc"</span><span class="p">),</span><span class="kt">Int32</span><span class="p">,</span><span class="p">())</span><span class="mi">2292761</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">t</span><span class="mi">2292761</span><span class="n">julia</span><span class="o">&gt;</span><span class="nb">typeof</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span class="kt">Int32</span></pre></div></div><p><code class="docutils literal"><span class="pre">clock</span></code> takes no arguments and returns an <code class="docutils literal"><span class="pre">Int32</span></code>. One common gotcha
is that a 1-tuple must be written with a trailing comma. For
example, to call the <code class="docutils literal"><span class="pre">getenv</span></code> function to get a pointer to the value
of an environment variable, one makes a call like this:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">path</span><span class="o">=</span><span class="k">ccall</span><span class="p">((:</span><span class="n">getenv</span><span class="p">,</span><span class="s">"libc"</span><span class="p">),</span><span class="n">Cstring</span><span class="p">,</span><span class="p">(</span><span class="n">Cstring</span><span class="p">,),</span><span class="s">"SHELL"</span><span class="p">)</span><span class="n">Cstring</span><span class="p">(@</span><span class="mh">0x00007fff5fbffc45</span><span class="p">)</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="s">"/bin/bash"</span></pre></div></div><p>Note that the argument type tuple must be written as <code class="docutils literal"><span class="pre">(Cstring,)</span></code>,
rather than <code class="docutils literal"><span class="pre">(Cstring)</span></code>. This is because <code class="docutils literal"><span class="pre">(Cstring)</span></code> is just
the expression <code class="docutils literal"><span class="pre">Cstring</span></code> surrounded by parentheses, rather than
a 1-tuple containing <code class="docutils literal"><span class="pre">Cstring</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Cstring</span><span class="p">)</span><span class="n">Cstring</span><span class="n">julia</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Cstring</span><span class="p">,)</span><span class="p">(</span><span class="n">Cstring</span><span class="p">,)</span></pre></div></div><p>In practice, especially when providing reusable functionality, one
generally wraps <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> uses in Julia functions that set up arguments
and then check for errors in whatever manner the C or Fortran function
indicates them, propagating to the Julia caller as exceptions. This is
especially important since C and Fortran APIs are notoriously
inconsistent about how they indicate error conditions. For example, the
<code class="docutils literal"><span class="pre">getenv</span></code> C library function is wrapped in the following Julia function,
which is a simplified version of the actual definition from
<a class="reference external" href="https://github.com/JuliaLang/julia/blob/master/base/env.jl">env.jl</a>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> getenv</span><span class="p">(</span><span class="n">var</span><span class="p">::</span><span class="n">AbstractString</span><span class="p">)</span><span class="n">val</span><span class="o">=</span><span class="k">ccall</span><span class="p">((:</span><span class="n">getenv</span><span class="p">,</span><span class="s">"libc"</span><span class="p">),</span><span class="n">Cstring</span><span class="p">,</span><span class="p">(</span><span class="n">Cstring</span><span class="p">,),</span><span class="n">var</span><span class="p">)</span><span class="k">if</span><span class="n">val</span><span class="o">==</span><span class="n">C_NULL</span><span class="nb">error</span><span class="p">(</span><span class="s">"getenv: undefined variable: "</span><span class="p">,</span><span class="n">var</span><span class="p">)</span><span class="k">end</span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="k">end</span></pre></div></div><p>The C <code class="docutils literal"><span class="pre">getenv</span></code> function indicates an error by returning <code class="docutils literal"><span class="pre">NULL</span></code>, but
other standard C functions indicate errors in various different ways,
including by returning -1, 0, 1 and other special values. This wrapper
throws an exception clearly indicating the problem if the caller tries
to get a non-existent environment variable:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">getenv</span><span class="p">(</span><span class="s">"SHELL"</span><span class="p">)</span><span class="s">"/bin/bash"</span><span class="n">julia</span><span class="o">&gt;</span><span class="n">getenv</span><span class="p">(</span><span class="s">"FOOBAR"</span><span class="p">)</span><span class="n">getenv</span><span class="p">:</span><span class="n">undefined</span><span class="n">variable</span><span class="p">:</span><span class="n">FOOBAR</span></pre></div></div><p>Here is a slightly more complex example that discovers the local
machine’s hostname:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> gethostname</span><span class="p">()</span><span class="n">hostname</span><span class="o">=</span><span class="n">Array</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}(</span><span class="mi">128</span><span class="p">)</span><span class="k">ccall</span><span class="p">((:</span><span class="n">gethostname</span><span class="p">,</span><span class="s">"libc"</span><span class="p">),</span><span class="kt">Int32</span><span class="p">,</span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">UInt8</span><span class="p">},</span><span class="n">Csize_t</span><span class="p">),</span><span class="n">hostname</span><span class="p">,</span><span class="nb">sizeof</span><span class="p">(</span><span class="n">hostname</span><span class="p">))</span><span class="n">hostname</span><span class="p">[</span><span class="k">end</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c"># ensure null-termination</span><span class="k">return</span><span class="n">unsafe_string</span><span class="p">(</span><span class="n">pointer</span><span class="p">(</span><span class="n">hostname</span><span class="p">))</span><span class="k">end</span></pre></div></div><p>This example first allocates an array of bytes, then calls the C library
function <code class="docutils literal"><span class="pre">gethostname</span></code> to fill the array in with the hostname, takes a
pointer to the hostname buffer, and converts the pointer to a Julia
string, assuming that it is a NUL-terminated C string. It is common for
C libraries to use this pattern of requiring the caller to allocate
memory to be passed to the callee and filled in. Allocation of memory
from Julia like this is generally accomplished by creating an
uninitialized array and passing a pointer to its data to the C function.
This is why we don’t use the <code class="docutils literal"><span class="pre">Cstring</span></code> type here: as the array is
uninitialized, it could contain NUL bytes. Converting to a <code class="docutils literal"><span class="pre">Cstring</span></code> as
part of the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> checks for contained NUL bytes and could therefore
throw a conversion error.</p><div class="section" id="creating-c-compatible-julia-function-pointers"><h2>Creating C-Compatible Julia Function Pointers<a class="headerlink" href="#creating-c-compatible-julia-function-pointers" title="Permalink to this headline">¶</a></h2><p>It is possible to pass Julia functions to native C functions that accept
function pointer arguments. For example, to match C prototypes of the form:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">typedef</span><span class="n">returntype</span><span class="p">(</span><span class="o">*</span><span class="n">functiontype</span><span class="p">)(</span><span class="n">argumenttype</span><span class="p">,</span><span class="o">...</span><span class="p">)</span></pre></div></div><p>The function <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a> generates the C-compatible function pointer for
a call to a Julia library function.
Arguments to <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a> are as follows:</p><ol class="arabic simple"><li>A Julia Function</li><li>Return type</li><li>A tuple of input types</li></ol><p>A classic example is the standard C library <code class="docutils literal"><span class="pre">qsort</span></code> function,
declared as:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">void</span><span class="n">qsort</span><span class="p">(</span><span class="n">void</span><span class="o">*</span><span class="n">base</span><span class="p">,</span><span class="n">size_t</span><span class="n">nmemb</span><span class="p">,</span><span class="n">size_t</span><span class="n">size</span><span class="p">,</span><span class="n">int</span><span class="p">(</span><span class="o">*</span><span class="n">compare</span><span class="p">)(</span><span class="kd">const</span><span class="n">void</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="kd">const</span><span class="n">void</span><span class="o">*</span><span class="n">b</span><span class="p">));</span></pre></div></div><p>The <code class="docutils literal"><span class="pre">base</span></code> argument is a pointer to an array of length <code class="docutils literal"><span class="pre">nmemb</span></code>, with elements of
<code class="docutils literal"><span class="pre">size</span></code> bytes each. <code class="docutils literal"><span class="pre">compare</span></code> is a callback function which takes pointers to two
elements <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> and returns an integer less/greater than zero if <code class="docutils literal"><span class="pre">a</span></code> should
appear before/after <code class="docutils literal"><span class="pre">b</span></code> (or zero if any order is permitted). Now, suppose that we
have a 1d array <code class="docutils literal"><span class="pre">A</span></code> of values in Julia that we want to sort using the <code class="docutils literal"><span class="pre">qsort</span></code>
function (rather than Julia’s built-in <code class="docutils literal"><span class="pre">sort</span></code> function). Before we worry about calling
<code class="docutils literal"><span class="pre">qsort</span></code> and passing arguments, we need to write a comparison function that works for
some arbitrary type T:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> mycompare</span><span class="p">{</span><span class="n">T</span><span class="p">}(</span><span class="n">a</span><span class="p">::</span><span class="n">T</span><span class="p">,</span><span class="n">b</span><span class="p">::</span><span class="n">T</span><span class="p">)</span><span class="k">return</span><span class="nb">convert</span><span class="p">(</span><span class="n">Cint</span><span class="p">,</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="o">?</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="o">?</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">)::</span><span class="n">Cint</span><span class="k">end</span></pre></div></div><p>Notice that we have to be careful about the return type: <code class="docutils literal"><span class="pre">qsort</span></code> expects a function
returning a C <code class="docutils literal"><span class="pre">int</span></code>, so we must be sure to return <code class="docutils literal"><span class="pre">Cint</span></code> via a call to <code class="docutils literal"><span class="pre">convert</span></code>
and a <code class="docutils literal"><span class="pre">typeassert</span></code>.</p><p>In order to pass this function to C, we obtain its address using the function <code class="docutils literal"><span class="pre">cfunction</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="n">mycompare_c</span><span class="o">=</span><span class="n">cfunction</span><span class="p">(</span><span class="n">mycompare</span><span class="p">,</span><span class="n">Cint</span><span class="p">,</span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">},</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}))</span></pre></div></div><p><a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a> accepts three arguments: the Julia function (<code class="docutils literal"><span class="pre">mycompare</span></code>),
the return type (<code class="docutils literal"><span class="pre">Cint</span></code>), and a tuple of the argument types, in this case to
sort an array of <code class="docutils literal"><span class="pre">Cdouble</span></code> (<code class="docutils literal"><span class="pre">Float64</span></code>) elements.</p><p>The final call to <code class="docutils literal"><span class="pre">qsort</span></code> looks like this:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">=</span><span class="p">[</span><span class="mf">1.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.7</span><span class="p">,</span><span class="mf">4.4</span><span class="p">,</span><span class="mf">3.1</span><span class="p">]</span><span class="k">ccall</span><span class="p">(:</span><span class="n">qsort</span><span class="p">,</span><span class="n">Void</span><span class="p">,</span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">},</span><span class="n">Csize_t</span><span class="p">,</span><span class="n">Csize_t</span><span class="p">,</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}),</span><span class="n">A</span><span class="p">,</span><span class="n">length</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="nb">sizeof</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">A</span><span class="p">)),</span><span class="n">mycompare_c</span><span class="p">)</span></pre></div></div><p>After this executes, <code class="docutils literal"><span class="pre">A</span></code> is changed to the sorted array <code class="docutils literal"><span class="pre">[-2.7,</span><span class="pre">1.3,</span><span class="pre">3.1,</span><span class="pre">4.4]</span></code>.
Note that Julia knows how to convert an array into a <code class="docutils literal"><span class="pre">Ptr{Cdouble}</span></code>, how to compute
the size of a type in bytes (identical to C’s <code class="docutils literal"><span class="pre">sizeof</span></code> operator), and so on.
For fun, try inserting a <code class="docutils literal"><span class="pre">println("mycompare($a,$b)")</span></code> line into <code class="docutils literal"><span class="pre">mycompare</span></code>, which
will allow you to see the comparisons that <code class="docutils literal"><span class="pre">qsort</span></code> is performing (and to verify that
it is really calling the Julia function that you passed to it).</p></div><div class="section" id="mapping-c-types-to-julia"><h2>Mapping C Types to Julia<a class="headerlink" href="#mapping-c-types-to-julia" title="Permalink to this headline">¶</a></h2><p>It is critical to exactly match the declared C type with its declaration
in Julia. Inconsistencies can cause code that works correctly on one system
to fail or produce indeterminate results on a different system.</p><p>Note that no C header files are used anywhere in the process of calling C
functions: you are responsible for making sure that your Julia types and
call signatures accurately reflect those in the C header file. (The <a class="reference external" href="https://github.com/ihnorton/Clang.jl">Clang
package</a> can be used to auto-generate
Julia code from a C header file.)</p><div class="section" id="auto-conversion"><h3>Auto-conversion:<a class="headerlink" href="#auto-conversion" title="Permalink to this headline">¶</a></h3><p>Julia automatically inserts calls to the <a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">cconvert()</span></code></a> function to convert
each argument to the specified type. For example, the following call:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">ccall</span><span class="p">((:</span><span class="n">foo</span><span class="p">,</span><span class="s">"libfoo"</span><span class="p">),</span><span class="n">Void</span><span class="p">,</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span class="kt">Float64</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></pre></div></div><p>will behave as if the following were written:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">ccall</span><span class="p">((:</span><span class="n">foo</span><span class="p">,</span><span class="s">"libfoo"</span><span class="p">),</span><span class="n">Void</span><span class="p">,</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span class="kt">Float64</span><span class="p">),</span><span class="n">Base</span><span class="o">.</span><span class="n">unsafe_convert</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span class="n">Base</span><span class="o">.</span><span class="n">cconvert</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span class="n">x</span><span class="p">)),</span><span class="n">Base</span><span class="o">.</span><span class="n">unsafe_convert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">Base</span><span class="o">.</span><span class="n">cconvert</span><span class="p">(</span><span class="kt">Float64</span><span class="p">,</span><span class="n">y</span><span class="p">)))</span></pre></div></div><p><a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">cconvert()</span></code></a> normally just calls <a class="reference internal" href="../../stdlib/base/#Base.convert" title="Base.convert"><code class="xref jl jl-func docutils literal"><span class="pre">convert()</span></code></a>, but can be defined to return
an arbitrary new object more appropriate for passing to C. For example,
this is used to convert an <code class="docutils literal"><span class="pre">Array</span></code> of objects (e.g. strings) to an
array of pointers.</p><p><a class="reference internal" href="../../stdlib/c/#Base.unsafe_convert" title="Base.unsafe_convert"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_convert()</span></code></a> handles conversion to <code class="docutils literal"><span class="pre">Ptr</span></code> types. It is considered
unsafe because converting an object to a native pointer can hide the object
from the garbage collector, causing it to be freed prematurely.</p></div><div class="section" id="type-correspondences"><h3>Type Correspondences:<a class="headerlink" href="#type-correspondences" title="Permalink to this headline">¶</a></h3><p>First, a review of some relevant Julia type terminology:</p><table border="1" class="text-wrap docutils"><colgroup><col width="26%"/><col width="26%"/><col width="48%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">Syntax / Keyword</th><th class="head">Example</th><th class="head">Description</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">type</span></code></td><td><code class="docutils literal"><span class="pre">String</span></code></td><td>“Leaf Type” :: A group of related data that includes
a type-tag, is managed by the Julia GC, and
is defined by object-identity.
The type parameters of a leaf type must be fully defined
(no <code class="docutils literal"><span class="pre">TypeVars</span></code> are allowed)
in order for the instance to be constructed.</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">abstract</span></code></td><td><code class="docutils literal"><span class="pre">Any</span></code>,
<code class="docutils literal"><span class="pre">AbstractArray{T,N}</span></code>,
<code class="docutils literal"><span class="pre">Complex{T}</span></code></td><td>“Super Type” :: A super-type (not a leaf-type)
that cannot be instantiated, but can be used to
describe a group of types.</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">{T}</span></code></td><td><code class="docutils literal"><span class="pre">Vector{Int}</span></code></td><td><p class="first">“Type Parameter” :: A specialization of a type
(typically used for dispatch or storage optimization).</p><p class="last">“TypeVar” :: The <code class="docutils literal"><span class="pre">T</span></code> in the type parameter declaration
is referred to as a TypeVar (short for type variable).</p></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">bitstype</span></code></td><td><code class="docutils literal"><span class="pre">Int</span></code>,
<code class="docutils literal"><span class="pre">Float64</span></code></td><td>“Bits Type” :: A type with no fields, but a size. It
is stored and defined by-value.</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">immutable</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">Pair{Int,Int}</span></code></p><p class="last"><code class="docutils literal"><span class="pre">Complex128</span></code> (<code class="docutils literal"><span class="pre">isbits</span></code>)</p></td><td><p class="first">“Immutable” :: A type with all fields defined to be
constant. It is defined by-value. And may be stored
with a type-tag.</p><p class="last">“Is-Bits” :: A <code class="docutils literal"><span class="pre">bitstype</span></code>, or an <code class="docutils literal"><span class="pre">immutable</span></code> type
where all fields are other <code class="docutils literal"><span class="pre">isbits</span></code> types. It is
defined by-value, and is stored without a type-tag.</p></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">type</span><span class="pre">...;</span><span class="pre">end</span></code></td><td><code class="docutils literal"><span class="pre">nothing</span></code></td><td>“Singleton” :: a Leaf Type or Immutable with no fields.</td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">(...)</span></code> or <code class="docutils literal"><span class="pre">tuple(...)`</span></code></td><td><code class="docutils literal"><span class="pre">(1,2,3)</span></code></td><td>“Tuple” :: an immutable data-structure similar to an
anonymous immutable type, or a constant array.
Represented as either an array or a struct.</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">typealias</span></code></td><td>Not applicable here</td><td>Type aliases, and other similar mechanisms of
doing type indirection, are resolved to their base
type (this includes assigning a type to another name,
or getting the type out of a function call).</td></tr></tbody></table></div><div class="section" id="bits-types"><h3>Bits Types:<a class="headerlink" href="#bits-types" title="Permalink to this headline">¶</a></h3><p>There are several special types to be aware of, as no other type can be defined to behave the same:</p><dl class="docutils"><dt><code class="docutils literal"><span class="pre">Float32</span></code></dt><dd>Exactly corresponds to the <code class="docutils literal"><span class="pre">float</span></code> type in C (or <code class="docutils literal"><span class="pre">REAL*4</span></code> in Fortran).</dd><dt><code class="docutils literal"><span class="pre">Float64</span></code></dt><dd>Exactly corresponds to the <code class="docutils literal"><span class="pre">double</span></code> type in C (or <code class="docutils literal"><span class="pre">REAL*8</span></code> in Fortran).</dd><dt><code class="docutils literal"><span class="pre">Complex64</span></code></dt><dd>Exactly corresponds to the <code class="docutils literal"><span class="pre">complex</span><span class="pre">float</span></code> type in C (or <code class="docutils literal"><span class="pre">COMPLEX*8</span></code> in Fortran).</dd><dt><code class="docutils literal"><span class="pre">Complex128</span></code></dt><dd>Exactly corresponds to the <code class="docutils literal"><span class="pre">complex</span><span class="pre">double</span></code> type in C (or <code class="docutils literal"><span class="pre">COMPLEX*16</span></code> in Fortran).</dd><dt><code class="docutils literal"><span class="pre">Signed</span></code></dt><dd>Exactly corresponds to the <code class="docutils literal"><span class="pre">signed</span></code> type annotation in C (or any <code class="docutils literal"><span class="pre">INTEGER</span></code> type in Fortran). Any Julia type that is not a subtype of <code class="docutils literal"><span class="pre">Signed</span></code> is assumed to be unsigned.</dd><dt><code class="docutils literal"><span class="pre">Ref{T}</span></code></dt><dd>Behaves like a <code class="docutils literal"><span class="pre">Ptr{T}</span></code> that owns its memory.</dd><dt><code class="docutils literal"><span class="pre">Array{T,N}</span></code></dt><dd><p class="first">When an array is passed to C as a <code class="docutils literal"><span class="pre">Ptr{T}</span></code> argument, it is
not reinterpret-cast: Julia requires that the element type of the
array matches <code class="docutils literal"><span class="pre">T</span></code>, and the address of the first element is passed.</p><p>Therefore, if an <code class="docutils literal"><span class="pre">Array</span></code> contains data in the wrong format, it will
have to be explicitly converted using a call such as <code class="docutils literal"><span class="pre">trunc(Int32,a)</span></code>.</p><p>To pass an array <code class="docutils literal"><span class="pre">A</span></code> as a pointer of a different type <em>without</em>
converting the data beforehand (for example, to pass a <code class="docutils literal"><span class="pre">Float64</span></code> array
to a function that operates on uninterpreted bytes), you can
declare the argument as <code class="docutils literal"><span class="pre">Ptr{Void}</span></code>.</p><p class="last">If an array of eltype <code class="docutils literal"><span class="pre">Ptr{T}</span></code> is passed as a <code class="docutils literal"><span class="pre">Ptr{Ptr{T}}</span></code> argument,
<a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">Base.cconvert()</span></code></a> will attempt to first make a null-terminated copy of the array with
each element replaced by its <a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">cconvert()</span></code></a> version. This allows, for example, passing an <code class="docutils literal"><span class="pre">argv</span></code>
pointer array of type <code class="docutils literal"><span class="pre">Vector{String}</span></code> to an argument of type <code class="docutils literal"><span class="pre">Ptr{Ptr{Cchar}}</span></code>.</p></dd></dl><p>On all systems we currently support, basic C/C++ value types may be
translated to Julia types as follows. Every C type also has a corresponding
Julia type with the same name, prefixed by C. This can help for writing portable code (and remembering that an <code class="docutils literal"><span class="pre">int</span></code> in C is not the same as an <code class="docutils literal"><span class="pre">Int</span></code> in Julia).</p><p><strong>System Independent:</strong></p><table border="1" class="text-wrap docutils"><colgroup><col width="32%"/><col width="16%"/><col width="20%"/><col width="32%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">C name</th><th class="head">Fortran name</th><th class="head">Standard Julia Alias</th><th class="head">Julia Base Type</th></tr></thead><tbody valign="top"><tr class="row-even"><td><p class="first"><code class="docutils literal"><span class="pre">unsigned</span><span class="pre">char</span></code></p><p class="last"><code class="docutils literal"><span class="pre">bool</span></code> (C++)</p></td><td><code class="docutils literal"><span class="pre">CHARACTER</span></code></td><td><code class="docutils literal"><span class="pre">Cuchar</span></code></td><td><code class="docutils literal"><span class="pre">UInt8</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">short</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">INTEGER*2</span></code></p><p class="last"><code class="docutils literal"><span class="pre">LOGICAL*2</span></code></p></td><td><code class="docutils literal"><span class="pre">Cshort</span></code></td><td><code class="docutils literal"><span class="pre">Int16</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">unsigned</span><span class="pre">short</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cushort</span></code></td><td><code class="docutils literal"><span class="pre">UInt16</span></code></td></tr><tr class="row-odd"><td><p class="first"><code class="docutils literal"><span class="pre">int</span></code></p><p class="last"><code class="docutils literal"><span class="pre">BOOL</span></code> (C, typical)</p></td><td><p class="first"><code class="docutils literal"><span class="pre">INTEGER*4</span></code></p><p class="last"><code class="docutils literal"><span class="pre">LOGICAL*4</span></code></p></td><td><code class="docutils literal"><span class="pre">Cint</span></code></td><td><code class="docutils literal"><span class="pre">Int32</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">unsigned</span><span class="pre">int</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cuint</span></code></td><td><code class="docutils literal"><span class="pre">UInt32</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">long</span><span class="pre">long</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">INTEGER*8</span></code></p><p class="last"><code class="docutils literal"><span class="pre">LOGICAL*8</span></code></p></td><td><code class="docutils literal"><span class="pre">Clonglong</span></code></td><td><code class="docutils literal"><span class="pre">Int64</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">unsigned</span><span class="pre">long</span><span class="pre">long</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Culonglong</span></code></td><td><code class="docutils literal"><span class="pre">UInt64</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">intmax_t</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cintmax_t</span></code></td><td><code class="docutils literal"><span class="pre">Int64</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">uintmax_t</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cuintmax_t</span></code></td><td><code class="docutils literal"><span class="pre">UInt64</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">float</span></code></td><td><code class="docutils literal"><span class="pre">REAL*4i</span></code></td><td><code class="docutils literal"><span class="pre">Cfloat</span></code></td><td><code class="docutils literal"><span class="pre">Float32</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">double</span></code></td><td><code class="docutils literal"><span class="pre">REAL*8</span></code></td><td><code class="docutils literal"><span class="pre">Cdouble</span></code></td><td><code class="docutils literal"><span class="pre">Float64</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">complex</span><span class="pre">float</span></code></td><td><code class="docutils literal"><span class="pre">COMPLEX*8</span></code></td><td><code class="docutils literal"><span class="pre">Complex64</span></code></td><td><code class="docutils literal"><span class="pre">Complex{Float32}</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">complex</span><span class="pre">double</span></code></td><td><code class="docutils literal"><span class="pre">COMPLEX*16</span></code></td><td><code class="docutils literal"><span class="pre">Complex128</span></code></td><td><code class="docutils literal"><span class="pre">Complex{Float64}</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">ptrdiff_t</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cptrdiff_t</span></code></td><td><code class="docutils literal"><span class="pre">Int</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">ssize_t</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cssize_t</span></code></td><td><code class="docutils literal"><span class="pre">Int</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">size_t</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Csize_t</span></code></td><td><code class="docutils literal"><span class="pre">UInt</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">void</span></code></td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Void</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">void</span></code> and
<code class="docutils literal"><span class="pre">[[noreturn]]</span></code> or <code class="docutils literal"><span class="pre">_Noreturn</span></code></td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Union{}</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">void*</span></code></td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Ptr{Void}</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">T*</span></code> (where T represents an
appropriately defined type)</td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Ref{T}</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">char*</span></code>
(or <code class="docutils literal"><span class="pre">char[]</span></code>, e.g. a string)</td><td><code class="docutils literal"><span class="pre">CHARACTER*N</span></code></td><td> </td><td><code class="docutils literal"><span class="pre">Cstring</span></code> if NUL-terminated, or
<code class="docutils literal"><span class="pre">Ptr{UInt8}</span></code> if not</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">char**</span></code> (or <code class="docutils literal"><span class="pre">*char[]</span></code>)</td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Ptr{Ptr{UInt8}}</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">jl_value_t*</span></code>
(any Julia Type)</td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Any</span></code></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">jl_value_t**</span></code>
(a reference to a Julia Type)</td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">Ref{Any}</span></code></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">va_arg</span></code></td><td> </td><td> </td><td>Not supported</td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">...</span></code>
(variadic function specification)</td><td> </td><td> </td><td><code class="docutils literal"><span class="pre">T...</span></code> (where <code class="docutils literal"><span class="pre">T</span></code>
is one of the above types,
variadic functions of different
argument types are not supported)</td></tr></tbody></table><p>The <code class="docutils literal"><span class="pre">Cstring</span></code> type is essentially a synonym for <code class="docutils literal"><span class="pre">Ptr{UInt8}</span></code>, except the conversion to <code class="docutils literal"><span class="pre">Cstring</span></code> throws an
error if the Julia string contains any embedded NUL characters (which would cause the string to be silently
truncated if the C routine treats NUL as the terminator).  If you are passing a <code class="docutils literal"><span class="pre">char*</span></code> to a C routine that
does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that
your Julia string does not contain NUL and want to skip the check, you can use <code class="docutils literal"><span class="pre">Ptr{UInt8}</span></code> as the argument type.
<code class="docutils literal"><span class="pre">Cstring</span></code> can also be used as the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> return type, but in that case it obviously does not introduce any extra
checks and is only meant to improve readability of the call.</p><p><strong>System-dependent:</strong></p><table border="1" class="docutils"><colgroup><col width="32%"/><col width="32%"/><col width="35%"/></colgroup><thead valign="bottom"><tr class="row-odd"><th class="head">C name</th><th class="head">Standard Julia Alias</th><th class="head">Julia Base Type</th></tr></thead><tbody valign="top"><tr class="row-even"><td><code class="docutils literal"><span class="pre">char</span></code></td><td><code class="docutils literal"><span class="pre">Cchar</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">Int8</span></code> (x86, x86_64)</p><p class="last"><code class="docutils literal"><span class="pre">UInt8</span></code> (powerpc, arm)</p></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">long</span></code></td><td><code class="docutils literal"><span class="pre">Clong</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">Int</span></code> (UNIX)</p><p class="last"><code class="docutils literal"><span class="pre">Int32</span></code> (Windows)</p></td></tr><tr class="row-even"><td><code class="docutils literal"><span class="pre">unsigned</span><span class="pre">long</span></code></td><td><code class="docutils literal"><span class="pre">Culong</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">UInt</span></code> (UNIX)</p><p class="last"><code class="docutils literal"><span class="pre">UInt32</span></code> (Windows)</p></td></tr><tr class="row-odd"><td><code class="docutils literal"><span class="pre">wchar_t</span></code></td><td><code class="docutils literal"><span class="pre">Cwchar_t</span></code></td><td><p class="first"><code class="docutils literal"><span class="pre">Int32</span></code> (UNIX)</p><p class="last"><code class="docutils literal"><span class="pre">UInt16</span></code> (Windows)</p></td></tr></tbody></table><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">When calling a Fortran function, all inputs must be passed by reference, so
all type correspondences above should contain an additional <code class="docutils literal"><span class="pre">Ptr{..}</span></code> or
<code class="docutils literal"><span class="pre">Ref{..}</span></code> wrapper around their type specification.</p></div><div class="admonition warning"><p class="first admonition-title">Warning</p><p class="last">For string arguments (<code class="docutils literal"><span class="pre">char*</span></code>) the Julia type should be <code class="docutils literal"><span class="pre">Cstring</span></code> (if NUL-
terminated data is expected) or either <code class="docutils literal"><span class="pre">Ptr{Cchar}</span></code> or <code class="docutils literal"><span class="pre">Ptr{UInt8}</span></code>
otherwise (these two pointer types have the same effect), as described above,
not <code class="docutils literal"><span class="pre">String</span></code>. Similarly, for array arguments (<code class="docutils literal"><span class="pre">T[]</span></code> or <code class="docutils literal"><span class="pre">T*</span></code>), the
Julia type should again be <code class="docutils literal"><span class="pre">Ptr{T}</span></code>, not <code class="docutils literal"><span class="pre">Vector{T}</span></code>.</p></div><div class="admonition warning"><p class="first admonition-title">Warning</p><p class="last">Julia’s <code class="docutils literal"><span class="pre">Char</span></code> type is 32 bits, which is not the same as the wide character
type (<code class="docutils literal"><span class="pre">wchar_t</span></code> or <code class="docutils literal"><span class="pre">wint_t</span></code>) on all platforms.</p></div><div class="admonition warning"><p class="first admonition-title">Warning</p><p class="last">A return type of <code class="docutils literal"><span class="pre">Union{}</span></code> means the function will not return
i.e. C++11 <code class="docutils literal"><span class="pre">[[noreturn]]</span></code> or C11 <code class="docutils literal"><span class="pre">_Noreturn</span></code> (e.g. <code class="docutils literal"><span class="pre">jl_throw</span></code> or
<code class="docutils literal"><span class="pre">longjmp</span></code>). Do not use this for functions that return
no value (<code class="docutils literal"><span class="pre">void</span></code>) but do return.</p></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">For <code class="docutils literal"><span class="pre">wchar_t*</span></code> arguments, the Julia type should be <code class="docutils literal"><span class="pre">Cwstring</span></code> (if the C
routine expects a NUL-terminated string) or <code class="docutils literal"><span class="pre">Ptr{Cwchar_t}</span></code> otherwise. Note
also that UTF-8 string data in Julia is internally NUL-terminated, so it can
be passed to C functions expecting NUL-terminated data without making a copy
(but using the <code class="docutils literal"><span class="pre">Cwstring</span></code> type will cause an error to be thrown if the string
itself contains NUL characters).</p></div><div class="admonition note"><p class="first admonition-title">Note</p><p>C functions that take an argument of the type <code class="docutils literal"><span class="pre">char**</span></code> can be called by
using a <code class="docutils literal"><span class="pre">Ptr{Ptr{UInt8}}</span></code> type within Julia. For example, C functions of the
form:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">int</span><span class="n">main</span><span class="p">(</span><span class="n">int</span><span class="n">argc</span><span class="p">,</span><span class="n">char</span><span class="o">**</span><span class="n">argv</span><span class="p">);</span></pre></div></div><p>can be called via the following Julia code:</p><div class="last highlight-julia"><div class="highlight"><pre><span></span><span class="n">argv</span><span class="o">=</span><span class="p">[</span><span class="s">"a.out"</span><span class="p">,</span><span class="s">"arg1"</span><span class="p">,</span><span class="s">"arg2"</span><span class="p">]</span><span class="k">ccall</span><span class="p">(:</span><span class="n">main</span><span class="p">,</span><span class="kt">Int32</span><span class="p">,</span><span class="p">(</span><span class="kt">Int32</span><span class="p">,</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Ptr</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}}),</span><span class="n">length</span><span class="p">(</span><span class="n">argv</span><span class="p">),</span><span class="n">argv</span><span class="p">)</span></pre></div></div></div><div class="admonition note"><p class="first admonition-title">Note</p><p class="last">A C function declared to return <code class="docutils literal"><span class="pre">Void</span></code> will return the value <code class="docutils literal"><span class="pre">nothing</span></code> in
Julia.</p></div></div><div class="section" id="struct-type-correspondences"><h3>Struct Type correspondences<a class="headerlink" href="#struct-type-correspondences" title="Permalink to this headline">¶</a></h3><p>Composite types, aka <code class="docutils literal"><span class="pre">struct</span></code> in C or <code class="docutils literal"><span class="pre">TYPE</span></code> in Fortran90
(or <code class="docutils literal"><span class="pre">STRUCTURE</span></code> / <code class="docutils literal"><span class="pre">RECORD</span></code> in some variants of F77),
can be mirrored in Julia by creating a <code class="docutils literal"><span class="pre">type</span></code> or <code class="docutils literal"><span class="pre">immutable</span></code>
definition with the same field layout.</p><p>When used recursively, <code class="docutils literal"><span class="pre">isbits</span></code> types are stored inline.
All other types are stored as a pointer to the data.
When mirroring a struct used by-value inside another struct in C,
it is imperative that you do not attempt to manually copy the fields over,
as this will not preserve the correct field alignment.
Instead, declare an immutable <code class="docutils literal"><span class="pre">isbits</span></code> type and use that instead.
Unnamed structs are not possible in the translation to Julia.</p><p>Packed structs and union declarations are not supported by Julia.</p><p>You can get a near approximation of a <code class="docutils literal"><span class="pre">union</span></code> if you know, a priori,
the field that will have the greatest size (potentially including padding).
When translating your fields to Julia, declare the Julia field to be only
of that type.</p><p>Arrays of parameters must be expanded manually, currently
(either inline, or in an immutable helper type). For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">in</span><span class="n">C</span><span class="p">:</span><span class="n">struct</span><span class="n">B</span><span class="p">{</span><span class="n">int</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span><span class="p">};</span><span class="n">b_a_2</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="k">in</span><span class="n">Julia</span><span class="p">:</span><span class="k">immutable</span><span class="n">B_A</span><span class="n">A_1</span><span class="p">::</span><span class="n">Cint</span><span class="n">A_2</span><span class="p">::</span><span class="n">Cint</span><span class="n">A_3</span><span class="p">::</span><span class="n">Cint</span><span class="k">end</span><span class="k">type</span><span class="nc"> B</span><span class="n">A</span><span class="p">::</span><span class="n">B_A</span><span class="k">end</span><span class="n">b_a_2</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span></pre></div></div><p>Arrays of unknown size are not supported.</p><p>In the future, some of these restrictions may be reduced or eliminated.</p></div><div class="section" id="simd-values"><h3>SIMD Values<a class="headerlink" href="#simd-values" title="Permalink to this headline">¶</a></h3><p>Note: This feature is currently implemented on 64-bit x86
and AArch64 platforms only.</p><p>If a C/C++ routine has an argument or return value that is a native
SIMD type, the corresponding Julia type is a homogeneous tuple
of <code class="docutils literal"><span class="pre">VecElement</span></code> that naturally maps to the SIMD type.  Specifically:</p><blockquote><div><ul class="simple"><li>The tuple must be the same size as the SIMD type.
For example, a tuple representing an <code class="docutils literal"><span class="pre">__m128</span></code> on x86
must have a size of 16 bytes.</li><li>The element type of the tuple must be an instance of <code class="docutils literal"><span class="pre">VecElement{T}</span></code>
where <code class="docutils literal"><span class="pre">T</span></code> is a bitstype that is 1, 2, 4 or 8 bytes.</li></ul></div></blockquote><p>For instance, consider this C routine that uses AVX intrinsics:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="c">#include &lt;immintrin.h&gt;</span><span class="n">__m256</span><span class="n">dist</span><span class="p">(</span><span class="n">__m256</span><span class="n">a</span><span class="p">,</span><span class="n">__m256</span><span class="n">b</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">_mm256_sqrt_ps</span><span class="p">(</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">),</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)));</span><span class="p">}</span></pre></div></div><p>The following Julia code calls <code class="docutils literal"><span class="pre">dist</span></code> using <code class="docutils literal"><span class="pre">ccall</span></code>:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">typealias</span><span class="nc"> m256</span><span class="n">NTuple</span><span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="n">VecElement</span><span class="p">{</span><span class="kt">Float32</span><span class="p">}}</span><span class="n">a</span><span class="o">=</span><span class="n">m256</span><span class="p">(</span><span class="nb">ntuple</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">VecElement</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="kt">Float32</span><span class="p">(</span><span class="n">i</span><span class="p">))),</span><span class="mi">8</span><span class="p">))</span><span class="n">b</span><span class="o">=</span><span class="n">m256</span><span class="p">(</span><span class="nb">ntuple</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">VecElement</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="kt">Float32</span><span class="p">(</span><span class="n">i</span><span class="p">))),</span><span class="mi">8</span><span class="p">))</span><span class="k">function</span><span class="nf"> call_dist</span><span class="p">(</span><span class="n">a</span><span class="p">::</span><span class="n">m256</span><span class="p">,</span><span class="n">b</span><span class="p">::</span><span class="n">m256</span><span class="p">)</span><span class="k">ccall</span><span class="p">((:</span><span class="n">dist</span><span class="p">,</span><span class="s">"libdist"</span><span class="p">),</span><span class="n">m256</span><span class="p">,</span><span class="p">(</span><span class="n">m256</span><span class="p">,</span><span class="n">m256</span><span class="p">),</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="k">end</span><span class="n">println</span><span class="p">(</span><span class="n">call_dist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span></pre></div></div><p>The host machine must have the requisite SIMD registers.  For example,
the code above will not work on hosts without AVX support.</p></div><div class="section" id="memory-ownership"><h3>Memory Ownership<a class="headerlink" href="#memory-ownership" title="Permalink to this headline">¶</a></h3><p><strong>malloc/free</strong></p><p>Memory allocation and deallocation of such objects must be
handled by calls to the appropriate cleanup routines in the libraries
being used, just like in any C program. Do not try to free an object
received from a C library with <code class="docutils literal"><span class="pre">Libc.free</span></code> in Julia, as this may result
in the <code class="docutils literal"><span class="pre">free</span></code> function being called via the wrong <code class="docutils literal"><span class="pre">libc</span></code> library and
cause Julia to crash. The reverse (passing an object allocated in Julia
to be freed by an external library) is equally invalid.</p></div><div class="section" id="when-to-use-t-ptr-t-and-ref-t"><h3>When to use T, Ptr{T} and Ref{T}<a class="headerlink" href="#when-to-use-t-ptr-t-and-ref-t" title="Permalink to this headline">¶</a></h3><p>In Julia code wrapping calls to external C routines, ordinary (non-pointer)
data should be declared to be of type <code class="docutils literal"><span class="pre">T</span></code> inside the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>, as they
are passed by value.  For C code accepting pointers, <code class="docutils literal"><span class="pre">Ref{T}</span></code> should
generally be used for the types of input arguments, allowing the use of
pointers to memory managed by either Julia or C through the implicit call to
<a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">cconvert()</span></code></a>.  In contrast, pointers returned by the C function called
should be declared to be of output type <code class="docutils literal"><span class="pre">Ptr{T}</span></code>, reflecting that the memory
pointed to is managed by C only. Pointers contained in C structs should be
represented as fields of type <code class="docutils literal"><span class="pre">Ptr{T}</span></code> within the corresponding Julia
immutable types designed to mimic the internal structure of corresponding C
structs.</p><p>In Julia code wrapping calls to external Fortran routines, all input arguments
should be declared as of type <code class="docutils literal"><span class="pre">Ref{T}</span></code>, as Fortran passes all variables by
reference. The return type should either be <code class="docutils literal"><span class="pre">Void</span></code> for Fortran subroutines,
or a <code class="docutils literal"><span class="pre">T</span></code> for Fortran functions returning the type <code class="docutils literal"><span class="pre">T</span></code>.</p></div></div><div class="section" id="mapping-c-functions-to-julia"><h2>Mapping C Functions to Julia<a class="headerlink" href="#mapping-c-functions-to-julia" title="Permalink to this headline">¶</a></h2><div class="section" id="ccall-cfunction-argument-translation-guide"><h3><code class="docutils literal"><span class="pre">ccall</span></code>/<code class="docutils literal"><span class="pre">cfunction</span></code> argument translation guide<a class="headerlink" href="#ccall-cfunction-argument-translation-guide" title="Permalink to this headline">¶</a></h3><p>For translating a C argument list to Julia:</p><ul class="simple"><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is one of the primitive types:
<code class="docutils literal"><span class="pre">char</span></code>, <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">long</span></code>, <code class="docutils literal"><span class="pre">short</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">double</span></code>, <code class="docutils literal"><span class="pre">complex</span></code>, <code class="docutils literal"><span class="pre">enum</span></code>
or any of their <code class="docutils literal"><span class="pre">typedef</span></code> equivalents<ul><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code class="docutils literal"><span class="pre">T</span></code> is an <code class="docutils literal"><span class="pre">enum</span></code>, the argument type should be equivalent to <code class="docutils literal"><span class="pre">Cint</span></code> or <code class="docutils literal"><span class="pre">Cuint</span></code></li><li>argument value will be copied (passed by value)</li></ul></li><li><code class="docutils literal"><span class="pre">struct</span><span class="pre">T</span></code> (including typedef to a struct)<ul><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is a Julia leaf type</li><li>argument value will be copied (passed by value)</li></ul></li><li><code class="docutils literal"><span class="pre">void*</span></code><ul><li>depends on how this parameter is used, first translate this to the intended pointer type,
then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code class="docutils literal"><span class="pre">Ptr{Void}</span></code>, if it really is just an unknown pointer</li></ul></li><li><code class="docutils literal"><span class="pre">jl_value_t*</span></code><ul><li><code class="docutils literal"><span class="pre">Any</span></code></li><li>argument value must be a valid Julia object</li><li>currently unsupported by <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a></li></ul></li><li><code class="docutils literal"><span class="pre">jl_value_t**</span></code><ul><li><code class="docutils literal"><span class="pre">Ref{Any}</span></code></li><li>argument value must be a valid Julia object (or <code class="docutils literal"><span class="pre">C_NULL</span></code>)</li><li>currently unsupported by <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a></li></ul></li><li><code class="docutils literal"><span class="pre">T*</span></code><ul><li><code class="docutils literal"><span class="pre">Ref{T}</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is the Julia type corresponding to <code class="docutils literal"><span class="pre">T</span></code></li><li>argument value will be copied if it is an <code class="docutils literal"><span class="pre">isbits</span></code> type
otherwise, the value must be a valid Julia object</li></ul></li><li><code class="docutils literal"><span class="pre">(T*)(...)</span></code> (e.g. a pointer to a function)<ul><li><code class="docutils literal"><span class="pre">Ptr{Void}</span></code> (you may need to use <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a> explicitly to create this pointer)</li></ul></li><li><code class="docutils literal"><span class="pre">...</span></code> (e.g. a vararg)<ul><li><code class="docutils literal"><span class="pre">T...</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is the Julia type</li></ul></li><li><code class="docutils literal"><span class="pre">va_arg</span></code><ul><li>not supported</li></ul></li></ul></div><div class="section" id="ccall-cfunction-return-type-translation-guide"><h3><code class="docutils literal"><span class="pre">ccall</span></code>/<code class="docutils literal"><span class="pre">cfunction</span></code> return type translation guide<a class="headerlink" href="#ccall-cfunction-return-type-translation-guide" title="Permalink to this headline">¶</a></h3><p>For translating a C return type to Julia:</p><ul class="simple"><li><code class="docutils literal"><span class="pre">void</span></code><ul><li><code class="docutils literal"><span class="pre">Void</span></code> (this will return the singleton instance <code class="docutils literal"><span class="pre">nothing::Void</span></code>)</li></ul></li><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is one of the primitive types:
<code class="docutils literal"><span class="pre">char</span></code>, <code class="docutils literal"><span class="pre">int</span></code>, <code class="docutils literal"><span class="pre">long</span></code>, <code class="docutils literal"><span class="pre">short</span></code>, <code class="docutils literal"><span class="pre">float</span></code>, <code class="docutils literal"><span class="pre">double</span></code>, <code class="docutils literal"><span class="pre">complex</span></code>, <code class="docutils literal"><span class="pre">enum</span></code>
or any of their <code class="docutils literal"><span class="pre">typedef</span></code> equivalents<ul><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is an equivalent Julia Bits Type (per the table above)</li><li>if <code class="docutils literal"><span class="pre">T</span></code> is an <code class="docutils literal"><span class="pre">enum</span></code>, the argument type should be equivalent to <code class="docutils literal"><span class="pre">Cint</span></code> or <code class="docutils literal"><span class="pre">Cuint</span></code></li><li>argument value will be copied (returned by-value)</li></ul></li><li><code class="docutils literal"><span class="pre">struct</span><span class="pre">T</span></code> (including typedef to a struct)<ul><li><code class="docutils literal"><span class="pre">T</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is a Julia Leaf Type</li><li>argument value will be copied (returned by-value)</li></ul></li><li><code class="docutils literal"><span class="pre">void*</span></code><ul><li>depends on how this parameter is used, first translate this to the intended pointer type,
then determine the Julia equivalent using the remaining rules in this list</li><li>this argument may be declared as <code class="docutils literal"><span class="pre">Ptr{Void}</span></code>, if it really is just an unknown pointer</li></ul></li><li><code class="docutils literal"><span class="pre">jl_value_t*</span></code><ul><li><code class="docutils literal"><span class="pre">Any</span></code></li><li>argument value must be a valid Julia object</li></ul></li><li><code class="docutils literal"><span class="pre">jl_value_t**</span></code><ul><li><code class="docutils literal"><span class="pre">Ref{Any}</span></code></li><li>argument value must be a valid Julia object (or <code class="docutils literal"><span class="pre">C_NULL</span></code>)</li></ul></li><li><code class="docutils literal"><span class="pre">T*</span></code><ul><li>If the memory is already owned by Julia, or is an <code class="docutils literal"><span class="pre">isbits</span></code> type, and is known to be non-null:<ul><li><code class="docutils literal"><span class="pre">Ref{T}</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is the Julia type corresponding to <code class="docutils literal"><span class="pre">T</span></code></li><li>a return type of <code class="docutils literal"><span class="pre">Ref{Any}</span></code> is invalid, it should either be <code class="docutils literal"><span class="pre">Any</span></code>
(corresponding to <code class="docutils literal"><span class="pre">jl_value_t*</span></code>) or <code class="docutils literal"><span class="pre">Ptr{Any}</span></code> (corresponding to <code class="docutils literal"><span class="pre">Ptr{Any}</span></code>)</li><li>C <strong>MUST NOT</strong> modify the memory returned via <code class="docutils literal"><span class="pre">Ref{T}</span></code> if <code class="docutils literal"><span class="pre">T</span></code> is an <code class="docutils literal"><span class="pre">isbits</span></code> type</li></ul></li><li>If the memory is owned by C:<ul><li><code class="docutils literal"><span class="pre">Ptr{T}</span></code>, where <code class="docutils literal"><span class="pre">T</span></code> is the Julia type corresponding to <code class="docutils literal"><span class="pre">T</span></code></li></ul></li></ul></li><li><code class="docutils literal"><span class="pre">(T*)(...)</span></code> (e.g. a pointer to a function)<ul><li><code class="docutils literal"><span class="pre">Ptr{Void}</span></code> (you may need to use <a class="reference internal" href="../../stdlib/c/#Base.cfunction" title="Base.cfunction"><code class="xref jl jl-func docutils literal"><span class="pre">cfunction()</span></code></a> explicitly to create this pointer)</li></ul></li></ul></div><div class="section" id="passing-pointers-for-modifying-inputs"><h3>Passing Pointers for Modifying Inputs<a class="headerlink" href="#passing-pointers-for-modifying-inputs" title="Permalink to this headline">¶</a></h3><p>Because C doesn’t support multiple return values,
often C functions will take pointers to data that the function will modify.
To accomplish this within a <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>,
you need to first encapsulate the value inside an <code class="docutils literal"><span class="pre">Ref{T}</span></code> of the appropriate type.
When you pass this <code class="docutils literal"><span class="pre">Ref</span></code> object as an argument,
Julia will automatically pass a C pointer to the encapsulated data:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">width</span><span class="o">=</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cint</span><span class="p">}(</span><span class="mi">0</span><span class="p">)</span><span class="n">range</span><span class="o">=</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cfloat</span><span class="p">}(</span><span class="mi">0</span><span class="p">)</span><span class="k">ccall</span><span class="p">(:</span><span class="n">foo</span><span class="p">,</span><span class="n">Void</span><span class="p">,</span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cint</span><span class="p">},</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cfloat</span><span class="p">}),</span><span class="n">width</span><span class="p">,</span><span class="n">range</span><span class="p">)</span></pre></div></div><p>Upon return, the contents of <code class="docutils literal"><span class="pre">width</span></code> and <code class="docutils literal"><span class="pre">range</span></code> can be retrieved
(if they were changed by <code class="docutils literal"><span class="pre">foo</span></code>) by <code class="docutils literal"><span class="pre">width[]</span></code> and <code class="docutils literal"><span class="pre">range[]</span></code>; that is,
they act like zero-dimensional arrays.</p></div><div class="section" id="special-reference-syntax-for-ccall-deprecated"><h3>Special Reference Syntax for ccall (deprecated):<a class="headerlink" href="#special-reference-syntax-for-ccall-deprecated" title="Permalink to this headline">¶</a></h3><p>The <code class="docutils literal"><span class="pre">&amp;</span></code> syntax is deprecated, use the <code class="docutils literal"><span class="pre">Ref{T}</span></code> argument type instead.</p><p>A prefix <code class="docutils literal"><span class="pre">&amp;</span></code> is used on an argument to <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> to indicate that a pointer
to a scalar argument should be passed instead of the scalar value itself
(required for all Fortran function arguments, as noted above). The following
example computes a dot product using a BLAS function.</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">function</span><span class="nf"> compute_dot</span><span class="p">(</span><span class="n">DX</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span><span class="n">DY</span><span class="p">::</span><span class="n">Vector</span><span class="p">{</span><span class="kt">Float64</span><span class="p">})</span><span class="nb">assert</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">DX</span><span class="p">)</span><span class="o">==</span><span class="n">length</span><span class="p">(</span><span class="n">DY</span><span class="p">))</span><span class="n">n</span><span class="o">=</span><span class="n">length</span><span class="p">(</span><span class="n">DX</span><span class="p">)</span><span class="n">incx</span><span class="o">=</span><span class="n">incy</span><span class="o">=</span><span class="mi">1</span><span class="n">product</span><span class="o">=</span><span class="k">ccall</span><span class="p">((:</span><span class="n">ddot_</span><span class="p">,</span><span class="s">"libLAPACK"</span><span class="p">),</span><span class="kt">Float64</span><span class="p">,</span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">},</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">},</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Float64</span><span class="p">},</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">}),</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="n">DX</span><span class="p">,</span><span class="o">&amp;</span><span class="n">incx</span><span class="p">,</span><span class="n">DY</span><span class="p">,</span><span class="o">&amp;</span><span class="n">incy</span><span class="p">)</span><span class="k">return</span><span class="n">product</span><span class="k">end</span></pre></div></div><p>The meaning of prefix <code class="docutils literal"><span class="pre">&amp;</span></code> is not quite the same as in C. In
particular, any changes to the referenced variables will not be
visible in Julia unless the type is mutable (declared via
<code class="docutils literal"><span class="pre">type</span></code>). However, even for immutable types it will not cause any
harm for called functions to attempt such modifications (that is,
writing through the passed pointers). Moreover, <code class="docutils literal"><span class="pre">&amp;</span></code> may be used with
any expression, such as <code class="docutils literal"><span class="pre">&amp;0</span></code> or <code class="docutils literal"><span class="pre">&amp;f(x)</span></code>.</p><p>When a scalar value is passed with <code class="docutils literal"><span class="pre">&amp;</span></code> as an argument of type
<code class="docutils literal"><span class="pre">Ptr{T}</span></code>, the value will first be converted to type <code class="docutils literal"><span class="pre">T</span></code>.</p></div></div><div class="section" id="some-examples-of-c-wrappers"><h2>Some Examples of C Wrappers<a class="headerlink" href="#some-examples-of-c-wrappers" title="Permalink to this headline">¶</a></h2><p>Here is a simple example of a C wrapper that returns a <code class="docutils literal"><span class="pre">Ptr</span></code> type:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">type</span><span class="nc"> gsl_permutation</span><span class="k">end</span><span class="c"># The corresponding C signature is</span><span class="c">#     gsl_permutation * gsl_permutation_alloc (size_t n);</span><span class="k">function</span><span class="nf"> permutation_alloc</span><span class="p">(</span><span class="n">n</span><span class="p">::</span><span class="n">Integer</span><span class="p">)</span><span class="n">output_ptr</span><span class="o">=</span><span class="k">ccall</span><span class="p">(</span><span class="p">(:</span><span class="n">gsl_permutation_alloc</span><span class="p">,</span><span class="p">:</span><span class="n">libgsl</span><span class="p">),</span><span class="c">#name of C function and library</span><span class="n">Ptr</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">},</span><span class="c">#output type</span><span class="p">(</span><span class="n">Csize_t</span><span class="p">,),</span><span class="c">#tuple of input types</span><span class="n">n</span><span class="c">#name of Julia variable to pass in</span><span class="p">)</span><span class="k">if</span><span class="n">output_ptr</span><span class="o">==</span><span class="n">C_NULL</span><span class="c"># Could not allocate memory</span><span class="nb">throw</span><span class="p">(</span><span class="n">OutOfMemoryError</span><span class="p">())</span><span class="k">end</span><span class="k">return</span><span class="n">output_ptr</span><span class="k">end</span></pre></div></div><p>The <a class="reference external" href="https://www.gnu.org/software/gsl/">GNU Scientific Library</a> (here assumed
to be accessible through <code class="docutils literal"><span class="pre">:libgsl</span></code>) defines an opaque pointer,
<code class="docutils literal"><span class="pre">gsl_permutation</span><span class="pre">*</span></code>, as the return type of the C function
<code class="docutils literal"><span class="pre">gsl_permutation_alloc()</span></code>. As user code never has to look inside the
<code class="docutils literal"><span class="pre">gsl_permutation</span></code> struct, the corresponding Julia wrapper simply needs a new
type declaration, <code class="docutils literal"><span class="pre">gsl_permutation</span></code>, that has no internal fields and whose
sole purpose is to be placed in the type parameter of a <code class="docutils literal"><span class="pre">Ptr</span></code> type.  The
return type of the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> is declared as <code class="docutils literal"><span class="pre">Ptr{gsl_permutation}</span></code>, since the
memory allocated and pointed to by <code class="docutils literal"><span class="pre">output_ptr</span></code> is controlled by C (and not
Julia).</p><p>The input <code class="docutils literal"><span class="pre">n</span></code> is passed by value, and so the function’s input signature is
simply declared as <code class="docutils literal"><span class="pre">(Csize_t,)</span></code> without any <code class="docutils literal"><span class="pre">Ref</span></code> or <code class="docutils literal"><span class="pre">Ptr</span></code> necessary.
(If the wrapper was calling a Fortran function instead, the corresponding
function input signature should instead be <code class="docutils literal"><span class="pre">(Ref{Csize_t},)</span></code>, since Fortran
variables are passed by reference.) Furthermore, <code class="docutils literal"><span class="pre">n</span></code> can be any type that is
convertable to a <code class="docutils literal"><span class="pre">Csize_t</span></code> integer; the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> implicitly calls
<a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">Base.cconvert(Csize_t,</span><span class="pre">n)</span></code></a>.</p><p>Here is a second example wrapping the corresponding destructor:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="c"># The corresponding C signature is</span><span class="c">#     void gsl_permutation_free (gsl_permutation * p);</span><span class="k">function</span><span class="nf"> permutation_free</span><span class="p">(</span><span class="n">p</span><span class="p">::</span><span class="n">Ref</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">})</span><span class="k">ccall</span><span class="p">(</span><span class="p">(:</span><span class="n">gsl_permutation_free</span><span class="p">,</span><span class="p">:</span><span class="n">libgsl</span><span class="p">),</span><span class="c">#name of C function and library</span><span class="n">Void</span><span class="p">,</span><span class="c">#output type</span><span class="p">(</span><span class="n">Ref</span><span class="p">{</span><span class="n">gsl_permutation</span><span class="p">},),</span><span class="c">#tuple of input types</span><span class="n">p</span><span class="c">#name of Julia variable to pass in</span><span class="p">)</span><span class="k">end</span></pre></div></div><p>Here, the input <code class="docutils literal"><span class="pre">p</span></code> is declared to be of type <code class="docutils literal"><span class="pre">Ref{gsl_permutation}</span></code>,
meaning that the memory that <code class="docutils literal"><span class="pre">p</span></code> points to may be managed by Julia or by C.
A pointer to memory allocated by C should be of type <code class="docutils literal"><span class="pre">Ptr{gsl_permutation}</span></code>,
but it is convertable using <a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">cconvert()</span></code></a> and therefore can be used in the
same (covariant) context of the input argument to a <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>. A pointer to
memory allocated by Julia must be of type <code class="docutils literal"><span class="pre">Ref{gsl_permutation}</span></code>, to ensure
that the memory address pointed to is valid and that Julia’s garbage collector
manages the chunk of memory pointed to correctly. Therefore, the
<code class="docutils literal"><span class="pre">Ref{gsl_permutation}</span></code> declaration allows pointers managed by C or Julia to
be used.</p><p>If the C wrapper never expects the user to pass pointers to memory managed by
Julia, then using <code class="docutils literal"><span class="pre">p::Ptr{gsl_permutation}</span></code> for the method signature of the
wrapper and similarly in the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> is also acceptable.</p><p>Here is a third example passing Julia arrays:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="c"># The corresponding C signature is</span><span class="c">#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,</span><span class="c">#                                double result_array[])</span><span class="k">function</span><span class="nf"> sf_bessel_Jn_array</span><span class="p">(</span><span class="n">nmin</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span><span class="n">nmax</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span><span class="n">x</span><span class="p">::</span><span class="n">Real</span><span class="p">)</span><span class="k">if</span><span class="n">nmax</span><span class="o">&lt;</span><span class="n">nmin</span><span class="nb">throw</span><span class="p">(</span><span class="n">DomainError</span><span class="p">())</span><span class="k">end</span><span class="n">result_array</span><span class="o">=</span><span class="n">Array</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}(</span><span class="n">nmax</span><span class="o">-</span><span class="n">nmin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="n">errorcode</span><span class="o">=</span><span class="k">ccall</span><span class="p">(</span><span class="p">(:</span><span class="n">gsl_sf_bessel_Jn_array</span><span class="p">,</span><span class="p">:</span><span class="n">libgsl</span><span class="p">),</span><span class="c">#name of C function and library</span><span class="n">Cint</span><span class="p">,</span><span class="c">#output type</span><span class="p">(</span><span class="n">Cint</span><span class="p">,</span><span class="n">Cint</span><span class="p">,</span><span class="n">Cdouble</span><span class="p">,</span><span class="n">Ref</span><span class="p">{</span><span class="n">Cdouble</span><span class="p">}),</span><span class="c">#tuple of input types</span><span class="n">nmin</span><span class="p">,</span><span class="n">nmax</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">result_array</span><span class="c">#names of Julia variables to pass in</span><span class="p">)</span><span class="k">if</span><span class="n">errorcode!</span><span class="o">=</span><span class="mi">0</span><span class="nb">error</span><span class="p">(</span><span class="s">"GSL error code </span><span class="si">$errorcode</span><span class="s">"</span><span class="p">)</span><span class="k">end</span><span class="k">return</span><span class="n">result_array</span><span class="k">end</span></pre></div></div><p>The C function wrapped returns an integer error code; the results of the actual
evaluation of the Bessel J function populate the Julia array <code class="docutils literal"><span class="pre">result_array</span></code>.
This variable can only be used with corresponding input type declaration
<code class="docutils literal"><span class="pre">Ref{Cdouble}</span></code>, since its memory is allocated and managed by
Julia, not C. The implicit call to <a class="reference internal" href="../../stdlib/c/#Base.cconvert" title="Base.cconvert"><code class="xref jl jl-func docutils literal"><span class="pre">Base.cconvert(Ref{Cdouble},</span><span class="pre">result_array)</span></code></a> unpacks the Julia pointer to a Julia array data
structure into a form understandable by C.</p><p>Note that for this code to work correctly, <code class="docutils literal"><span class="pre">result_array</span></code> must be declared to
be of type <code class="docutils literal"><span class="pre">Ref{Cdouble}</span></code> and not <code class="docutils literal"><span class="pre">Ptr{Cdouble}</span></code>. The memory is managed by
Julia and the <code class="docutils literal"><span class="pre">Ref</span></code> signature alerts Julia’s garbage collector to keep
managing the memory for <code class="docutils literal"><span class="pre">result_array</span></code> while the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> executes. If
<code class="docutils literal"><span class="pre">Ptr{Cdouble}</span></code> were used instead, the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> may still work, but
Julia’s garbage collector would not be aware that the memory declared for
<code class="docutils literal"><span class="pre">result_array</span></code> is being used by the external C function. As a result, the
code may produce a memory leak if <code class="docutils literal"><span class="pre">result_array</span></code> never gets freed by the
garbage collector, or if the garbage collector prematurely frees
<code class="docutils literal"><span class="pre">result_array</span></code>, the C function may end up throwing an invalid memory access
exception.</p></div><div class="section" id="garbage-collection-safety"><h2>Garbage Collection Safety<a class="headerlink" href="#garbage-collection-safety" title="Permalink to this headline">¶</a></h2><p>When passing data to a <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>, it is best to avoid using the <a class="reference internal" href="../../stdlib/c/#Base.pointer" title="Base.pointer"><code class="xref jl jl-func docutils literal"><span class="pre">pointer()</span></code></a>
function. Instead define a convert method and pass the variables directly to
the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>. <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> automatically arranges that all of its arguments will be
preserved from garbage collection until the call returns. If a C API will
store a reference to memory allocated by Julia, after the <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> returns, you
must arrange that the object remains visible to the garbage collector. The
suggested way to handle this is to make a global variable of type
<code class="docutils literal"><span class="pre">Array{Ref,1}</span></code> to hold these values, until the C library notifies you that
it is finished with them.</p><p>Whenever you have created a pointer to Julia data, you must ensure the original data
exists until you are done with using the pointer. Many methods in Julia such as
<a class="reference internal" href="../../stdlib/c/#Base.unsafe_load" title="Base.unsafe_load"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_load()</span></code></a> and <a class="reference internal" href="../../stdlib/strings/#Base.String" title="Base.String"><code class="xref jl jl-func docutils literal"><span class="pre">String()</span></code></a> make copies of data instead of taking ownership
of the buffer, so that it is safe to free (or alter) the original data without
affecting Julia. A notable exception is <a class="reference internal" href="../../stdlib/strings/#Base.unsafe_wrap" title="Base.unsafe_wrap"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_wrap()</span></code></a> which, for performance
reasons, shares (or can be told to take ownership of) the underlying buffer.</p><p>The garbage collector does not guarantee any order of finalization. That is, if <code class="docutils literal"><span class="pre">a</span></code>
contained a reference to <code class="docutils literal"><span class="pre">b</span></code> and both <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> are due for garbage
collection, there is no guarantee that <code class="docutils literal"><span class="pre">b</span></code> would be finalized after <code class="docutils literal"><span class="pre">a</span></code>. If
proper finalization of <code class="docutils literal"><span class="pre">a</span></code> depends on <code class="docutils literal"><span class="pre">b</span></code> being valid, it must be handled in
other ways.</p></div><div class="section" id="non-constant-function-specifications"><h2>Non-constant Function Specifications<a class="headerlink" href="#non-constant-function-specifications" title="Permalink to this headline">¶</a></h2><p>A <code class="docutils literal"><span class="pre">(name,</span><span class="pre">library)</span></code> function specification must be a constant expression.
However, it is possible to use computed values as function names by staging
through <code class="docutils literal"><span class="pre">eval</span></code> as follows:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">eval</span><span class="k">ccall</span><span class="p">((</span><span class="o">$</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="s">"b"</span><span class="p">)),</span><span class="s">"lib"</span><span class="p">),</span><span class="o">...</span></pre></div></div><p>This expression constructs a name using <code class="docutils literal"><span class="pre">string</span></code>, then substitutes this
name into a new <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> expression, which is then evaluated. Keep in mind that
<code class="docutils literal"><span class="pre">eval</span></code> only operates at the top level, so within this expression local
variables will not be available (unless their values are substituted with
<code class="docutils literal"><span class="pre">$</span></code>). For this reason, <code class="docutils literal"><span class="pre">eval</span></code> is typically only used to form top-level
definitions, for example when wrapping libraries that contain many
similar functions.</p><p>If your usage is more dynamic, use indirect calls as described in the next section.</p></div><div class="section" id="indirect-calls"><h2>Indirect Calls<a class="headerlink" href="#indirect-calls" title="Permalink to this headline">¶</a></h2><p>The first argument to <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> can also be an expression evaluated at run time.
In this case, the expression must evaluate to a <code class="docutils literal"><span class="pre">Ptr</span></code>,
which will be used as the address of the native function to call.
This behavior occurs when the first <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> argument contains references to non-constants,
such as local variables, function arguments, or non-constant globals.</p><p>For example, you might lookup the function via <code class="docutils literal"><span class="pre">dlsym</span></code>,
then cache it in a global variable for that session. For example:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="k">macro</span><span class="nb">dlsym</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">lib</span><span class="p">)</span><span class="n">z</span><span class="p">,</span><span class="n">zlocal</span><span class="o">=</span><span class="n">gensym</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">func</span><span class="p">)),</span><span class="n">gensym</span><span class="p">()</span><span class="n">eval</span><span class="p">(</span><span class="n">current_module</span><span class="p">(),:(</span><span class="kd">global</span><span class="o">$</span><span class="n">z</span><span class="o">=</span><span class="n">C_NULL</span><span class="p">))</span><span class="n">z</span><span class="o">=</span><span class="n">esc</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="k">quote</span><span class="k">let</span><span class="o">$</span><span class="n">zlocal</span><span class="p">::</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span class="o">=</span><span class="o">$</span><span class="n">z</span><span class="p">::</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">}</span><span class="k">if</span><span class="o">$</span><span class="n">zlocal</span><span class="o">==</span><span class="n">C_NULL</span><span class="o">$</span><span class="n">zlocal</span><span class="o">=</span><span class="nb">dlsym</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">lib</span><span class="p">))::</span><span class="n">Ptr</span><span class="p">{</span><span class="n">Void</span><span class="p">},</span><span class="o">$</span><span class="p">(</span><span class="n">esc</span><span class="p">(</span><span class="n">func</span><span class="p">)))</span><span class="kd">global</span><span class="o">$</span><span class="n">z</span><span class="o">=</span><span class="o">$</span><span class="n">zlocal</span><span class="k">end</span><span class="o">$</span><span class="n">zlocal</span><span class="k">end</span><span class="k">end</span><span class="k">end</span><span class="n">mylibvar</span><span class="o">=</span><span class="nb">dlopen</span><span class="p">(</span><span class="s">"mylib"</span><span class="p">)</span><span class="k">ccall</span><span class="p">(@</span><span class="nb">dlsym</span><span class="p">(</span><span class="s">"myfunc"</span><span class="p">,</span><span class="n">mylibvar</span><span class="p">),</span><span class="n">Void</span><span class="p">,</span><span class="p">())</span></pre></div></div></div><div class="section" id="calling-convention"><h2>Calling Convention<a class="headerlink" href="#calling-convention" title="Permalink to this headline">¶</a></h2><p>The second argument to <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> can optionally be a calling convention
specifier (immediately preceding return type). Without any specifier,
the platform-default C calling convention is used. Other supported
conventions are: <code class="docutils literal"><span class="pre">stdcall</span></code>, <code class="docutils literal"><span class="pre">cdecl</span></code>, <code class="docutils literal"><span class="pre">fastcall</span></code>, and <code class="docutils literal"><span class="pre">thiscall</span></code>.
For example (from <code class="docutils literal"><span class="pre">base/libc.jl</span></code>) we see the same <code class="docutils literal"><span class="pre">gethostname</span></code><a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> as above,
but with the correct signature for Windows:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">hn</span><span class="o">=</span><span class="n">Array</span><span class="p">{</span><span class="n">UInt8</span><span class="p">}(</span><span class="mi">256</span><span class="p">)</span><span class="n">err</span><span class="o">=</span><span class="k">ccall</span><span class="p">(:</span><span class="n">gethostname</span><span class="p">,</span><span class="n">stdcall</span><span class="p">,</span><span class="kt">Int32</span><span class="p">,</span><span class="p">(</span><span class="n">Ptr</span><span class="p">{</span><span class="n">UInt8</span><span class="p">},</span><span class="n">UInt32</span><span class="p">),</span><span class="n">hn</span><span class="p">,</span><span class="n">length</span><span class="p">(</span><span class="n">hn</span><span class="p">))</span></pre></div></div><p>For more information, please see the <a class="reference external" href="http://llvm.org/docs/LangRef.html#calling-conventions">LLVM Language Reference</a>.</p></div><div class="section" id="accessing-global-variables"><h2>Accessing Global Variables<a class="headerlink" href="#accessing-global-variables" title="Permalink to this headline">¶</a></h2><p>Global variables exported by native libraries can be accessed by name using the
<a class="reference internal" href="../../stdlib/c/#Base.cglobal" title="Base.cglobal"><code class="xref jl jl-func docutils literal"><span class="pre">cglobal()</span></code></a> function. The arguments to <a class="reference internal" href="../../stdlib/c/#Base.cglobal" title="Base.cglobal"><code class="xref jl jl-func docutils literal"><span class="pre">cglobal()</span></code></a> are a symbol specification
identical to that used by <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a>, and a type describing the value stored in
the variable:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">julia</span><span class="o">&gt;</span><span class="n">cglobal</span><span class="p">((:</span><span class="n">errno</span><span class="p">,:</span><span class="n">libc</span><span class="p">),</span><span class="kt">Int32</span><span class="p">)</span><span class="n">Ptr</span><span class="p">{</span><span class="kt">Int32</span><span class="p">}</span><span class="p">@</span><span class="mh">0x00007f418d0816b8</span></pre></div></div><p>The result is a pointer giving the address of the value. The value can be
manipulated through this pointer using <a class="reference internal" href="../../stdlib/c/#Base.unsafe_load" title="Base.unsafe_load"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_load()</span></code></a> and <code class="xref jl jl-func docutils literal"><span class="pre">unsafe_store()</span></code>.</p></div><div class="section" id="accessing-data-through-a-pointer"><h2>Accessing Data through a Pointer<a class="headerlink" href="#accessing-data-through-a-pointer" title="Permalink to this headline">¶</a></h2><p>The following methods are described as “unsafe” because a bad pointer
or type declaration can cause Julia to terminate abruptly.</p><p>Given a <code class="docutils literal"><span class="pre">Ptr{T}</span></code>, the contents of type <code class="docutils literal"><span class="pre">T</span></code> can generally be copied from
the referenced memory into a Julia object using <code class="docutils literal"><span class="pre">unsafe_load(ptr,</span><span class="pre">[index])</span></code>.
The index argument is optional (default is 1),
and follows the Julia-convention of 1-based indexing.
This function is intentionally similar to the behavior of <a class="reference internal" href="../../stdlib/collections/#Base.getindex" title="Base.getindex"><code class="xref jl jl-func docutils literal"><span class="pre">getindex()</span></code></a> and <a class="reference internal" href="../../stdlib/collections/#Base.setindex!" title="Base.setindex!"><code class="xref jl jl-func docutils literal"><span class="pre">setindex!()</span></code></a>
(e.g. <code class="docutils literal"><span class="pre">[]</span></code> access syntax).</p><p>The return value will be a new object initialized
to contain a copy of the contents of the referenced memory.
The referenced memory can safely be freed or released.</p><p>If <code class="docutils literal"><span class="pre">T</span></code> is <code class="docutils literal"><span class="pre">Any</span></code>, then the memory is assumed to contain a reference to
a Julia object (a <code class="docutils literal"><span class="pre">jl_value_t*</span></code>), the result will be a reference to this object,
and the object will not be copied. You must be careful in this case to ensure
that the object was always visible to the garbage collector (pointers do not
count, but the new reference does) to ensure the memory is not prematurely freed.
Note that if the object was not originally allocated by Julia, the new object
will never be finalized by Julia’s garbage collector.  If the <code class="docutils literal"><span class="pre">Ptr</span></code> itself
is actually a <code class="docutils literal"><span class="pre">jl_value_t*</span></code>, it can be converted back to a Julia object
reference by <a class="reference internal" href="../../stdlib/c/#Base.unsafe_pointer_to_objref" title="Base.unsafe_pointer_to_objref"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_pointer_to_objref(ptr)</span></code></a>.
(Julia values <code class="docutils literal"><span class="pre">v</span></code> can be converted to <code class="docutils literal"><span class="pre">jl_value_t*</span></code> pointers, as
<code class="docutils literal"><span class="pre">Ptr{Void}</span></code>, by calling <a class="reference internal" href="../../stdlib/c/#Base.pointer_from_objref" title="Base.pointer_from_objref"><code class="xref jl jl-func docutils literal"><span class="pre">pointer_from_objref(v)</span></code></a>.)</p><p>The reverse operation (writing data to a <code class="docutils literal"><span class="pre">Ptr{T}</span></code>), can be performed using
<a class="reference internal" href="../../stdlib/c/#Base.unsafe_store!" title="Base.unsafe_store!"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_store!(ptr,</span><span class="pre">value,</span><span class="pre">[index])</span></code></a>.  Currently, this is only supported
for bitstypes or other pointer-free (<code class="docutils literal"><span class="pre">isbits</span></code>) immutable types.</p><p>Any operation that throws an error is probably currently unimplemented
and should be posted as a bug so that it can be resolved.</p><p>If the pointer of interest is a plain-data array (bitstype or immutable), the
function <a class="reference internal" href="../../stdlib/strings/#Base.unsafe_wrap" title="Base.unsafe_wrap"><code class="xref jl jl-func docutils literal"><span class="pre">unsafe_wrap(Array,</span><span class="pre">ptr,dims,[own])</span></code></a> may be
more useful. The final parameter should be true if Julia should “take
ownership” of the underlying buffer and call <code class="docutils literal"><span class="pre">free(ptr)</span></code> when the returned
<code class="docutils literal"><span class="pre">Array</span></code> object is finalized.  If the <code class="docutils literal"><span class="pre">own</span></code> parameter is omitted or false,
the caller must ensure the buffer remains in existence until all access is
complete.</p><p>Arithmetic on the <code class="docutils literal"><span class="pre">Ptr</span></code> type in Julia (e.g. using <code class="docutils literal"><span class="pre">+</span></code>) does not behave the
same as C’s pointer arithmetic. Adding an integer to a <code class="docutils literal"><span class="pre">Ptr</span></code> in Julia always
moves the pointer by some number of <em>bytes</em>, not elements. This way, the
address values obtained from pointer arithmetic do not depend on the
element types of pointers.</p></div><div class="section" id="thread-safety"><h2>Thread-safety<a class="headerlink" href="#thread-safety" title="Permalink to this headline">¶</a></h2><p>Some C libraries execute their callbacks from a different thread, and
since Julia isn’t thread-safe you’ll need to take some extra
precautions. In particular, you’ll need to set up a two-layered
system: the C callback should only <em>schedule</em> (via Julia’s event loop)
the execution of your “real” callback.
To do this, create a <code class="docutils literal"><span class="pre">AsyncCondition</span></code> object and wait on it:</p><div class="highlight-julia"><div class="highlight"><pre><span></span><span class="n">cond</span><span class="o">=</span><span class="n">Base</span><span class="o">.</span><span class="n">AsyncCondition</span><span class="p">()</span><span class="n">wait</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span></pre></div></div><p>The callback you pass to C should only execute a <a class="reference internal" href="../../stdlib/c/#Base.ccall" title="Base.ccall"><code class="xref jl jl-func docutils literal"><span class="pre">ccall()</span></code></a> to
<code class="docutils literal"><span class="pre">:uv_async_send</span></code>, passing <code class="docutils literal"><span class="pre">cb.handle</span></code> as the argument,
taking care to avoid any allocations or other interactions with the Julia runtime.</p><p>Note that events may be coalesced, so multiple calls to uv_async_send
may result in a single wakeup notification to the condition.</p></div><div class="section" id="more-about-callbacks"><h2>More About Callbacks<a class="headerlink" href="#more-about-callbacks" title="Permalink to this headline">¶</a></h2><p>For more details on how to pass callbacks to C libraries, see this
<a class="reference external" href="http://julialang.org/blog/2013/05/callback">blog post</a>.</p></div><div class="section" id="c"><h2>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h2><p>Limited support for C++ is provided by the <a class="reference external" href="https://github.com/timholy/Cpp.jl">Cpp</a>,
<a class="reference external" href="https://github.com/ihnorton/Clang.jl">Clang</a>, and <a class="reference external" href="https://github.com/Keno/Cxx.jl">Cxx</a> packages.</p></div></div></div><footer><div aria-label="footer navigation" class="rst-footer-buttons" role="navigation"><a class="btn btn-neutral float-right" href="../handling-operating-system-variation/" title="Handling Operating System Variation">Next <span class="fa fa-arrow-circle-right"></span></a><a class="btn btn-neutral" href="../running-external-programs/" title="Running External Programs"><span class="fa fa-arrow-circle-left"></span> Previous</a></div><hr/><div role="contentinfo"><p></p></div><a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a></footer></div></div></section></div><script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.5.1-pre',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script><script src="../../_static/jquery.js" type="text/javascript"></script><script src="../../_static/underscore.js" type="text/javascript"></script><script src="../../_static/doctools.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script src="../../_static/js/theme.js" type="text/javascript"></script><script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script></body></HTML>