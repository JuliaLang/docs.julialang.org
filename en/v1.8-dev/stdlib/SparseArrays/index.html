<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse Arrays Â· The Julia Language</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../../manual/strings/">Strings</a></li><li><a class="tocitem" href="../../manual/functions/">Functions</a></li><li><a class="tocitem" href="../../manual/control-flow/">Control Flow</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../../manual/types/">Types</a></li><li><a class="tocitem" href="../../manual/methods/">Methods</a></li><li><a class="tocitem" href="../../manual/constructors/">Constructors</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../../manual/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../../manual/modules/">Modules</a></li><li><a class="tocitem" href="../../manual/documentation/">Documentation</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="../../manual/missing/">Missing Values</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../../manual/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="tocitem" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">Code Loading</a></li><li><a class="tocitem" href="../../manual/profile/">Profiling</a></li><li><a class="tocitem" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../../manual/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode Input</a></li><li><a class="tocitem" href="../../manual/command-line-options/">Command-line Options</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">Essentials</a></li><li><a class="tocitem" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../../base/math/">Mathematics</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">Strings</a></li><li><a class="tocitem" href="../../base/arrays/">Arrays</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/constants/">Constants</a></li><li><a class="tocitem" href="../../base/file/">Filesystem</a></li><li><a class="tocitem" href="../../base/io-network/">I/O and Network</a></li><li><a class="tocitem" href="../../base/punctuation/">Punctuation</a></li><li><a class="tocitem" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../../base/iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../../base/c/">C Interface</a></li><li><a class="tocitem" href="../../base/libc/">C Standard Library</a></li><li><a class="tocitem" href="../../base/stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../Base64/">Base64</a></li><li><a class="tocitem" href="../CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../Dates/">Dates</a></li><li><a class="tocitem" href="../DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../Downloads/">Downloads</a></li><li><a class="tocitem" href="../FileWatching/">File Events</a></li><li><a class="tocitem" href="../Future/">Future</a></li><li><a class="tocitem" href="../InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../Logging/">Logging</a></li><li><a class="tocitem" href="../Markdown/">Markdown</a></li><li><a class="tocitem" href="../Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../NetworkOptions/">NetworkOptions</a></li><li><a class="tocitem" href="../Pkg/">Pkg</a></li><li><a class="tocitem" href="../Printf/">Printf</a></li><li><a class="tocitem" href="../Profile/">Profiling</a></li><li><a class="tocitem" href="../REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../Random/">Random Numbers</a></li><li><a class="tocitem" href="../SHA/">SHA</a></li><li><a class="tocitem" href="../Serialization/">Serialization</a></li><li><a class="tocitem" href="../SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../Sockets/">Sockets</a></li><li class="is-active"><a class="tocitem" href>Sparse Arrays</a><ul class="internal"><li><a class="tocitem" href="#man-csc"><span>Compressed Sparse Column (CSC) Sparse Matrix Storage</span></a></li><li><a class="tocitem" href="#Sparse-Vector-Storage"><span>Sparse Vector Storage</span></a></li><li><a class="tocitem" href="#Sparse-Vector-and-Matrix-Constructors"><span>Sparse Vector and Matrix Constructors</span></a></li><li><a class="tocitem" href="#Sparse-matrix-operations"><span>Sparse matrix operations</span></a></li><li><a class="tocitem" href="#Correspondence-of-dense-and-sparse-methods"><span>Correspondence of dense and sparse methods</span></a></li><li class="toplevel"><a class="tocitem" href="#stdlib-sparse-arrays"><span>Sparse Arrays</span></a></li></ul></li><li><a class="tocitem" href="../Statistics/">Statistics</a></li><li><a class="tocitem" href="../SuiteSparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../TOML/">TOML</a></li><li><a class="tocitem" href="../Tar/">Tar</a></li><li><a class="tocitem" href="../Test/">Unit Testing</a></li><li><a class="tocitem" href="../UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">Inference</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../../devdocs/probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../../devdocs/build/linux/">Linux</a></li><li><a class="tocitem" href="../../devdocs/build/macos/">macOS</a></li><li><a class="tocitem" href="../../devdocs/build/windows/">Windows</a></li><li><a class="tocitem" href="../../devdocs/build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../../devdocs/build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../../devdocs/build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Standard Library</a></li><li class="is-active"><a href>Sparse Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/SparseArrays.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Arrays"><a class="docs-heading-anchor" href="#Sparse-Arrays">Sparse Arrays</a><a id="Sparse-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Arrays" title="Permalink"></a></h1><p>Julia has support for sparse vectors and <a href="https://en.wikipedia.org/wiki/Sparse_matrix">sparse matrices</a> in the <code>SparseArrays</code> stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</p><h2 id="man-csc"><a class="docs-heading-anchor" href="#man-csc">Compressed Sparse Column (CSC) Sparse Matrix Storage</a><a id="man-csc-1"></a><a class="docs-heading-anchor-permalink" href="#man-csc" title="Permalink"></a></h2><p>In Julia, sparse matrices are stored in the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29">Compressed Sparse Column (CSC) format</a>. Julia sparse matrices have the type <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC{Tv,Ti}</code></a>, where <code>Tv</code> is the type of the stored values, and <code>Ti</code> is the integer type for storing column pointers and row indices. The internal representation of <code>SparseMatrixCSC</code> is as follows:</p><pre><code class="language-julia hljs">struct SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}
    m::Int                  # Number of rows
    n::Int                  # Number of columns
    colptr::Vector{Ti}      # Column j is in colptr[j]:(colptr[j+1]-1)
    rowval::Vector{Ti}      # Row indices of stored values
    nzval::Vector{Tv}       # Stored values, typically nonzeros
end</code></pre><p>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</p><p>All operations on sparse matrices are carefully implemented to exploit the CSC data structure for performance, and to avoid expensive operations.</p><p>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your <code>SparseMatrixCSC</code> object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</p><p>In some applications, it is convenient to store explicit zero values in a <code>SparseMatrixCSC</code>. These <em>are</em> accepted by functions in <code>Base</code> (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The <a href="#SparseArrays.nnz"><code>nnz</code></a> function returns the number of elements explicitly stored in the sparse data structure, including non-structural zeros. In order to count the exact number of numerical nonzeros, use <a href="../../base/collections/#Base.count"><code>count(!iszero, x)</code></a>, which inspects every stored element of a sparse matrix. <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>, and the in-place <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>, can be used to remove stored zeros from the sparse matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1, 1, 2, 3], [1, 3, 2, 3], [0, 1, 2, 0])
3Ã3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 0  â  1
 â  2  â
 â  â  0

julia&gt; dropzeros(A)
3Ã3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 â  â  1
 â  2  â
 â  â  â</code></pre><h2 id="Sparse-Vector-Storage"><a class="docs-heading-anchor" href="#Sparse-Vector-Storage">Sparse Vector Storage</a><a id="Sparse-Vector-Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Vector-Storage" title="Permalink"></a></h2><p>Sparse vectors are stored in a close analog to compressed sparse column format for sparse matrices. In Julia, sparse vectors have the type <a href="#SparseArrays.SparseVector"><code>SparseVector{Tv,Ti}</code></a> where <code>Tv</code> is the type of the stored values and <code>Ti</code> the integer type for the indices. The internal representation is as follows:</p><pre><code class="language-julia hljs">struct SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}
    n::Int              # Length of the sparse vector
    nzind::Vector{Ti}   # Indices of stored values
    nzval::Vector{Tv}   # Stored values, typically nonzeros
end</code></pre><p>As for <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>, the <code>SparseVector</code> type can also contain explicitly stored zeros. (See <a href="#man-csc">Sparse Matrix Storage</a>.).</p><h2 id="Sparse-Vector-and-Matrix-Constructors"><a class="docs-heading-anchor" href="#Sparse-Vector-and-Matrix-Constructors">Sparse Vector and Matrix Constructors</a><a id="Sparse-Vector-and-Matrix-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Vector-and-Matrix-Constructors" title="Permalink"></a></h2><p>The simplest way to create a sparse array is to use a function equivalent to the <a href="../../base/arrays/#Base.zeros"><code>zeros</code></a> function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an <code>sp</code> prefix:</p><pre><code class="language-julia-repl hljs">julia&gt; spzeros(3)
3-element SparseVector{Float64, Int64} with 0 stored entries</code></pre><p>The <a href="#SparseArrays.sparse"><code>sparse</code></a> function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector <code>I</code> of row indices, a vector <code>J</code> of column indices, and a vector <code>V</code> of stored values (this is also known as the <a href="https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29">COO (coordinate) format</a>). <code>sparse(I,J,V)</code> then constructs a sparse matrix such that <code>S[I[k], J[k]] = V[k]</code>. The equivalent sparse vector constructor is <a href="#SparseArrays.sparsevec"><code>sparsevec</code></a>, which takes the (row) index vector <code>I</code> and the vector <code>V</code> with the stored values and constructs a sparse vector <code>R</code> such that <code>R[I[k]] = V[k]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; I = [1, 4, 3, 5]; J = [4, 7, 18, 9]; V = [1, 2, -5, 3];

julia&gt; S = sparse(I,J,V)
5Ã18 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
â â â â¡â â â â â  
â â â â â â â â â 

julia&gt; R = sparsevec(I,V)
5-element SparseVector{Int64, Int64} with 4 stored entries:
  [1]  =  1
  [3]  =  -5
  [4]  =  2
  [5]  =  3</code></pre><p>The inverse of the <a href="#SparseArrays.sparse"><code>sparse</code></a> and <a href="#SparseArrays.sparsevec"><code>sparsevec</code></a> functions is <a href="#SparseArrays.findnz"><code>findnz</code></a>, which retrieves the inputs used to create the sparse array. <a href="../../base/arrays/#Base.findall-Tuple{Any}"><code>findall(!iszero, x)</code></a> returns the cartesian indices of non-zero entries in <code>x</code> (including stored entries equal to zero).</p><pre><code class="language-julia-repl hljs">julia&gt; findnz(S)
([1, 4, 5, 3], [4, 7, 9, 18], [1, 2, 3, -5])

julia&gt; findall(!iszero, S)
4-element Vector{CartesianIndex{2}}:
 CartesianIndex(1, 4)
 CartesianIndex(4, 7)
 CartesianIndex(5, 9)
 CartesianIndex(3, 18)

julia&gt; findnz(R)
([1, 3, 4, 5], [1, -5, 2, 3])

julia&gt; findall(!iszero, R)
4-element Vector{Int64}:
 1
 3
 4
 5</code></pre><p>Another way to create a sparse array is to convert a dense array into a sparse array using the <a href="#SparseArrays.sparse"><code>sparse</code></a> function:</p><pre><code class="language-julia-repl hljs">julia&gt; sparse(Matrix(1.0I, 5, 5))
5Ã5 SparseMatrixCSC{Float64, Int64} with 5 stored entries:
 1.0   â    â    â    â
  â   1.0   â    â    â
  â    â   1.0   â    â
  â    â    â   1.0   â
  â    â    â    â   1.0

julia&gt; sparse([1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre><p>You can go in the other direction using the <a href="../../base/arrays/#Core.Array"><code>Array</code></a> constructor. The <a href="#SparseArrays.issparse"><code>issparse</code></a> function can be used to query if a matrix is sparse.</p><pre><code class="language-julia-repl hljs">julia&gt; issparse(spzeros(5))
true</code></pre><h2 id="Sparse-matrix-operations"><a class="docs-heading-anchor" href="#Sparse-matrix-operations">Sparse matrix operations</a><a id="Sparse-matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrix-operations" title="Permalink"></a></h2><p>Arithmetic operations on sparse matrices also work as they do on dense matrices. Indexing of, assignment into, and concatenation of sparse matrices work in the same way as dense matrices. Indexing operations, especially assignment, are expensive, when carried out one element at a time. In many cases it may be better to convert the sparse matrix into <code>(I,J,V)</code> format using <a href="#SparseArrays.findnz"><code>findnz</code></a>, manipulate the values or the structure in the dense vectors <code>(I,J,V)</code>, and then reconstruct the sparse matrix.</p><h2 id="Correspondence-of-dense-and-sparse-methods"><a class="docs-heading-anchor" href="#Correspondence-of-dense-and-sparse-methods">Correspondence of dense and sparse methods</a><a id="Correspondence-of-dense-and-sparse-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Correspondence-of-dense-and-sparse-methods" title="Permalink"></a></h2><p>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix <code>S</code>, or that the resulting sparse matrix has density <code>d</code>, i.e. each matrix element has a probability <code>d</code> of being non-zero.</p><p>Details can be found in the <a href="#stdlib-sparse-arrays">Sparse Vectors and Matrices</a> section of the standard library reference.</p><table><tr><th style="text-align: left">Sparse</th><th style="text-align: left">Dense</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="#SparseArrays.spzeros"><code>spzeros(m,n)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Base.zeros"><code>zeros(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> matrix of zeros. (<a href="#SparseArrays.spzeros"><code>spzeros(m,n)</code></a> is empty.)</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sparse"><code>sparse(I,n,n)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Base.Matrix"><code>Matrix(I,n,n)</code></a></td><td style="text-align: left">Creates a <em>n</em>-by-<em>n</em> identity matrix.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sparse"><code>sparse(A)</code></a></td><td style="text-align: left"><a href="../../base/arrays/#Core.Array"><code>Array(S)</code></a></td><td style="text-align: left">Interconverts between dense and sparse formats.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprand"><code>sprand(m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.rand"><code>rand(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed uniformly on the half-open interval <span>$[0, 1)$</span>.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprandn"><code>sprandn(m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.randn"><code>randn(m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</td></tr><tr><td style="text-align: left"><a href="#SparseArrays.sprandn"><code>sprandn(rng,m,n,d)</code></a></td><td style="text-align: left"><a href="../Random/#Base.randn"><code>randn(rng,m,n)</code></a></td><td style="text-align: left">Creates a <em>m</em>-by-<em>n</em> random matrix (of density <em>d</em>) with iid non-zero elements generated with the <code>rng</code> random number generator</td></tr></table><h1 id="stdlib-sparse-arrays"><a class="docs-heading-anchor" href="#stdlib-sparse-arrays">Sparse Arrays</a><a id="stdlib-sparse-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#stdlib-sparse-arrays" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseArray" href="#SparseArrays.AbstractSparseArray"><code>SparseArrays.AbstractSparseArray</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSparseArray{Tv,Ti,N}</code></pre><p>Supertype for <code>N</code>-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. <a href="#SparseArrays.SparseMatrixCSC"><code>SparseMatrixCSC</code></a>, <a href="#SparseArrays.SparseVector"><code>SparseVector</code></a> and <code>SuiteSparse.CHOLMOD.Sparse</code> are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/abstractsparse.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseVector" href="#SparseArrays.AbstractSparseVector"><code>SparseArrays.AbstractSparseVector</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSparseVector{Tv,Ti}</code></pre><p>Supertype for one-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. Alias for <code>AbstractSparseArray{Tv,Ti,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/abstractsparse.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.AbstractSparseMatrix" href="#SparseArrays.AbstractSparseMatrix"><code>SparseArrays.AbstractSparseMatrix</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSparseMatrix{Tv,Ti}</code></pre><p>Supertype for two-dimensional sparse arrays (or array-like types) with elements of type <code>Tv</code> and index type <code>Ti</code>. Alias for <code>AbstractSparseArray{Tv,Ti,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/abstractsparse.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.SparseVector" href="#SparseArrays.SparseVector"><code>SparseArrays.SparseVector</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseVector{Tv,Ti&lt;:Integer} &lt;: AbstractSparseVector{Tv,Ti}</code></pre><p>Vector type for storing sparse vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.SparseMatrixCSC" href="#SparseArrays.SparseMatrixCSC"><code>SparseArrays.SparseMatrixCSC</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseMatrixCSC{Tv,Ti&lt;:Integer} &lt;: AbstractSparseMatrixCSC{Tv,Ti}</code></pre><p>Matrix type for storing sparse matrices in the <a href="#man-csc">Compressed Sparse Column</a> format. The standard way of constructing SparseMatrixCSC is through the <a href="#SparseArrays.sparse"><code>sparse</code></a> function. See also <a href="#SparseArrays.spzeros"><code>spzeros</code></a>, <a href="#SparseArrays.spdiagm"><code>spdiagm</code></a> and <a href="#SparseArrays.sprand"><code>sprand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse(A)</code></pre><p>Convert an AbstractMatrix <code>A</code> into a sparse matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = Matrix(1.0I, 3, 3)
3Ã3 Matrix{Float64}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; sparse(A)
3Ã3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   â    â
  â   1.0   â
  â    â   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L761-L780">source</a></section><section><div><pre><code class="nohighlight hljs">sparse(I, J, V,[ m, n, combine])</code></pre><p>Create a sparse matrix <code>S</code> of dimensions <code>m x n</code> such that <code>S[I[k], J[k]] = V[k]</code>. The <code>combine</code> function is used to combine duplicates. If <code>m</code> and <code>n</code> are not specified, they are set to <code>maximum(I)</code> and <code>maximum(J)</code> respectively. If the <code>combine</code> function is not supplied, <code>combine</code> defaults to <code>+</code> unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>. All elements of <code>I</code> must satisfy <code>1 &lt;= I[k] &lt;= m</code>, and all elements of <code>J</code> must satisfy <code>1 &lt;= J[k] &lt;= n</code>. Numerical zeros in (<code>I</code>, <code>J</code>, <code>V</code>) are retained as structural nonzeros; to drop numerical zeros, use <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p>For additional documentation and an expert driver, see <code>SparseArrays.sparse!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Is = [1; 2; 3];

julia&gt; Js = [1; 2; 3];

julia&gt; Vs = [1; 2; 3];

julia&gt; sparse(Is, Js, Vs)
3Ã3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  â  â
 â  2  â
 â  â  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L793-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparsevec" href="#SparseArrays.sparsevec"><code>SparseArrays.sparsevec</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparsevec(I, V, [m, combine])</code></pre><p>Create a sparse vector <code>S</code> of length <code>m</code> such that <code>S[I[k]] = V[k]</code>. Duplicates are combined using the <code>combine</code> function, which defaults to <code>+</code> if no <code>combine</code> argument is provided, unless the elements of <code>V</code> are Booleans in which case <code>combine</code> defaults to <code>|</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; II = [1, 3, 3, 5]; V = [0.1, 0.2, 0.3, 0.2];

julia&gt; sparsevec(II, V)
5-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  0.5
  [5]  =  0.2

julia&gt; sparsevec(II, V, 8, -)
8-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  0.1
  [3]  =  -0.1
  [5]  =  0.2

julia&gt; sparsevec([1, 3, 1, 2, 2], [true, true, false, false, false])
3-element SparseVector{Bool, Int64} with 3 stored entries:
  [1]  =  1
  [2]  =  0
  [3]  =  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L189-L219">source</a></section><section><div><pre><code class="nohighlight hljs">sparsevec(d::Dict, [m])</code></pre><p>Create a sparse vector of length <code>m</code> where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sparsevec(Dict(1 =&gt; 3, 2 =&gt; 2))
2-element SparseVector{Int64, Int64} with 2 stored entries:
  [1]  =  3
  [2]  =  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L267-L280">source</a></section><section><div><pre><code class="nohighlight hljs">sparsevec(A)</code></pre><p>Convert a vector <code>A</code> into a sparse vector of length <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sparsevec([1.0, 2.0, 0.0, 0.0, 3.0, 0.0])
6-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  2.0
  [5]  =  3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L397-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.issparse" href="#SparseArrays.issparse"><code>SparseArrays.issparse</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issparse(S)</code></pre><p>Returns <code>true</code> if <code>S</code> is sparse, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sv = sparsevec([1, 4], [2.3, 2.2], 10)
10-element SparseVector{Float64, Int64} with 2 stored entries:
  [1 ]  =  2.3
  [4 ]  =  2.2

julia&gt; issparse(sv)
true

julia&gt; issparse(Array(sv))
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/abstractsparse.jl#L34-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nnz" href="#SparseArrays.nnz"><code>SparseArrays.nnz</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nnz(A)</code></pre><p>Returns the number of stored (filled) elements in a sparse array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3Ã3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  â  â
 â  2  â
 â  â  2

julia&gt; nnz(A)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.findnz" href="#SparseArrays.findnz"><code>SparseArrays.findnz</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findnz(A::SparseMatrixCSC)</code></pre><p>Return a tuple <code>(I, J, V)</code> where <code>I</code> and <code>J</code> are the row and column indices of the stored (&quot;structurally non-zero&quot;) values in sparse matrix <code>A</code>, and <code>V</code> is a vector of the values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1 2 0; 0 0 3; 0 4 0])
3Ã3 SparseMatrixCSC{Int64, Int64} with 4 stored entries:
 1  2  â
 â  â  3
 â  4  â

julia&gt; findnz(A)
([1, 1, 3, 2], [1, 2, 2, 3], [1, 2, 4, 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/abstractsparse.jl#L107-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.spzeros" href="#SparseArrays.spzeros"><code>SparseArrays.spzeros</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spzeros([type,]m[,n])</code></pre><p>Create a sparse vector of length <code>m</code> or sparse matrix of size <code>m x n</code>. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to <a href="../../base/numbers/#Core.Float64"><code>Float64</code></a> if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spzeros(3, 3)
3Ã3 SparseMatrixCSC{Float64, Int64} with 0 stored entries:
  â    â    â
  â    â    â
  â    â    â

julia&gt; spzeros(Float32, 4)
4-element SparseVector{Float32, Int64} with 0 stored entries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1737-L1756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.spdiagm" href="#SparseArrays.spdiagm"><code>SparseArrays.spdiagm</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spdiagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
spdiagm(m::Integer, n::Integer, kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)</code></pre><p>Construct a sparse diagonal matrix from <code>Pair</code>s of vectors and diagonals. Each vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal.  By default, the matrix is square and its size is inferred from <code>kv</code>, but a non-square size <code>m</code>Ã<code>n</code> (padded with zeros as needed) can be specified by passing <code>m,n</code> as the first arguments.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spdiagm(-1 =&gt; [1,2,3,4], 1 =&gt; [4,3,2,1])
5Ã5 SparseMatrixCSC{Int64, Int64} with 8 stored entries:
 â  4  â  â  â
 1  â  3  â  â
 â  2  â  2  â
 â  â  3  â  1
 â  â  â  4  â</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L3689-L3709">source</a></section><section><div><pre><code class="nohighlight hljs">spdiagm(v::AbstractVector)
spdiagm(m::Integer, n::Integer, v::AbstractVector)</code></pre><p>Construct a sparse matrix with elements of the vector as diagonal elements. By default (no given <code>m</code> and <code>n</code>), the matrix is square and its size is given by <code>length(v)</code>, but a non-square size <code>m</code>Ã<code>n</code> can be specified by passing <code>m</code> and <code>n</code> as the first arguments.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>These functions require at least Julia 1.6.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spdiagm([1,2,3])
3Ã3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 1  â  â
 â  2  â
 â  â  3

julia&gt; spdiagm(sparse([1,0,3]))
3Ã3 SparseMatrixCSC{Int64, Int64} with 2 stored entries:
 1  â  â
 â  â  â
 â  â  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L3713-L3739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse_hcat" href="#SparseArrays.sparse_hcat"><code>SparseArrays.sparse_hcat</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse_hcat(A...)</code></pre><p>Concatenate along dimension 2. Return a SparseMatrixCSC object.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>This method was added in Julia 1.8. It mimicks previous concatenation behavior, where the concatenation with specialized &quot;sparse&quot; matrix types from LinearAlgebra.jl automatically yielded sparse output even in the absence of any SparseArray argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L1115-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse_vcat" href="#SparseArrays.sparse_vcat"><code>SparseArrays.sparse_vcat</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse_vcat(A...)</code></pre><p>Concatenate along dimension 1. Return a SparseMatrixCSC object.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>This method was added in Julia 1.8. It mimicks previous concatenation behavior, where the concatenation with specialized &quot;sparse&quot; matrix types from LinearAlgebra.jl automatically yielded sparse output even in the absence of any SparseArray argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L1130-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse_hvcat" href="#SparseArrays.sparse_hvcat"><code>SparseArrays.sparse_hvcat</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse_hvcat(rows::Tuple{Vararg{Int}}, values...)</code></pre><p>Sparse horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>This method was added in Julia 1.8. It mimicks previous concatenation behavior, where the concatenation with specialized &quot;sparse&quot; matrix types from LinearAlgebra.jl automatically yielded sparse output even in the absence of any SparseArray argument.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L1145-L1156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.blockdiag" href="#SparseArrays.blockdiag"><code>SparseArrays.blockdiag</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blockdiag(A...)</code></pre><p>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; blockdiag(sparse(2I, 3, 3), sparse(4I, 2, 2))
5Ã5 SparseMatrixCSC{Int64, Int64} with 5 stored entries:
 2  â  â  â  â
 â  2  â  â  â
 â  â  2  â  â
 â  â  â  4  â
 â  â  â  â  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L3462-L3477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sprand" href="#SparseArrays.sprand"><code>SparseArrays.sprand</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sprand([rng],[type],m,[n],p::AbstractFloat,[rfn])</code></pre><p>Create a random length <code>m</code> sparse vector or <code>m</code> by <code>n</code> sparse matrix, in which the probability of any element being nonzero is independently given by <code>p</code> (and hence the mean density of nonzeros is also exactly <code>p</code>). Nonzero values are sampled from the distribution specified by <code>rfn</code> and have the type <code>type</code>. The uniform distribution is used in case <code>rfn</code> is not specified. The optional <code>rng</code> argument specifies a random number generator, see <a href="../Random/#Random-Numbers">Random Numbers</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sprand(Bool, 2, 2, 0.5)
2Ã2 SparseMatrixCSC{Bool, Int64} with 2 stored entries:
 1  1
 â  â

julia&gt; sprand(Float64, 3, 0.75)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  0.795547
  [2]  =  0.49425</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1660-L1682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sprandn" href="#SparseArrays.sprandn"><code>SparseArrays.sprandn</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sprandn([rng][,Type],m[,n],p::AbstractFloat)</code></pre><p>Create a random sparse vector of length <code>m</code> or sparse matrix of size <code>m</code> by <code>n</code> with the specified (independent) probability <code>p</code> of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional <code>rng</code> argument specifies a random number generator, see <a href="../Random/#Random-Numbers">Random Numbers</a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Specifying the output element type <code>Type</code> requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sprandn(2, 2, 0.75)
2Ã2 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 -1.20577     â
  0.311817  -0.234641</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1707-L1725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nonzeros" href="#SparseArrays.nonzeros"><code>SparseArrays.nonzeros</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nonzeros(A)</code></pre><p>Return a vector of the structural nonzero values in sparse array <code>A</code>. This includes zeros that are explicitly stored in the sparse array. The returned vector points directly to the internal nonzero storage of <code>A</code>, and any modifications to the returned vector will mutate <code>A</code> as well. See <a href="#SparseArrays.rowvals"><code>rowvals</code></a> and <a href="#SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3Ã3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  â  â
 â  2  â
 â  â  2

julia&gt; nonzeros(A)
3-element Vector{Int64}:
 2
 2
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L140-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.rowvals" href="#SparseArrays.rowvals"><code>SparseArrays.rowvals</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rowvals(A::AbstractSparseMatrixCSC)</code></pre><p>Return a vector of the row indices of <code>A</code>. Any modifications to the returned vector will mutate <code>A</code> as well. Providing access to how the row indices are stored internally can be useful in conjunction with iterating over structural nonzero values. See also <a href="#SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#SparseArrays.nzrange"><code>nzrange</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse(2I, 3, 3)
3Ã3 SparseMatrixCSC{Int64, Int64} with 3 stored entries:
 2  â  â
 â  2  â
 â  â  2

julia&gt; rowvals(A)
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L169-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nzrange" href="#SparseArrays.nzrange"><code>SparseArrays.nzrange</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nzrange(A::AbstractSparseMatrixCSC, col::Integer)</code></pre><p>Return the range of indices to the structural nonzero values of a sparse matrix column. In conjunction with <a href="#SparseArrays.nonzeros"><code>nonzeros</code></a> and <a href="#SparseArrays.rowvals"><code>rowvals</code></a>, this allows for convenient iterating over a sparse matrix :</p><pre><code class="nohighlight hljs">A = sparse(I,J,V)
rows = rowvals(A)
vals = nonzeros(A)
m, n = size(A)
for j = 1:n
   for i in nzrange(A, j)
      row = rows[i]
      val = vals[i]
      # perform sparse wizardry...
   end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L197-L215">source</a></section><section><div><pre><code class="nohighlight hljs">nzrange(x::SparseVectorUnion, col)</code></pre><p>Give the range of indices to the structural nonzero values of a sparse vector. The column index <code>col</code> is ignored (assumed to be <code>1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.droptol!" href="#SparseArrays.droptol!"><code>SparseArrays.droptol!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">droptol!(A::AbstractSparseMatrixCSC, tol)</code></pre><p>Removes stored values from <code>A</code> whose absolute value is less than or equal to <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1525-L1529">source</a></section><section><div><pre><code class="nohighlight hljs">droptol!(x::SparseVector, tol)</code></pre><p>Removes stored values from <code>x</code> whose absolute value is less than or equal to <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L2017-L2021">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros!" href="#SparseArrays.dropzeros!"><code>SparseArrays.dropzeros!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropzeros!(A::AbstractSparseMatrixCSC;)</code></pre><p>Removes stored numerical zeros from <code>A</code>.</p><p>For an out-of-place version, see <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays-8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1533-L1540">source</a></section><section><div><pre><code class="nohighlight hljs">dropzeros!(x::SparseVector)</code></pre><p>Removes stored numerical zeros from <code>x</code>.</p><p>For an out-of-place version, see <a href="#SparseArrays.dropzeros"><code>dropzeros</code></a>. For algorithmic information, see <code>fkeep!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/76fa18281db20bde90d0534a2b08b092f165df8c/stdlib/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L2024-L2031">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros" href="#SparseArrays.dropzeros"><code>SparseArrays.dropzeros</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropzeros(A::AbstractSparseMatrixCSC;)</code></pre><p>Generates a copy of <code>A</code> and removes stored numerical zeros from that copy.</p><p>For an in-place version and algorithmic information, see <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparse([1, 2, 3], [1, 2, 3], [1.0, 0.0, 1.0])
3Ã3 SparseMatrixCSC{Float64, Int64} with 3 stored entries:
 1.0   â    â
  â   0.0   â
  â    â   1.0

julia&gt; dropzeros(A)
3Ã3 SparseMatrixCSC{Float64, Int64} with 2 stored entries:
 1.0   â    â
  â    â    â
  â    â   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1543-L1564">source</a></section><section><div><pre><code class="nohighlight hljs">dropzeros(x::SparseVector)</code></pre><p>Generates a copy of <code>x</code> and removes numerical zeros from that copy.</p><p>For an in-place version and algorithmic information, see <a href="#SparseArrays.dropzeros!"><code>dropzeros!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = sparsevec([1, 2, 3], [1.0, 0.0, 1.0])
3-element SparseVector{Float64, Int64} with 3 stored entries:
  [1]  =  1.0
  [2]  =  0.0
  [3]  =  1.0

julia&gt; dropzeros(A)
3-element SparseVector{Float64, Int64} with 2 stored entries:
  [1]  =  1.0
  [3]  =  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsevector.jl#L2034-L2054">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.permute" href="#SparseArrays.permute"><code>SparseArrays.permute</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
        q::AbstractVector{&lt;:Integer}) where {Tv,Ti}</code></pre><p>Bilaterally permute <code>A</code>, returning <code>PAQ</code> (<code>A[p,q]</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == size(A, 2)</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == size(A, 1)</code>).</p><p>For expert drivers and additional information, see <a href="../../base/arrays/#Base.permute!-Tuple{Any, AbstractVector}"><code>permute!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = spdiagm(0 =&gt; [1, 2, 3, 4], 1 =&gt; [5, 6, 7])
4Ã4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 1  5  â  â
 â  2  6  â
 â  â  3  7
 â  â  â  4

julia&gt; permute(A, [4, 3, 2, 1], [1, 2, 3, 4])
4Ã4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 â  â  â  4
 â  â  3  7
 â  2  6  â
 1  5  â  â

julia&gt; permute(A, [1, 2, 3, 4], [4, 3, 2, 1])
4Ã4 SparseMatrixCSC{Int64, Int64} with 7 stored entries:
 â  â  5  1
 â  6  2  â
 7  3  â  â
 4  â  â  â</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1405-L1438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}" href="#Base.permute!-Union{Tuple{Tq}, Tuple{Tp}, Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, SparseMatrixCSC{Tv, Ti}, AbstractVector{Tp}, AbstractVector{Tq}}} where {Tv, Ti, Tp&lt;:Integer, Tq&lt;:Integer}"><code>Base.permute!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permute!(X::AbstractSparseMatrixCSC{Tv,Ti}, A::AbstractSparseMatrixCSC{Tv,Ti},
         p::AbstractVector{&lt;:Integer}, q::AbstractVector{&lt;:Integer},
         [C::AbstractSparseMatrixCSC{Tv,Ti}]) where {Tv,Ti}</code></pre><p>Bilaterally permute <code>A</code>, storing result <code>PAQ</code> (<code>A[p,q]</code>) in <code>X</code>. Stores intermediate result <code>(AQ)^T</code> (<code>transpose(A[:,q])</code>) in optional argument <code>C</code> if present. Requires that none of <code>X</code>, <code>A</code>, and, if present, <code>C</code> alias each other; to store result <code>PAQ</code> back into <code>A</code>, use the following method lacking <code>X</code>:</p><pre><code class="nohighlight hljs">permute!(A::AbstractSparseMatrixCSC{Tv,Ti}, p::AbstractVector{&lt;:Integer},
         q::AbstractVector{&lt;:Integer}[, C::AbstractSparseMatrixCSC{Tv,Ti},
         [workcolptr::Vector{Ti}]]) where {Tv,Ti}</code></pre><p><code>X</code>&#39;s dimensions must match those of <code>A</code> (<code>size(X, 1) == size(A, 1)</code> and <code>size(X, 2) == size(A, 2)</code>), and <code>X</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(rowvals(X)) &gt;= nnz(A)</code> and <code>length(nonzeros(X)) &gt;= nnz(A)</code>). Column-permutation <code>q</code>&#39;s length must match <code>A</code>&#39;s column count (<code>length(q) == size(A, 2)</code>). Row-permutation <code>p</code>&#39;s length must match <code>A</code>&#39;s row count (<code>length(p) == size(A, 1)</code>).</p><p><code>C</code>&#39;s dimensions must match those of <code>transpose(A)</code> (<code>size(C, 1) == size(A, 2)</code> and <code>size(C, 2) == size(A, 1)</code>), and <code>C</code> must have enough storage to accommodate all allocated entries in <code>A</code> (<code>length(rowvals(C)) &gt;= nnz(A)</code> and <code>length(nonzeros(C)) &gt;= nnz(A)</code>).</p><p>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods <code>unchecked_noalias_permute!</code> and <code>unchecked_aliasing_permute!</code>.</p><p>See also <a href="#SparseArrays.permute"><code>permute</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/SparseArrays.jl/blob/8d397ccc5a2fa6ac6832623ae291cb3acff72d4f/src/sparsematrix.jl#L1327-L1356">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Sockets/">Â« Sockets</a><a class="docs-footer-nextpage" href="../Statistics/">Statistics Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 9 February 2022 22:43">Wednesday 9 February 2022</span>. Using Julia version 1.8.0-DEV.1483.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
