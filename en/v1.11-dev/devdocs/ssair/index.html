<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia SSA-form IR · The Julia Language</title><meta name="title" content="Julia SSA-form IR · The Julia Language"/><meta property="og:title" content="Julia SSA-form IR · The Julia Language"/><meta property="twitter:title" content="Julia SSA-form IR · The Julia Language"/><meta name="description" content="Documentation for The Julia Language."/><meta property="og:description" content="Documentation for The Julia Language."/><meta property="twitter:description" content="Documentation for The Julia Language."/><meta property="og:url" content="https://docs.julialang.org/en/v1/devdocs/ssair/"/><meta property="twitter:url" content="https://docs.julialang.org/en/v1/devdocs/ssair/"/><link rel="canonical" href="https://docs.julialang.org/en/v1/devdocs/ssair/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-28835595-6"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-28835595-6', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="The Julia Language logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../../manual/strings/">Strings</a></li><li><a class="tocitem" href="../../manual/functions/">Functions</a></li><li><a class="tocitem" href="../../manual/control-flow/">Control Flow</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../../manual/types/">Types</a></li><li><a class="tocitem" href="../../manual/methods/">Methods</a></li><li><a class="tocitem" href="../../manual/constructors/">Constructors</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../../manual/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../../manual/modules/">Modules</a></li><li><a class="tocitem" href="../../manual/documentation/">Documentation</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../manual/arrays/">Single- and multi-dimensional Arrays</a></li><li><a class="tocitem" href="../../manual/missing/">Missing Values</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../../manual/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="tocitem" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">Code Loading</a></li><li><a class="tocitem" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../../manual/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode Input</a></li><li><a class="tocitem" href="../../manual/command-line-interface/">Command-line Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../base/base/">Essentials</a></li><li><a class="tocitem" href="../../base/collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../../base/math/">Mathematics</a></li><li><a class="tocitem" href="../../base/numbers/">Numbers</a></li><li><a class="tocitem" href="../../base/strings/">Strings</a></li><li><a class="tocitem" href="../../base/arrays/">Arrays</a></li><li><a class="tocitem" href="../../base/parallel/">Tasks</a></li><li><a class="tocitem" href="../../base/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../base/scopedvalues/">Scoped Values</a></li><li><a class="tocitem" href="../../base/constants/">Constants</a></li><li><a class="tocitem" href="../../base/file/">Filesystem</a></li><li><a class="tocitem" href="../../base/io-network/">I/O and Network</a></li><li><a class="tocitem" href="../../base/punctuation/">Punctuation</a></li><li><a class="tocitem" href="../../base/sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../../base/iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../../base/reflection/">Reflection and introspection</a></li><li><a class="tocitem" href="../../base/c/">C Interface</a></li><li><a class="tocitem" href="../../base/libc/">C Standard Library</a></li><li><a class="tocitem" href="../../base/stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../../base/simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/ArgTools/">ArgTools</a></li><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibCURL/">LibCURL</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">Logging</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../../stdlib/NetworkOptions/">Network Options</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">Profiling</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="tocitem" href="../../stdlib/StyledStrings/">StyledStrings</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Tar/">Tar</a></li><li><a class="tocitem" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/creating-packages/">Creating Packages</a></li><li><a class="tocitem" href="../../tutorials/profile/">Profiling</a></li><li><a class="tocitem" href="../../tutorials/external/">External Tutorials</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox" checked/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../ast/">Julia ASTs</a></li><li><a class="tocitem" href="../types/">More about types</a></li><li><a class="tocitem" href="../object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../functions/">Julia Functions</a></li><li><a class="tocitem" href="../cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../subarrays/">SubArrays</a></li><li><a class="tocitem" href="../isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../sysimg/">System Image Building</a></li><li><a class="tocitem" href="../pkgimg/">Package Images</a></li><li><a class="tocitem" href="../llvm-passes/">Custom LLVM Passes</a></li><li><a class="tocitem" href="../llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../require/">Module loading</a></li><li><a class="tocitem" href="../inference/">Inference</a></li><li class="is-active"><a class="tocitem" href>Julia SSA-form IR</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Categories-of-IR-nodes"><span>Categories of IR nodes</span></a></li><li><a class="tocitem" href="#Main-SSA-data-structure"><span>Main SSA data structure</span></a></li></ul></li><li><a class="tocitem" href="../EscapeAnalysis/"><code>EscapeAnalysis</code></a></li><li><a class="tocitem" href="../aot/">Ahead of Time Compilation</a></li><li><a class="tocitem" href="../gc-sa/">Static analyzer annotations for GC correctness in C code</a></li><li><a class="tocitem" href="../gc/">Garbage Collection in Julia</a></li><li><a class="tocitem" href="../jit/">JIT Design and Implementation</a></li><li><a class="tocitem" href="../builtins/">Core.Builtins</a></li><li><a class="tocitem" href="../precompile_hang/">Fixing precompilation hangs due to open tasks or IO</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../external_profilers/">External Profiler Support</a></li><li><a class="tocitem" href="../sanitizers/">Sanitizer support</a></li><li><a class="tocitem" href="../probes/">Instrumenting Julia with DTrace, and bpftrace</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Building Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../build/build/">Building Julia (Detailed)</a></li><li><a class="tocitem" href="../build/linux/">Linux</a></li><li><a class="tocitem" href="../build/macos/">macOS</a></li><li><a class="tocitem" href="../build/windows/">Windows</a></li><li><a class="tocitem" href="../build/freebsd/">FreeBSD</a></li><li><a class="tocitem" href="../build/arm/">ARM (Linux)</a></li><li><a class="tocitem" href="../build/distributing/">Binary distributions</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li><a class="is-disabled">Documentation of Julia&#39;s Internals</a></li><li class="is-active"><a href>Julia SSA-form IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia SSA-form IR</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/devdocs/ssair.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-SSA-form-IR"><a class="docs-heading-anchor" href="#Julia-SSA-form-IR">Julia SSA-form IR</a><a id="Julia-SSA-form-IR-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-SSA-form-IR" title="Permalink"></a></h1><p>Julia uses a static single assignment intermediate representation (<a href="https://en.wikipedia.org/wiki/Static_single-assignment_form">SSA IR</a>) to perform optimization. This IR is different from LLVM IR, and unique to Julia. It allows for Julia specific optimizations.</p><ol><li>Basic blocks (regions with no control flow) are explicitly annotated.</li><li>if/else and loops are turned into <code>goto</code> statements.</li><li>lines with multiple operations are split into multiple lines by introducing variables.</li></ol><p>For example the following Julia code:</p><pre><code class="language-julia hljs">function foo(x)
    y = sin(x)
    if x &gt; 5.0
        y = y + cos(x)
    end
    return exp(2) + y
end</code></pre><p>when called with a <code>Float64</code> argument is translated into:</p><pre><code class="language-julia hljs">using InteractiveUtils
@code_typed foo(1.0)</code></pre><pre><code class="language-llvm hljs">CodeInfo(
1 ─ %1 = invoke Main.sin(x::Float64)::Float64
│   %2 = Base.lt_float(x, 5.0)::Bool
└──      goto #3 if not %2
2 ─ %4 = invoke Main.cos(x::Float64)::Float64
└── %5 = Base.add_float(%1, %4)::Float64
3 ┄ %6 = φ (#2 =&gt; %5, #1 =&gt; %1)::Float64
│   %7 = Base.add_float(7.38905609893065, %6)::Float64
└──      return %7
) =&gt; Float64</code></pre><p>In this example, we can see all of these changes.</p><ol><li>The first basic block is everything in</li></ol><pre><code class="language-llvm hljs">1 ─ %1 = invoke Main.sin(x::Float64)::Float64
│   %2 = Base.lt_float(x, 5.0)::Bool
└──      goto #3 if not %2</code></pre><ol><li>The <code>if</code> statement is translated into <code>goto #3 if not %2</code> which goes to the 3rd basic block if <code>x&gt;5</code> isn&#39;t met and otherwise goes to the second basic block.</li><li><code>%2</code> is an SSA value introduced to represent <code>x &gt; 5</code>.</li></ol><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p>Beginning in Julia 0.7, parts of the compiler use a new <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA-form</a> intermediate representation (IR). Historically, the compiler would directly generate LLVM IR from a lowered form of the Julia AST. This form had most syntactic abstractions removed, but still looked a lot like an abstract syntax tree. Over time, in order to facilitate optimizations, SSA values were introduced to this IR and the IR was linearized (i.e. turned into a form where function arguments could only be SSA values or constants). However, non-SSA values (slots) remained in the IR due to the lack of Phi nodes in the IR (necessary for back-edges and re-merging of conditional control flow). This negated much of the usefulness of SSA form representation when performing middle end optimizations. Some heroic effort was put into making these optimizations work without a complete SSA form representation, but the lack of such a representation ultimately proved prohibitive.</p><h2 id="Categories-of-IR-nodes"><a class="docs-heading-anchor" href="#Categories-of-IR-nodes">Categories of IR nodes</a><a id="Categories-of-IR-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Categories-of-IR-nodes" title="Permalink"></a></h2><p>The SSA IR representation has four categories of IR nodes: Phi, Pi, PhiC, and Upsilon nodes (the latter two are only used for exception handling).</p><h3 id="Phi-nodes-and-Pi-nodes"><a class="docs-heading-anchor" href="#Phi-nodes-and-Pi-nodes">Phi nodes and Pi nodes</a><a id="Phi-nodes-and-Pi-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Phi-nodes-and-Pi-nodes" title="Permalink"></a></h3><p>Phi nodes are part of generic SSA abstraction (see the link above if you&#39;re not familiar with the concept). In the Julia IR, these nodes are represented as:</p><pre><code class="nohighlight hljs">struct PhiNode
    edges::Vector{Int32}
    values::Vector{Any}
end</code></pre><p>where we ensure that both vectors always have the same length. In the canonical representation (the one handled by codegen and the interpreter), the edge values indicate come-from statement numbers (i.e. if edge has an entry of <code>15</code>, there must be a <code>goto</code>, <code>gotoifnot</code> or implicit fall through from statement <code>15</code> that targets this phi node). Values are either SSA values or constants. It is also possible for a value to be unassigned if the variable was not defined on this path. However, undefinedness checks get explicitly inserted and represented as booleans after middle end optimizations, so code generators may assume that any use of a Phi node will have an assigned value in the corresponding slot. It is also legal for the mapping to be incomplete, i.e. for a Phi node to have missing incoming edges. In that case, it must be dynamically guaranteed that the corresponding value will not be used.</p><p>Note that SSA uses semantically occur after the terminator of the corresponding predecessor (&quot;on the edge&quot;). Consequently, if multiple Phi nodes appear at the start of a basic block, they are run simultaneously. This means that in the following IR snippet, if we came from block <code>23</code>, <code>%46</code> will take the value associated to <code>%45</code> <em>before</em> we entered this block.</p><pre><code class="language-julia hljs">%45 = φ (#18 =&gt; %23, #23 =&gt; %50)
%46 = φ (#18 =&gt; 1.0, #23 =&gt; %45)</code></pre><p>PiNodes encode statically proven information that may be implicitly assumed in basic blocks dominated by a given pi node. They are conceptually equivalent to the technique introduced in the paper <a href="https://dl.acm.org/citation.cfm?id=358438.349342">ABCD: Eliminating Array Bounds Checks on Demand</a> or the predicate info nodes in LLVM. To see how they work, consider, e.g.</p><pre><code class="language-julia hljs">%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value
if isa(x, Int)
    # use x
else
    # use x
end</code></pre><p>We can perform predicate insertion and turn this into:</p><pre><code class="language-julia hljs">%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value
if isa(x, Int)
    %x_int = PiNode(x, Int)
    # use %x_int
else
    %x_float = PiNode(x, Float64)
    # use %x_float
end</code></pre><p>Pi nodes are generally ignored in the interpreter, since they don&#39;t have any effect on the values, but they may sometimes lead to code generation in the compiler (e.g. to change from an implicitly union split representation to a plain unboxed representation). The main usefulness of PiNodes stems from the fact that path conditions of the values can be accumulated simply by def-use chain walking that is generally done for most optimizations that care about these conditions anyway.</p><h3 id="PhiC-nodes-and-Upsilon-nodes"><a class="docs-heading-anchor" href="#PhiC-nodes-and-Upsilon-nodes">PhiC nodes and Upsilon nodes</a><a id="PhiC-nodes-and-Upsilon-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#PhiC-nodes-and-Upsilon-nodes" title="Permalink"></a></h3><p>Exception handling complicates the SSA story moderately, because exception handling introduces additional control flow edges into the IR across which values must be tracked. One approach to do so, which is followed by LLVM, is to make calls which may throw exceptions into basic block terminators and add an explicit control flow edge to the catch handler:</p><pre><code class="nohighlight hljs">invoke @function_that_may_throw() to label %regular unwind to %catch

regular:
# Control flow continues here

catch:
# Exceptions go here</code></pre><p>However, this is problematic in a language like Julia, where at the start of the optimization pipeline, we do not know which calls throw. We would have to conservatively assume that every call (which in Julia is every statement) throws. This would have several negative effects. On the one hand, it would essentially reduce the scope of every basic block to a single call, defeating the purpose of having operations be performed at the basic block level. On the other hand, every catch basic block would have <code>n*m</code> phi node arguments (<code>n</code>, the number of statements in the critical region, <code>m</code> the number of live values through the catch block).</p><p>To work around this, we use a combination of <code>Upsilon</code> and <code>PhiC</code> nodes (the C standing for <code>catch</code>, written <code>φᶜ</code> in the IR pretty printer, because unicode subscript c is not available). There are several ways to think of these nodes, but perhaps the easiest is to think of each <code>PhiC</code> as a load from a unique store-many, read-once slot, with <code>Upsilon</code> being the corresponding store operation. The <code>PhiC</code> has an operand list of all the upsilon nodes that store to its implicit slot. The <code>Upsilon</code> nodes however, do not record which <code>PhiC</code> node they store to. This is done for more natural integration with the rest of the SSA IR. E.g. if there are no more uses of a <code>PhiC</code> node, it is safe to delete it, and the same is true of an <code>Upsilon</code> node. In most IR passes, <code>PhiC</code> nodes can be treated like <code>Phi</code> nodes. One can follow use-def chains through them, and they can be lifted to new <code>PhiC</code> nodes and new <code>Upsilon</code> nodes (in the same places as the original <code>Upsilon</code> nodes). The result of this scheme is that the number of <code>Upsilon</code> nodes (and <code>PhiC</code> arguments) is proportional to the number of assigned values to a particular variable (before SSA conversion), rather than the number of statements in the critical region.</p><p>To see this scheme in action, consider the function</p><pre><code class="language-julia hljs">@noinline opaque() = invokelatest(identity, nothing) # Something opaque
function foo()
    local y
    x = 1
    try
        y = 2
        opaque()
        y = 3
        error()
    catch
    end
    (x, y)
end</code></pre><p>The corresponding IR (with irrelevant types stripped) is:</p><pre><code class="nohighlight hljs">1 ─       nothing::Nothing
2 ─ %2  = $(Expr(:enter, #4))
3 ─ %3  = ϒ (false)
│   %4  = ϒ (#undef)
│   %5  = ϒ (1)
│   %6  = ϒ (true)
│   %7  = ϒ (2)
│         invoke Main.opaque()::Any
│   %9  = ϒ (true)
│   %10 = ϒ (3)
│         invoke Main.error()::Union{}
└──       $(Expr(:unreachable))::Union{}
4 ┄ %13 = φᶜ (%3, %6, %9)::Bool
│   %14 = φᶜ (%4, %7, %10)::Core.Compiler.MaybeUndef(Int64)
│   %15 = φᶜ (%5)::Core.Const(1)
└──       $(Expr(:leave, Core.SSAValue(2)))
5 ─       $(Expr(:pop_exception, :(%2)))::Any
│         $(Expr(:throw_undef_if_not, :y, :(%13)))::Any
│   %19 = Core.tuple(%15, %14)
└──       return %19</code></pre><p>Note in particular that every value live into the critical region gets an upsilon node at the top of the critical region. This is because catch blocks are considered to have an invisible control flow edge from outside the function. As a result, no SSA value dominates the catch blocks, and all incoming values have to come through a <code>φᶜ</code> node.</p><h2 id="Main-SSA-data-structure"><a class="docs-heading-anchor" href="#Main-SSA-data-structure">Main SSA data structure</a><a id="Main-SSA-data-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Main-SSA-data-structure" title="Permalink"></a></h2><p>The main <code>SSAIR</code> data structure is worthy of discussion. It draws inspiration from LLVM and Webkit&#39;s B3 IR. The core of the data structure is a flat vector of statements. Each statement is implicitly assigned an SSA value based on its position in the vector (i.e. the result of the statement at idx 1 can be accessed using <code>SSAValue(1)</code> etc). For each SSA value, we additionally maintain its type. Since, SSA values are definitionally assigned only once, this type is also the result type of the expression at the corresponding index. However, while this representation is rather efficient (since the assignments don&#39;t need to be explicitly encoded), it of course carries the drawback that order is semantically significant, so reorderings and insertions change statement numbers. Additionally, we do not keep use lists (i.e. it is impossible to walk from a def to all its uses without explicitly computing this map–def lists however are trivial since you can look up the corresponding statement from the index), so the LLVM-style RAUW (replace-all-uses-with) operation is unavailable.</p><p>Instead, we do the following:</p><ul><li>We keep a separate buffer of nodes to insert (including the position to insert them at, the type of the corresponding value and the node itself). These nodes are numbered by their occurrence in the insertion buffer, allowing their values to be immediately used elsewhere in the IR (i.e. if there are 12 statements in the original statement list, the first new statement will be accessible as <code>SSAValue(13)</code>).</li><li>RAUW style operations are performed by setting the corresponding statement index to the replacement value.</li><li>Statements are erased by setting the corresponding statement to <code>nothing</code> (this is essentially just a special-case convention of the above).</li><li>If there are any uses of the statement being erased, they will be set to <code>nothing</code>.</li></ul><p>There is a <code>compact!</code> function that compacts the above data structure by performing the insertion of nodes in the appropriate place, trivial copy propagation, and renaming of uses to any changed SSA values. However, the clever part of this scheme is that this compaction can be done lazily as part of the subsequent pass. Most optimization passes need to walk over the entire list of statements, performing analysis or modifications along the way. We provide an <code>IncrementalCompact</code> iterator that can be used to iterate over the statement list. It will perform any necessary compaction and return the new index of the node, as well as the node itself. It is legal at this point to walk def-use chains, as well as make any modifications or deletions to the IR (insertions are disallowed however).</p><p>The idea behind this arrangement is that, since the optimization passes need to touch the corresponding memory anyway and incur the corresponding memory access penalty, performing the extra housekeeping should have comparatively little overhead (and save the overhead of maintaining these data structures during IR modification).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inference/">« Inference</a><a class="docs-footer-nextpage" href="../EscapeAnalysis/"><code>EscapeAnalysis</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 30 December 2023 00:01">Saturday 30 December 2023</span>. Using Julia version 1.11.0-DEV.1168.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
