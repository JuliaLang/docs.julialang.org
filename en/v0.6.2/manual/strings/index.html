<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="robots" content="noindex"/><title>Strings Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname+location.search+location.hash});
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../introduction/">Introduction</a></li><li><a class="toctext" href="../getting-started/">Getting Started</a></li><li><a class="toctext" href="../variables/">Variables</a></li><li><a class="toctext" href="../integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li class="current"><a class="toctext" href>Strings</a><ul class="internal"><li><a class="toctext" href="#man-characters-1">Characters</a></li><li><a class="toctext" href="#String-Basics-1">String Basics</a></li><li><a class="toctext" href="#Unicode-and-UTF-8-1">Unicode and UTF-8</a></li><li><a class="toctext" href="#Concatenation-1">Concatenation</a></li><li><a class="toctext" href="#string-interpolation-1">Interpolation</a></li><li><a class="toctext" href="#Triple-Quoted-String-Literals-1">Triple-Quoted String Literals</a></li><li><a class="toctext" href="#Common-Operations-1">Common Operations</a></li><li><a class="toctext" href="#non-standard-string-literals-1">Non-Standard String Literals</a></li><li><a class="toctext" href="#Regular-Expressions-1">Regular Expressions</a></li><li><a class="toctext" href="#man-byte-array-literals-1">Byte Array Literals</a></li><li><a class="toctext" href="#man-version-number-literals-1">Version Number Literals</a></li><li><a class="toctext" href="#man-raw-string-literals-1">Raw String Literals</a></li></ul></li><li><a class="toctext" href="../functions/">Functions</a></li><li><a class="toctext" href="../control-flow/">Control Flow</a></li><li><a class="toctext" href="../variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../methods/">Methods</a></li><li><a class="toctext" href="../constructors/">Constructors</a></li><li><a class="toctext" href="../conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li><a class="toctext" href="../modules/">Modules</a></li><li><a class="toctext" href="../documentation/">Documentation</a></li><li><a class="toctext" href="../metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../linear-algebra/">Linear algebra</a></li><li><a class="toctext" href="../networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../dates/">Date and DateTime</a></li><li><a class="toctext" href="../interacting-with-julia/">Interacting With Julia</a></li><li><a class="toctext" href="../running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../embedding/">Embedding Julia</a></li><li><a class="toctext" href="../packages/">Packages</a></li><li><a class="toctext" href="../profile/">Profiling</a></li><li><a class="toctext" href="../stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../style-guide/">Style Guide</a></li><li><a class="toctext" href="../faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../../stdlib/base/">Essentials</a></li><li><a class="toctext" href="../../stdlib/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../../stdlib/math/">Mathematics</a></li><li><a class="toctext" href="../../stdlib/numbers/">Numbers</a></li><li><a class="toctext" href="../../stdlib/strings/">Strings</a></li><li><a class="toctext" href="../../stdlib/arrays/">Arrays</a></li><li><a class="toctext" href="../../stdlib/parallel/">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../../stdlib/linalg/">Linear Algebra</a></li><li><a class="toctext" href="../../stdlib/constants/">Constants</a></li><li><a class="toctext" href="../../stdlib/file/">Filesystem</a></li><li><a class="toctext" href="../../stdlib/io-network/">I/O and Network</a></li><li><a class="toctext" href="../../stdlib/punctuation/">Punctuation</a></li><li><a class="toctext" href="../../stdlib/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../../stdlib/pkg/">Package Manager Functions</a></li><li><a class="toctext" href="../../stdlib/dates/">Dates and Time</a></li><li><a class="toctext" href="../../stdlib/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../../stdlib/test/">Unit Testing</a></li><li><a class="toctext" href="../../stdlib/c/">C Interface</a></li><li><a class="toctext" href="../../stdlib/libc/">C Standard Library</a></li><li><a class="toctext" href="../../stdlib/libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../../stdlib/profile/">Profiling</a></li><li><a class="toctext" href="../../stdlib/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../../stdlib/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../../devdocs/types/">More about types</a></li><li><a class="toctext" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../../devdocs/libgit2/">Base.LibGit2</a></li><li><a class="toctext" href="../../devdocs/require/">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Strings</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/doc/src/manual/strings.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Strings</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="man-strings-1" href="#man-strings-1">Strings</a></h1><p>Strings are finite sequences of characters. Of course, the real trouble comes when one asks what a character is. The characters that English speakers are familiar with are the letters <code>A</code>, <code>B</code>, <code>C</code>, etc., together with numerals and common punctuation symbols. These characters are standardized together with a mapping to integer values between 0 and 127 by the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> standard. There are, of course, many other characters used in non-English languages, including variants of the ASCII characters with accents and other modifications, related scripts such as Cyrillic and Greek, and scripts completely unrelated to ASCII and English, including Arabic, Chinese, Hebrew, Hindi, Japanese, and Korean. The <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> standard tackles the complexities of what exactly a character is, and is generally accepted as the definitive standard addressing this problem. Depending on your needs, you can either ignore these complexities entirely and just pretend that only ASCII characters exist, or you can write code that can handle any of the characters or encodings that one may encounter when handling non-ASCII text. Julia makes dealing with plain ASCII text simple and efficient, and handling Unicode is as simple and efficient as possible. In particular, you can write C-style string code to process ASCII strings, and they will work as expected, both in terms of performance and semantics. If such code encounters non-ASCII text, it will gracefully fail with a clear error message, rather than silently introducing corrupt results. When this happens, modifying the code to handle non-ASCII data is straightforward.</p><p>There are a few noteworthy high-level features about Julia&#39;s strings:</p><ul><li><p>The built-in concrete type used for strings (and string literals) in Julia is <a href="../../stdlib/strings/#Core.String-Tuple{AbstractString}"><code>String</code></a>. This supports the full range of <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> characters via the <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> encoding. (A <a href="../../stdlib/strings/#Base.transcode"><code>transcode()</code></a> function is provided to convert to/from other Unicode encodings.)</p></li><li><p>All string types are subtypes of the abstract type <code>AbstractString</code>, and external packages define additional <code>AbstractString</code> subtypes (e.g. for other encodings).  If you define a function expecting a string argument, you should declare the type as <code>AbstractString</code> in order to accept any string type.</p></li><li><p>Like C and Java, but unlike most dynamic languages, Julia has a first-class type representing a single character, called <code>Char</code>. This is just a special kind of 32-bit primitive type whose numeric value represents a Unicode code point.</p></li><li><p>As in Java, strings are immutable: the value of an <code>AbstractString</code> object cannot be changed. To construct a different string value, you construct a new string from parts of other strings.</p></li><li><p>Conceptually, a string is a <em>partial function</em> from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.</p></li></ul><h2><a class="nav-anchor" id="man-characters-1" href="#man-characters-1">Characters</a></h2><p>A <code>Char</code> value represents a single character: it is just a 32-bit primitive type with a special literal representation and appropriate arithmetic behaviors, whose numeric value is interpreted as a <a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a>. Here is how <code>Char</code> values are input and shown:</p><pre><code class="language-julia-repl">julia&gt; &#39;x&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; typeof(ans)
Char</code></pre><p>You can convert a <code>Char</code> to its integer value, i.e. code point, easily:</p><pre><code class="language-julia-repl">julia&gt; Int(&#39;x&#39;)
120

julia&gt; typeof(ans)
Int64</code></pre><p>On 32-bit architectures, <a href="../../stdlib/base/#Core.typeof"><code>typeof(ans)</code></a> will be <a href="../../stdlib/numbers/#Core.Int32"><code>Int32</code></a>. You can convert an integer value back to a <code>Char</code> just as easily:</p><pre><code class="language-julia-repl">julia&gt; Char(120)
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</code></pre><p>Not all integer values are valid Unicode code points, but for performance, the <code>Char()</code> conversion does not check that every character value is valid. If you want to check that each converted value is a valid code point, use the <a href="../../stdlib/strings/#Base.isvalid-Tuple{Any}"><code>isvalid()</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; Char(0x110000)
&#39;\U110000&#39;: Unicode U+110000 (category Cn: Other, not assigned)

julia&gt; isvalid(Char, 0x110000)
false</code></pre><p>As of this writing, the valid Unicode code points are <code>U+00</code> through <code>U+d7ff</code> and <code>U+e000</code> through <code>U+10ffff</code>. These have not all been assigned intelligible meanings yet, nor are they necessarily interpretable by applications, but all of these values are considered to be valid Unicode characters.</p><p>You can input any Unicode character in single quotes using <code>\u</code> followed by up to four hexadecimal digits or <code>\U</code> followed by up to eight hexadecimal digits (the longest valid value only requires six):</p><pre><code class="language-julia-repl">julia&gt; &#39;\u0&#39;
&#39;\0&#39;: ASCII/Unicode U+0000 (category Cc: Other, control)

julia&gt; &#39;\u78&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &#39;\u2200&#39;
&#39;â&#39;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; &#39;\U10ffff&#39;
&#39;\U10ffff&#39;: Unicode U+10ffff (category Cn: Other, not assigned)</code></pre><p>Julia uses your system&#39;s locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped <code>\u</code> or <code>\U</code> input forms. In addition to these Unicode escape forms, all of <a href="https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes">C&#39;s traditional escaped input forms</a> can also be used:</p><pre><code class="language-julia-repl">julia&gt; Int(&#39;\0&#39;)
0

julia&gt; Int(&#39;\t&#39;)
9

julia&gt; Int(&#39;\n&#39;)
10

julia&gt; Int(&#39;\e&#39;)
27

julia&gt; Int(&#39;\x7f&#39;)
127

julia&gt; Int(&#39;\177&#39;)
127

julia&gt; Int(&#39;\xff&#39;)
255</code></pre><p>You can do comparisons and a limited amount of arithmetic with <code>Char</code> values:</p><pre><code class="language-julia-repl">julia&gt; &#39;A&#39; &lt; &#39;a&#39;
true

julia&gt; &#39;A&#39; &lt;= &#39;a&#39; &lt;= &#39;Z&#39;
false

julia&gt; &#39;A&#39; &lt;= &#39;X&#39; &lt;= &#39;Z&#39;
true

julia&gt; &#39;x&#39; - &#39;a&#39;
23

julia&gt; &#39;A&#39; + 1
&#39;B&#39;: ASCII/Unicode U+0042 (category Lu: Letter, uppercase)</code></pre><h2><a class="nav-anchor" id="String-Basics-1" href="#String-Basics-1">String Basics</a></h2><p>String literals are delimited by double quotes or triple double quotes:</p><pre><code class="language-jldoctest">julia&gt; str = &quot;Hello, world.\n&quot;
&quot;Hello, world.\n&quot;

julia&gt; &quot;&quot;&quot;Contains &quot;quote&quot; characters&quot;&quot;&quot;
&quot;Contains \&quot;quote\&quot; characters&quot;</code></pre><p>If you want to extract a character from a string, you index into it:</p><pre><code class="language-jldoctest">julia&gt; str[1]
&#39;H&#39;: ASCII/Unicode U+0048 (category Lu: Letter, uppercase)

julia&gt; str[6]
&#39;,&#39;: ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[end]
&#39;\n&#39;: ASCII/Unicode U+000a (category Cc: Other, control)</code></pre><p>All indexing in Julia is 1-based: the first element of any integer-indexed object is found at index 1. (As we will see below, this does not necessarily mean that the last element is found at index <code>n</code>, where <code>n</code> is the length of the string.)</p><p>In any indexing expression, the keyword <code>end</code> can be used as a shorthand for the last index (computed by <a href="../../stdlib/collections/#Base.endof"><code>endof(str)</code></a>). You can perform arithmetic and other operations with <code>end</code>, just like a normal value:</p><pre><code class="language-jldoctest">julia&gt; str[end-1]
&#39;.&#39;: ASCII/Unicode U+002e (category Po: Punctuation, other)

julia&gt; str[endÃ·2]
&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>Using an index less than 1 or greater than <code>end</code> raises an error:</p><pre><code class="language-jldoctest">julia&gt; str[0]
ERROR: BoundsError: attempt to access &quot;Hello, world.\n&quot;
  at index [0]
[...]

julia&gt; str[end+1]
ERROR: BoundsError: attempt to access &quot;Hello, world.\n&quot;
  at index [15]
[...]</code></pre><p>You can also extract a substring using range indexing:</p><pre><code class="language-jldoctest">julia&gt; str[4:9]
&quot;lo, wo&quot;</code></pre><p>Notice that the expressions <code>str[k]</code> and <code>str[k:k]</code> do not give the same result:</p><pre><code class="language-jldoctest">julia&gt; str[6]
&#39;,&#39;: ASCII/Unicode U+002c (category Po: Punctuation, other)

julia&gt; str[6:6]
&quot;,&quot;</code></pre><p>The former is a single character value of type <code>Char</code>, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</p><h2><a class="nav-anchor" id="Unicode-and-UTF-8-1" href="#Unicode-and-UTF-8-1">Unicode and UTF-8</a></h2><p>Julia fully supports Unicode characters and strings. As <a href="#man-characters-1">discussed above</a>, in character literals, Unicode code points can be represented using Unicode <code>\u</code> and <code>\U</code> escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</p><pre><code class="language-jldoctest">julia&gt; s = &quot;\u2200 x \u2203 y&quot;
&quot;â x â y&quot;</code></pre><p>Whether these Unicode characters are displayed as escapes or shown as special characters depends on your terminal&#39;s locale settings and its support for Unicode. String literals are encoded using the UTF-8 encoding. UTF-8 is a variable-width encoding, meaning that not all characters are encoded in the same number of bytes. In UTF-8, ASCII characters â i.e. those with code points less than 0x80 (128) â are encoded as they are in ASCII, using a single byte, while code points 0x80 and above are encoded using multiple bytes â up to four per character. This means that not every byte index into a UTF-8 string is necessarily a valid index for a character. If you index into a string at such an invalid byte index, an error is thrown:</p><pre><code class="language-jldoctest">julia&gt; s[1]
&#39;â&#39;: Unicode U+2200 (category Sm: Symbol, math)

julia&gt; s[2]
ERROR: UnicodeError: invalid character index
[...]

julia&gt; s[3]
ERROR: UnicodeError: invalid character index
[...]

julia&gt; s[4]
&#39; &#39;: ASCII/Unicode U+0020 (category Zs: Separator, space)</code></pre><p>In this case, the character <code>â</code> is a three-byte character, so the indices 2 and 3 are invalid and the next character&#39;s index is 4; this next valid index can be computed by <a href="../../stdlib/strings/#Base.nextind"><code>nextind(s,1)</code></a>, and the next index after that by <code>nextind(s,4)</code> and so on.</p><p>Because of variable-length encodings, the number of characters in a string (given by <a href="../../stdlib/collections/#Base.length-Tuple{Any}"><code>length(s)</code></a>) is not always the same as the last index. If you iterate through the indices 1 through <a href="../../stdlib/collections/#Base.endof"><code>endof(s)</code></a> and index into <code>s</code>, the sequence of characters returned when errors aren&#39;t thrown is the sequence of characters comprising the string <code>s</code>. Thus we have the identity that <code>length(s) &lt;= endof(s)</code>, since each character in a string must have its own index. The following is an inefficient and verbose way to iterate through the characters of <code>s</code>:</p><pre><code class="language-jldoctest">julia&gt; for i = 1:endof(s)
           try
               println(s[i])
           catch
               # ignore the index error
           end
       end
â

x

â

y</code></pre><p>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</p><pre><code class="language-jldoctest">julia&gt; for c in s
           println(c)
       end
â

x

â

y</code></pre><p>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the <a href="https://github.com/JuliaArchive/LegacyStrings.jl">LegacyStrings.jl</a> package implements <code>UTF16String</code> and <code>UTF32String</code> types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on <a href="#man-byte-array-literals-1">byte array literals</a>. The <a href="../../stdlib/strings/#Base.transcode"><code>transcode()</code></a> function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</p><h2><a class="nav-anchor" id="Concatenation-1" href="#Concatenation-1">Concatenation</a></h2><p>One of the most common and useful string operations is concatenation:</p><pre><code class="language-jldoctest">julia&gt; greet = &quot;Hello&quot;
&quot;Hello&quot;

julia&gt; whom = &quot;world&quot;
&quot;world&quot;

julia&gt; string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)
&quot;Hello, world.\n&quot;</code></pre><p>Julia also provides <code>*</code> for string concatenation:</p><pre><code class="language-jldoctest">julia&gt; greet * &quot;, &quot; * whom * &quot;.\n&quot;
&quot;Hello, world.\n&quot;</code></pre><p>While <code>*</code> may seem like a surprising choice to users of languages that provide <code>+</code> for string concatenation, this use of <code>*</code> has precedent in mathematics, particularly in abstract algebra.</p><p>In mathematics, <code>+</code> usually denotes a <em>commutative</em> operation, where the order of the operands does not matter. An example of this is matrix addition, where <code>A + B == B + A</code> for any matrices <code>A</code> and <code>B</code> that have the same shape. In contrast, <code>*</code> typically denotes a <em>noncommutative</em> operation, where the order of the operands <em>does</em> matter. An example of this is matrix multiplication, where in general <code>A * B != B * A</code>. As with matrix multiplication, string concatenation is noncommutative: <code>greet * whom != whom * greet</code>. As such, <code>*</code> is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</p><p>More precisely, the set of all finite-length strings <em>S</em> together with the string concatenation operator <code>*</code> forms a <a href="https://en.wikipedia.org/wiki/Free_monoid">free monoid</a> (<em>S</em>, <code>*</code>). The identity element of this set is the empty string, <code>&quot;&quot;</code>. Whenever a free monoid is not commutative, the operation is typically represented as <code>\cdot</code>, <code>*</code>, or a similar symbol, rather than <code>+</code>, which as stated usually implies commutativity.</p><h2><a class="nav-anchor" id="string-interpolation-1" href="#string-interpolation-1">Interpolation</a></h2><p>Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to <a href="../../stdlib/strings/#Base.string"><code>string()</code></a> or repeated multiplications, Julia allows interpolation into string literals using <code>$</code>, as in Perl:</p><pre><code class="language-jldoctest">julia&gt; &quot;$greet, $whom.\n&quot;
&quot;Hello, world.\n&quot;</code></pre><p>This is more readable and convenient and equivalent to the above string concatenation â the system rewrites this apparent single string literal into a concatenation of string literals with variables.</p><p>The shortest complete expression after the <code>$</code> is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</p><pre><code class="language-julia-repl">julia&gt; &quot;1 + 2 = $(1 + 2)&quot;
&quot;1 + 2 = 3&quot;</code></pre><p>Both concatenation and string interpolation call <a href="../../stdlib/strings/#Base.string"><code>string()</code></a> to convert objects into string form. Most non-<code>AbstractString</code> objects are converted to strings closely corresponding to how they are entered as literal expressions:</p><pre><code class="language-julia-repl">julia&gt; v = [1,2,3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; &quot;v: $v&quot;
&quot;v: [1, 2, 3]&quot;</code></pre><p><a href="../../stdlib/strings/#Base.string"><code>string()</code></a> is the identity for <code>AbstractString</code> and <code>Char</code> values, so these are interpolated into strings as themselves, unquoted and unescaped:</p><pre><code class="language-julia-repl">julia&gt; c = &#39;x&#39;
&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)

julia&gt; &quot;hi, $c&quot;
&quot;hi, x&quot;</code></pre><p>To include a literal <code>$</code> in a string literal, escape it with a backslash:</p><pre><code class="language-julia-repl">julia&gt; print(&quot;I have \$100 in my account.\n&quot;)
I have $100 in my account.</code></pre><h2><a class="nav-anchor" id="Triple-Quoted-String-Literals-1" href="#Triple-Quoted-String-Literals-1">Triple-Quoted String Literals</a></h2><p>When strings are created using triple-quotes (<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>) they have some special behavior that can be useful for creating longer blocks of text. First, if the opening <code>&quot;&quot;&quot;</code> is followed by a newline, the newline is stripped from the resulting string.</p><pre><code class="language-julia">&quot;&quot;&quot;hello&quot;&quot;&quot;</code></pre><p>is equivalent to</p><pre><code class="language-julia">&quot;&quot;&quot;
hello&quot;&quot;&quot;</code></pre><p>but</p><pre><code class="language-julia">&quot;&quot;&quot;

hello&quot;&quot;&quot;</code></pre><p>will contain a literal newline at the beginning. Trailing whitespace is left unaltered. They can contain <code>&quot;</code> symbols without escaping. Triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</p><pre><code class="language-julia-repl">julia&gt; str = &quot;&quot;&quot;
           Hello,
           world.
         &quot;&quot;&quot;
&quot;  Hello,\n  world.\n&quot;</code></pre><p>In this case the final (empty) line before the closing <code>&quot;&quot;&quot;</code> sets the indentation level.</p><p>Note that line breaks in literal strings, whether single- or triple-quoted, result in a newline (LF) character <code>\n</code> in the string, even if your editor uses a carriage return <code>\r</code> (CR) or CRLF combination to end lines. To include a CR in a string, use an explicit escape <code>\r</code>; for example, you can enter the literal string <code>&quot;a CRLF line ending\r\n&quot;</code>.</p><h2><a class="nav-anchor" id="Common-Operations-1" href="#Common-Operations-1">Common Operations</a></h2><p>You can lexicographically compare strings using the standard comparison operators:</p><pre><code class="language-julia-repl">julia&gt; &quot;abracadabra&quot; &lt; &quot;xylophone&quot;
true

julia&gt; &quot;abracadabra&quot; == &quot;xylophone&quot;
false

julia&gt; &quot;Hello, world.&quot; != &quot;Goodbye, world.&quot;
true

julia&gt; &quot;1 + 2 = 3&quot; == &quot;1 + 2 = $(1 + 2)&quot;
true</code></pre><p>You can search for the index of a particular character using the <a href="../../stdlib/strings/#Base.search"><code>search()</code></a> function:</p><pre><code class="language-julia-repl">julia&gt; search(&quot;xylophone&quot;, &#39;x&#39;)
1

julia&gt; search(&quot;xylophone&quot;, &#39;p&#39;)
5

julia&gt; search(&quot;xylophone&quot;, &#39;z&#39;)
0</code></pre><p>You can start the search for a character at a given offset by providing a third argument:</p><pre><code class="language-julia-repl">julia&gt; search(&quot;xylophone&quot;, &#39;o&#39;)
4

julia&gt; search(&quot;xylophone&quot;, &#39;o&#39;, 5)
7

julia&gt; search(&quot;xylophone&quot;, &#39;o&#39;, 8)
0</code></pre><p>You can use the <a href="../../stdlib/arrays/#Base.contains-Tuple{Function,Any,Any}"><code>contains()</code></a> function to check if a substring is contained in a string:</p><pre><code class="language-julia-repl">julia&gt; contains(&quot;Hello, world.&quot;, &quot;world&quot;)
true

julia&gt; contains(&quot;Xylophon&quot;, &quot;o&quot;)
true

julia&gt; contains(&quot;Xylophon&quot;, &quot;a&quot;)
false

julia&gt; contains(&quot;Xylophon&quot;, &#39;o&#39;)
ERROR: MethodError: no method matching contains(::String, ::Char)
Closest candidates are:
  contains(!Matched::Function, ::Any, !Matched::Any) at reduce.jl:664
  contains(::AbstractString, !Matched::AbstractString) at strings/search.jl:378</code></pre><p>The last error is because <code>&#39;o&#39;</code> is a character literal, and <a href="../../stdlib/arrays/#Base.contains-Tuple{Function,Any,Any}"><code>contains()</code></a> is a generic function that looks for subsequences. To look for an element in a sequence, you must use <a href="../../stdlib/collections/#Base.in"><code>in()</code></a> instead.</p><p>Two other handy string functions are <a href="../../stdlib/linalg/#Base.repeat"><code>repeat()</code></a> and <a href="../../stdlib/strings/#Base.join"><code>join()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; repeat(&quot;.:Z:.&quot;, 10)
&quot;.:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.&quot;

julia&gt; join([&quot;apples&quot;, &quot;bananas&quot;, &quot;pineapples&quot;], &quot;, &quot;, &quot; and &quot;)
&quot;apples, bananas and pineapples&quot;</code></pre><p>Some other useful functions include:</p><ul><li><p><a href="../../stdlib/collections/#Base.endof"><code>endof(str)</code></a> gives the maximal (byte) index that can be used to index into <code>str</code>.</p></li><li><p><a href="../../stdlib/collections/#Base.length-Tuple{Any}"><code>length(str)</code></a> the number of characters in <code>str</code>.</p></li><li><p><a href="../../stdlib/collections/#Base.start"><code>i = start(str)</code></a> gives the first valid index at which a character can be found in <code>str</code> (typically 1).</p></li><li><p><a href="../../stdlib/collections/#Base.next"><code>c, j = next(str,i)</code></a> returns next character at or after the index <code>i</code> and the next valid character index following that. With <a href="../../stdlib/collections/#Base.start"><code>start()</code></a> and <a href="../../stdlib/collections/#Base.endof"><code>endof()</code></a>, can be used to iterate through the characters in <code>str</code>.</p></li><li><p><a href="../../stdlib/strings/#Base.ind2chr"><code>ind2chr(str,i)</code></a> gives the number of characters in <code>str</code> up to and including any at index <code>i</code>.</p></li><li><p><a href="../../stdlib/strings/#Base.chr2ind"><code>chr2ind(str,j)</code></a> gives the index at which the <code>j</code>th character in <code>str</code> occurs.</p></li></ul><h2><a class="nav-anchor" id="non-standard-string-literals-1" href="#non-standard-string-literals-1">Non-Standard String Literals</a></h2><p>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides <a href="#non-standard-string-literals-1">non-standard string literals</a>. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn&#39;t behave quite like a normal string literal.  Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the <a href="../metaprogramming/#Metaprogramming-1">Metaprogramming</a> section.</p><h2><a class="nav-anchor" id="Regular-Expressions-1" href="#Regular-Expressions-1">Regular Expressions</a></h2><p>Julia has Perl-compatible regular expressions (regexes), as provided by the <a href="http://www.pcre.org/">PCRE</a> library. Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with <code>r</code>. The most basic regular expression literal without any options turned on just uses <code>r&quot;...&quot;</code>:</p><pre><code class="language-julia-repl">julia&gt; r&quot;^\s*(?:#|$)&quot;
r&quot;^\s*(?:#|$)&quot;

julia&gt; typeof(ans)
Regex</code></pre><p>To check if a regex matches a string, use <a href="../../stdlib/strings/#Base.ismatch"><code>ismatch()</code></a>:</p><pre><code class="language-julia-repl">julia&gt; ismatch(r&quot;^\s*(?:#|$)&quot;, &quot;not a comment&quot;)
false

julia&gt; ismatch(r&quot;^\s*(?:#|$)&quot;, &quot;# a comment&quot;)
true</code></pre><p>As one can see here, <a href="../../stdlib/strings/#Base.ismatch"><code>ismatch()</code></a> simply returns true or false, indicating whether the given regex matches the string or not. Commonly, however, one wants to know not just whether a string matched, but also <em>how</em> it matched. To capture this information about a match, use the <a href="../../stdlib/strings/#Base.match"><code>match()</code></a> function instead:</p><pre><code class="language-julia-repl">julia&gt; match(r&quot;^\s*(?:#|$)&quot;, &quot;not a comment&quot;)

julia&gt; match(r&quot;^\s*(?:#|$)&quot;, &quot;# a comment&quot;)
RegexMatch(&quot;#&quot;)</code></pre><p>If the regular expression does not match the given string, <a href="../../stdlib/strings/#Base.match"><code>match()</code></a> returns <code>nothing</code> â a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</p><pre><code class="language-julia">m = match(r&quot;^\s*(?:#|$)&quot;, line)
if m === nothing
    println(&quot;not a comment&quot;)
else
    println(&quot;blank or comment&quot;)
end</code></pre><p>If a regular expression does match, the value returned by <a href="../../stdlib/strings/#Base.match"><code>match()</code></a> is a <code>RegexMatch</code> object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</p><pre><code class="language-julia-repl">julia&gt; m = match(r&quot;^\s*(?:#\s*(.*?)\s*$|$)&quot;, &quot;# a comment &quot;)
RegexMatch(&quot;# a comment &quot;, 1=&quot;a comment&quot;)</code></pre><p>When calling <a href="../../stdlib/strings/#Base.match"><code>match()</code></a>, you have the option to specify an index at which to start the search. For example:</p><pre><code class="language-julia-repl">julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,1)
RegexMatch(&quot;1&quot;)

julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,6)
RegexMatch(&quot;2&quot;)

julia&gt; m = match(r&quot;[0-9]&quot;,&quot;aaaa1aaaa2aaaa3&quot;,11)
RegexMatch(&quot;3&quot;)</code></pre><p>You can extract the following info from a <code>RegexMatch</code> object:</p><ul><li><p>the entire substring matched: <code>m.match</code></p></li><li><p>the captured substrings as an array of strings: <code>m.captures</code></p></li><li><p>the offset at which the whole match begins: <code>m.offset</code></p></li><li><p>the offsets of the captured substrings as a vector: <code>m.offsets</code></p></li></ul><p>For when a capture doesn&#39;t match, instead of a substring, <code>m.captures</code> contains <code>nothing</code> in that position, and <code>m.offsets</code> has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</p><pre><code class="language-jldoctest">julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;acd&quot;)
RegexMatch(&quot;acd&quot;, 1=&quot;a&quot;, 2=&quot;c&quot;, 3=&quot;d&quot;)

julia&gt; m.match
&quot;acd&quot;

julia&gt; m.captures
3-element Array{Union{SubString{String}, Void},1}:
 &quot;a&quot;
 &quot;c&quot;
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; m = match(r&quot;(a|b)(c)?(d)&quot;, &quot;ad&quot;)
RegexMatch(&quot;ad&quot;, 1=&quot;a&quot;, 2=nothing, 3=&quot;d&quot;)

julia&gt; m.match
&quot;ad&quot;

julia&gt; m.captures
3-element Array{Union{SubString{String}, Void},1}:
 &quot;a&quot;
 nothing
 &quot;d&quot;

julia&gt; m.offset
1

julia&gt; m.offsets
3-element Array{Int64,1}:
 1
 0
 2</code></pre><p>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</p><pre><code class="language-jldoctest">julia&gt; first, second, third = m.captures; first
&quot;a&quot;</code></pre><p>Captures can also be accessed by indexing the <code>RegexMatch</code> object with the number or name of the capture group:</p><pre><code class="language-julia-repl">julia&gt; m=match(r&quot;(?&lt;hour&gt;\d+):(?&lt;minute&gt;\d+)&quot;,&quot;12:45&quot;)
RegexMatch(&quot;12:45&quot;, hour=&quot;12&quot;, minute=&quot;45&quot;)

julia&gt; m[:minute]
&quot;45&quot;

julia&gt; m[2]
&quot;45&quot;</code></pre><p>Captures can be referenced in a substitution string when using <a href="../../stdlib/strings/#Base.replace"><code>replace()</code></a> by using <code>\n</code> to refer to the nth capture group and prefixing the substitution string with <code>s</code>. Capture group 0 refers to the entire match object. Named capture groups can be referenced in the substitution with <code>g&lt;groupname&gt;</code>. For example:</p><pre><code class="language-julia-repl">julia&gt; replace(&quot;first second&quot;, r&quot;(\w+) (?&lt;agroup&gt;\w+)&quot;, s&quot;\g&lt;agroup&gt; \1&quot;)
&quot;second first&quot;</code></pre><p>Numbered capture groups can also be referenced as <code>\g&lt;n&gt;</code> for disambiguation, as in:</p><pre><code class="language-julia-repl">julia&gt; replace(&quot;a&quot;, r&quot;.&quot;, s&quot;\g&lt;0&gt;1&quot;)
&quot;a1&quot;</code></pre><p>You can modify the behavior of regular expressions by some combination of the flags <code>i</code>, <code>m</code>, <code>s</code>, and <code>x</code> after the closing double quote mark. These flags have the same meaning as they do in Perl, as explained in this excerpt from the <a href="http://perldoc.perl.org/perlre.html#Modifiers">perlre manpage</a>:</p><pre><code class="language-none">i   Do case-insensitive pattern matching.

    If locale matching rules are in effect, the case map is taken
    from the current locale for code points less than 255, and
    from Unicode rules for larger code points. However, matches
    that would cross the Unicode rules/non-Unicode rules boundary
    (ords 255/256) will not succeed.

m   Treat string as multiple lines.  That is, change &quot;^&quot; and &quot;$&quot;
    from matching the start or end of the string to matching the
    start or end of any line anywhere within the string.

s   Treat string as single line.  That is, change &quot;.&quot; to match any
    character whatsoever, even a newline, which normally it would
    not match.

    Used together, as r&quot;&quot;ms, they let the &quot;.&quot; match any character
    whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match,
    respectively, just after and just before newlines within the
    string.

x   Tells the regular expression parser to ignore most whitespace
    that is neither backslashed nor within a character class. You
    can use this to break up your regular expression into
    (slightly) more readable parts. The &#39;#&#39; character is also
    treated as a metacharacter introducing a comment, just as in
    ordinary code.</code></pre><p>For example, the following regex has all three flags turned on:</p><pre><code class="language-julia-repl">julia&gt; r&quot;a+.*b+.*?d$&quot;ism
r&quot;a+.*b+.*?d$&quot;ims

julia&gt; match(r&quot;a+.*b+.*?d$&quot;ism, &quot;Goodbye,\nOh, angry,\nBad world\n&quot;)
RegexMatch(&quot;angry,\nBad world&quot;)</code></pre><p>Triple-quoted regex strings, of the form <code>r&quot;&quot;&quot;...&quot;&quot;&quot;</code>, are also supported (and may be convenient for regular expressions containing quotation marks or newlines).</p><h2><a class="nav-anchor" id="man-byte-array-literals-1" href="#man-byte-array-literals-1">Byte Array Literals</a></h2><p>Another useful non-standard string literal is the byte-array string literal: <code>b&quot;...&quot;</code>. This form lets you use string notation to express literal byte arrays â i.e. arrays of <a href="../../stdlib/numbers/#Core.UInt8"><code>UInt8</code></a> values. The rules for byte array literals are the following:</p><ul><li><p>ASCII characters and ASCII escapes produce a single byte.</p></li><li><p><code>\x</code> and octal escape sequences produce the <em>byte</em> corresponding to the escape value.</p></li><li><p>Unicode escape sequences produce a sequence of bytes encoding that code point in UTF-8.</p></li></ul><p>There is some overlap between these rules since the behavior of <code>\x</code> and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</p><pre><code class="language-julia-repl">julia&gt; b&quot;DATA\xff\u2200&quot;
8-element Array{UInt8,1}:
 0x44
 0x41
 0x54
 0x41
 0xff
 0xe2
 0x88
 0x80</code></pre><p>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. <code>\xff</code> produces the single byte 255. The Unicode escape <code>\u2200</code> is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string â if you try to use this as a regular string literal, you will get a syntax error:</p><pre><code class="language-julia-repl">julia&gt; &quot;DATA\xff\u2200&quot;
ERROR: syntax: invalid UTF-8 sequence</code></pre><p>Also observe the significant distinction between <code>\xff</code> and <code>\uff</code>: the former escape sequence encodes the <em>byte 255</em>, whereas the latter escape sequence represents the <em>code point 255</em>, which is encoded as two bytes in UTF-8:</p><pre><code class="language-julia-repl">julia&gt; b&quot;\xff&quot;
1-element Array{UInt8,1}:
 0xff

julia&gt; b&quot;\uff&quot;
2-element Array{UInt8,1}:
 0xc3
 0xbf</code></pre><p>In character literals, this distinction is glossed over and <code>\xff</code> is allowed to represent the code point 255, because characters <em>always</em> represent code points. In strings, however, <code>\x</code> escapes always represent bytes, not code points, whereas <code>\u</code> and <code>\U</code> escapes always represent code points, which are encoded in one or more bytes. For code points less than <code>\u80</code>, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding <code>\x</code> escape, so the distinction can safely be ignored. For the escapes <code>\x80</code> through <code>\xff</code> as compared to <code>\u80</code> through <code>\uff</code>, however, there is a major difference: the former escapes all encode single bytes, which â unless followed by very specific continuation bytes â do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</p><p>If this is all extremely confusing, try reading <a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;</a>. It&#39;s an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</p><h2><a class="nav-anchor" id="man-version-number-literals-1" href="#man-version-number-literals-1">Version Number Literals</a></h2><p>Version numbers can easily be expressed with non-standard string literals of the form <code>v&quot;...&quot;</code>. Version number literals create <code>VersionNumber</code> objects which follow the specifications of <a href="http://semver.org">semantic versioning</a>, and therefore are composed of major, minor and patch numeric values, followed by pre-release and build alpha-numeric annotations. For example, <code>v&quot;0.2.1-rc1+win64&quot;</code> is broken into major version <code>0</code>, minor version <code>2</code>, patch version <code>1</code>, pre-release <code>rc1</code> and build <code>win64</code>. When entering a version literal, everything except the major version number is optional, therefore e.g.  <code>v&quot;0.2&quot;</code> is equivalent to <code>v&quot;0.2.0&quot;</code> (with empty pre-release/build annotations), <code>v&quot;2&quot;</code> is equivalent to <code>v&quot;2.0.0&quot;</code>, and so on.</p><p><code>VersionNumber</code> objects are mostly useful to easily and correctly compare two (or more) versions. For example, the constant <code>VERSION</code> holds Julia version number as a <code>VersionNumber</code> object, and therefore one can define some version-specific behavior using simple statements as:</p><pre><code class="language-julia">if v&quot;0.2&quot; &lt;= VERSION &lt; v&quot;0.3-&quot;
    # do something specific to 0.2 release series
end</code></pre><p>Note that in the above example the non-standard version number <code>v&quot;0.3-&quot;</code> is used, with a trailing <code>-</code>: this notation is a Julia extension of the standard, and it&#39;s used to indicate a version which is lower than any <code>0.3</code> release, including all of its pre-releases. So in the above example the code would only run with stable <code>0.2</code> versions, and exclude such versions as <code>v&quot;0.3.0-rc1&quot;</code>. In order to also allow for unstable (i.e. pre-release) <code>0.2</code> versions, the lower bound check should be modified like this: <code>v&quot;0.2-&quot; &lt;= VERSION</code>.</p><p>Another non-standard version specification extension allows one to use a trailing <code>+</code> to express an upper limit on build versions, e.g.  <code>VERSION &gt; v&quot;0.2-rc1+&quot;</code> can be used to mean any version above <code>0.2-rc1</code> and any of its builds: it will return <code>false</code> for version <code>v&quot;0.2-rc1+win64&quot;</code> and <code>true</code> for <code>v&quot;0.2-rc2&quot;</code>.</p><p>It is good practice to use such special versions in comparisons (particularly, the trailing <code>-</code> should always be used on upper bounds unless there&#39;s a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</p><p>Besides being used for the <a href="../../stdlib/constants/#Base.VERSION"><code>VERSION</code></a> constant, <code>VersionNumber</code> objects are widely used in the <code>Pkg</code> module, to specify packages versions and their dependencies.</p><h2><a class="nav-anchor" id="man-raw-string-literals-1" href="#man-raw-string-literals-1">Raw String Literals</a></h2><p>Raw strings without interpolation or unescaping can be expressed with non-standard string literals of the form <code>raw&quot;...&quot;</code>. Raw string literals create ordinary <code>String</code> objects which contain the enclosed contents exactly as entered with no interpolation or unescaping. This is useful for strings which contain code or markup in other languages which use <code>$</code> or <code>\</code> as special characters. The exception is quotation marks that still must be escaped, e.g. <code>raw&quot;\&quot;&quot;</code> is equivalent to <code>&quot;\&quot;&quot;</code>.</p><footer><hr/><a class="previous" href="../complex-and-rational-numbers/"><span class="direction">Previous</span><span class="title">Complex and Rational Numbers</span></a><a class="next" href="../functions/"><span class="direction">Next</span><span class="title">Functions</span></a></footer></article></body></html>
