<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia Functions Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname+location.search+location.hash});
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/introduction.html">Introduction</a></li><li><a class="toctext" href="../manual/getting-started.html">Getting Started</a></li><li><a class="toctext" href="../manual/variables.html">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings.html">Strings</a></li><li><a class="toctext" href="../manual/functions.html">Functions</a></li><li><a class="toctext" href="../manual/control-flow.html">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="toctext" href="../manual/types.html">Types</a></li><li><a class="toctext" href="../manual/methods.html">Methods</a></li><li><a class="toctext" href="../manual/constructors.html">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces.html">Interfaces</a></li><li><a class="toctext" href="../manual/modules.html">Modules</a></li><li><a class="toctext" href="../manual/documentation.html">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/linear-algebra.html">Linear algebra</a></li><li><a class="toctext" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="toctext" href="../manual/dates.html">Date and DateTime</a></li><li><a class="toctext" href="../manual/interacting-with-julia.html">Interacting With Julia</a></li><li><a class="toctext" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="toctext" href="../manual/packages.html">Packages</a></li><li><a class="toctext" href="../manual/profile.html">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide.html">Style Guide</a></li><li><a class="toctext" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/base.html">Essentials</a></li><li><a class="toctext" href="../stdlib/collections.html">Collections and Data Structures</a></li><li><a class="toctext" href="../stdlib/math.html">Mathematics</a></li><li><a class="toctext" href="../stdlib/numbers.html">Numbers</a></li><li><a class="toctext" href="../stdlib/strings.html">Strings</a></li><li><a class="toctext" href="../stdlib/arrays.html">Arrays</a></li><li><a class="toctext" href="../stdlib/parallel.html">Tasks and Parallel Computing</a></li><li><a class="toctext" href="../stdlib/linalg.html">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/constants.html">Constants</a></li><li><a class="toctext" href="../stdlib/file.html">Filesystem</a></li><li><a class="toctext" href="../stdlib/io-network.html">I/O and Network</a></li><li><a class="toctext" href="../stdlib/punctuation.html">Punctuation</a></li><li><a class="toctext" href="../stdlib/sort.html">Sorting and Related Functions</a></li><li><a class="toctext" href="../stdlib/pkg.html">Package Manager Functions</a></li><li><a class="toctext" href="../stdlib/dates.html">Dates and Time</a></li><li><a class="toctext" href="../stdlib/iterators.html">Iteration utilities</a></li><li><a class="toctext" href="../stdlib/test.html">Unit Testing</a></li><li><a class="toctext" href="../stdlib/c.html">C Interface</a></li><li><a class="toctext" href="../stdlib/libc.html">C Standard Library</a></li><li><a class="toctext" href="../stdlib/libdl.html">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/profile.html">Profiling</a></li><li><a class="toctext" href="../stdlib/stacktraces.html">StackTraces</a></li><li><a class="toctext" href="../stdlib/simd-types.html">SIMD Support</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="reflection.html">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="init.html">Initialization of the Julia runtime</a></li><li><a class="toctext" href="ast.html">Julia ASTs</a></li><li><a class="toctext" href="types.html">More about types</a></li><li><a class="toctext" href="object.html">Memory layout of Julia Objects</a></li><li><a class="toctext" href="eval.html">Eval of Julia code</a></li><li><a class="toctext" href="callconv.html">Calling Conventions</a></li><li><a class="toctext" href="compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li class="current"><a class="toctext" href="functions.html">Julia Functions</a><ul class="internal"><li><a class="toctext" href="#Method-Tables-1">Method Tables</a></li><li><a class="toctext" href="#Function-calls-1">Function calls</a></li><li><a class="toctext" href="#Adding-methods-1">Adding methods</a></li><li><a class="toctext" href="#Creating-generic-functions-1">Creating generic functions</a></li><li><a class="toctext" href="#Closures-1">Closures</a></li><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Builtins-1">Builtins</a></li><li><a class="toctext" href="#Keyword-arguments-1">Keyword arguments</a></li><li><a class="toctext" href="#Compiler-efficiency-issues-1">Compiler efficiency issues</a></li></ul></li><li><a class="toctext" href="cartesian.html">Base.Cartesian</a></li><li><a class="toctext" href="meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="subarrays.html">SubArrays</a></li><li><a class="toctext" href="sysimg.html">System Image Building</a></li><li><a class="toctext" href="llvm.html">Working with LLVM</a></li><li><a class="toctext" href="stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="boundscheck.html">Bounds checking</a></li><li><a class="toctext" href="locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="offset-arrays.html">Arrays with custom indices</a></li><li><a class="toctext" href="libgit2.html">Base.LibGit2</a></li><li><a class="toctext" href="require.html">Module loading</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="debuggingtips.html">gdb debugging tips</a></li><li><a class="toctext" href="valgrind.html">Using Valgrind with Julia</a></li><li><a class="toctext" href="sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li>Documentation of Julia&#39;s Internals</li><li><a href="functions.html">Julia Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/tree/0d7248e2ff65bd6886ba3f003bf5aeab929edab5/doc/src/devdocs/functions.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Julia Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Julia-Functions-1" href="#Julia-Functions-1">Julia Functions</a></h1><p>This document will explain how functions, method definitions, and method tables work.</p><h2><a class="nav-anchor" id="Method-Tables-1" href="#Method-Tables-1">Method Tables</a></h2><p>Every function in Julia is a generic function. A generic function is conceptually a single function, but consists of many definitions, or methods. The methods of a generic function are stored in a method table. Method tables (type <code>MethodTable</code>) are associated with <code>TypeName</code>s. A <code>TypeName</code> describes a family of parameterized types. For example <code>Complex{Float32}</code> and <code>Complex{Float64}</code> share the same <code>Complex</code> type name object.</p><p>All objects in Julia are potentially callable, because every object has a type, which in turn has a <code>TypeName</code>.</p><h2><a class="nav-anchor" id="Function-calls-1" href="#Function-calls-1">Function calls</a></h2><p>Given the call <code>f(x,y)</code>, the following steps are performed: first, the method table to use is accessed as <code>typeof(f).name.mt</code>. Second, an argument tuple type is formed, <code>Tuple{typeof(f), typeof(x), typeof(y)}</code>. Note that the type of the function itself is the first element. This is because the type might have parameters, and so needs to take part in dispatch. This tuple type is looked up in the method table.</p><p>This dispatch process is performed by <code>jl_apply_generic</code>, which takes two arguments: a pointer to an array of the values f, x, and y, and the number of values (in this case 3).</p><p>Throughout the system, there are two kinds of APIs that handle functions and argument lists: those that accept the function and arguments separately, and those that accept a single argument structure. In the first kind of API, the &quot;arguments&quot; part does <em>not</em> contain information about the function, since that is passed separately. In the second kind of API, the function is the first element of the argument structure.</p><p>For example, the following function for performing a call accepts just an <code>args</code> pointer, so the first element of the args array will be the function to call:</p><pre><code class="language-c">jl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)</code></pre><p>This entry point for the same functionality accepts the function separately, so the <code>args</code> array does not contain the function:</p><pre><code class="language-c">jl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);</code></pre><h2><a class="nav-anchor" id="Adding-methods-1" href="#Adding-methods-1">Adding methods</a></h2><p>Given the above dispatch process, conceptually all that is needed to add a new method is (1) a tuple type, and (2) code for the body of the method. <code>jl_method_def</code> implements this operation. <code>jl_first_argument_datatype</code> is called to extract the relevant method table from what would be the type of the first argument. This is much more complicated than the corresponding procedure during dispatch, since the argument tuple type might be abstract. For example, we can define:</p><pre><code class="language-julia">(::Union{Foo{Int},Foo{Int8}})(x) = 0</code></pre><p>which works since all possible matching methods would belong to the same method table.</p><h2><a class="nav-anchor" id="Creating-generic-functions-1" href="#Creating-generic-functions-1">Creating generic functions</a></h2><p>Since every object is callable, nothing special is needed to create a generic function. Therefore <code>jl_new_generic_function</code> simply creates a new singleton (0 size) subtype of <code>Function</code> and returns its instance. A function can have a mnemonic &quot;display name&quot; which is used in debug info and when printing objects. For example the name of <code>Base.sin</code> is <code>sin</code>. By convention, the name of the created <em>type</em> is the same as the function name, with a <code>#</code> prepended. So <code>typeof(sin)</code> is <code>Base.#sin</code>.</p><h2><a class="nav-anchor" id="Closures-1" href="#Closures-1">Closures</a></h2><p>A closure is simply a callable object with field names corresponding to captured variables. For example, the following code:</p><pre><code class="language-julia">function adder(x)
    return y-&gt;x+y
end</code></pre><p>is lowered to (roughly):</p><pre><code class="language-julia">struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end</code></pre><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><p>A constructor call is just a call to a type. The type of most types is <code>DataType</code>, so the method table for <code>DataType</code> contains most constructor definitions. One wrinkle is the fallback definition that makes all types callable via <code>convert</code>:</p><pre><code class="language-julia">(::Type{T}){T}(args...) = convert(T, args...)::T</code></pre><p>In this definition the function type is abstract, which is not normally supported. To make this work, all subtypes of <code>Type</code> (<code>Type</code>, <code>UnionAll</code>, <code>Union</code>, and <code>DataType</code>) currently share a method table via special arrangement.</p><h2><a class="nav-anchor" id="Builtins-1" href="#Builtins-1">Builtins</a></h2><p>The &quot;builtin&quot; functions, defined in the <code>Core</code> module, are:</p><pre><code class="language-none">=== typeof sizeof issubtype isa typeassert throw tuple getfield setfield! fieldtype
nfields isdefined arrayref arrayset arraysize applicable invoke apply_type _apply
_expr svec</code></pre><p>These are all singleton objects whose types are subtypes of <code>Builtin</code>, which is a subtype of <code>Function</code>. Their purpose is to expose entry points in the run time that use the &quot;jlcall&quot; calling convention:</p><pre><code class="language-c">jl_value_t *(jl_value_t*, jl_value_t**, uint32_t)</code></pre><p>The method tables of builtins are empty. Instead, they have a single catch-all method cache entry (<code>Tuple{Vararg{Any}}</code>) whose jlcall fptr points to the correct function. This is kind of a hack but works reasonably well.</p><h2><a class="nav-anchor" id="Keyword-arguments-1" href="#Keyword-arguments-1">Keyword arguments</a></h2><p>Keyword arguments work by associating a special, hidden function object with each method table that has definitions with keyword arguments. This function is called the &quot;keyword argument sorter&quot; or &quot;keyword sorter&quot;, or &quot;kwsorter&quot;, and is stored in the <code>kwsorter</code> field of <code>MethodTable</code> objects. Every definition in the kwsorter function has the same arguments as some definition in the normal method table, except with a single <code>Array</code> argument prepended. This array contains alternating symbols and values that represent the passed keyword arguments. The kwsorter&#39;s job is to move keyword arguments into their canonical positions based on name, plus evaluate and substite any needed default value expressions. The result is a normal positional argument list, which is then passed to yet another function.</p><p>The easiest way to understand the process is to look at how a keyword argument method definition is lowered. The code:</p><pre><code class="language-julia">function circle(center, radius; color = black, fill::Bool = true, options...)
    # draw
end</code></pre><p>actually produces <em>three</em> method definitions. The first is a function that accepts all arguments (including keywords) as positional arguments, and includes the code for the method body. It has an auto-generated name:</p><pre><code class="language-julia">function #circle#1(color, fill::Bool, options, circle, center, radius)
    # draw
end</code></pre><p>The second method is an ordinary definition for the original <code>circle</code> function, which handles the case where no keyword arguments are passed:</p><pre><code class="language-julia">function circle(center, radius)
    #circle#1(black, true, Any[], circle, center, radius)
end</code></pre><p>This simply dispatches to the first method, passing along default values. Finally there is the kwsorter definition:</p><pre><code class="language-none">function (::Core.kwftype(typeof(circle)))(kw::Array, circle, center, radius)
    options = Any[]
    color = arg associated with :color, or black if not found
    fill = arg associated with :fill, or true if not found
    # push remaining elements of kw into options array
    #circle#1(color, fill, options, circle, center, radius)
end</code></pre><p>The front end generates code to loop over the <code>kw</code> array and pick out arguments in the right order, evaluating default expressions when an argument is not found.</p><p>The function <code>Core.kwftype(t)</code> fetches (and creates, if necessary) the field <code>t.name.mt.kwsorter</code>.</p><p>This design has the feature that call sites that don&#39;t use keyword arguments require no special handling; everything works as if they were not part of the language at all. Call sites that do use keyword arguments are dispatched directly to the called function&#39;s kwsorter. For example the call:</p><pre><code class="language-julia">circle((0,0), 1.0, color = red; other...)</code></pre><p>is lowered to:</p><pre><code class="language-julia">kwfunc(circle)(Any[:color,red,other...], circle, (0,0), 1.0)</code></pre><p>The unpacking procedure represented here as <code>other...</code> actually further unpacks each <em>element</em> of <code>other</code>, expecting each one to contain two values (a symbol and a value). <code>kwfunc</code> (also in <code>Core</code>) fetches the kwsorter for the called function. Notice that the original <code>circle</code> function is passed through, to handle closures.</p><h2><a class="nav-anchor" id="Compiler-efficiency-issues-1" href="#Compiler-efficiency-issues-1">Compiler efficiency issues</a></h2><p>Generating a new type for every function has potentially serious consequences for compiler resource use when combined with Julia&#39;s &quot;specialize on all arguments by default&quot; design. Indeed, the initial implementation of this design suffered from much longer build and test times, higher memory use, and a system image nearly 2x larger than the baseline. In a naive implementation, the problem is bad enough to make the system nearly unusable. Several significant optimizations were needed to make the design practical.</p><p>The first issue is excessive specialization of functions for different values of function-valued arguments. Many functions simply &quot;pass through&quot; an argument to somewhere else, e.g. to another function or to a storage location. Such functions do not need to be specialized for every closure that might be passed in. Fortunately this case is easy to distinguish by simply considering whether a function <em>calls</em> one of its arguments (i.e. the argument appears in &quot;head position&quot; somewhere). Performance-critical higher-order functions like <code>map</code> certainly call their argument function and so will still be specialized as expected. This optimization is implemented by recording which arguments are called during the <code>analyze-variables</code> pass in the front end. When <code>cache_method</code> sees an argument in the <code>Function</code> type hierarchy passed to a slot declared as <code>Any</code> or <code>Function</code>, it pretends the slot was declared as <code>ANY</code> (the &quot;don&#39;t specialize&quot; hint). This heuristic seems to be extremely effective in practice.</p><p>The next issue concerns the structure of method cache hash tables. Empirical studies show that the vast majority of dynamically-dispatched calls involve one or two arguments. In turn, many of these cases can be resolved by considering only the first argument. (Aside: proponents of single dispatch would not be surprised by this at all. However, this argument means &quot;multiple dispatch is easy to optimize in practice&quot;, and that we should therefore use it, <em>not</em> &quot;we should use single dispatch&quot;!) So the method cache uses the type of the first argument as its primary key. Note, however, that this corresponds to the <em>second</em> element of the tuple type for a function call (the first element being the type of the function itself). Typically, type variation in head position is extremely low â indeed, the majority of functions belong to singleton types with no parameters. However, this is not the case for constructors, where a single method table holds constructors for every type. Therefore the <code>Type</code> method table is special-cased to use the <em>first</em> tuple type element instead of the second.</p><p>The front end generates type declarations for all closures. Initially, this was implemented by generating normal type declarations. However, this produced an extremely large number of constructors, all of which were trivial (simply passing all arguments through to <code>new</code>). Since methods are partially ordered, inserting all of these methods is O(n^2), plus there are just too many of them to keep around. This was optimized by generating <code>composite_type</code> expressions directly (bypassing default constructor generation), and using <code>new</code> directly to create closure instances. Not the prettiest thing ever, but you do what you gotta do.</p><p>The next problem was the <code>@test</code> macro, which generated a 0-argument closure for each test case. This is not really necessary, since each test case is simply run once in place. Therefore I modified <code>@test</code> to expand to a try-catch block that records the test result (true, false, or exception raised) and calls the test suite handler on it.</p><p>However this caused a new problem. When many tests are grouped together in a single function, e.g. a single top level expression, or some other test grouping function, that function could have a very large number of exception handlers. This triggered a kind of dataflow analysis worst case, where type inference spun around for minutes enumerating possible paths through the forest of handlers. This was fixed by simply bailing out of type inference when it encounters more than some number of handlers (currently 25). Presumably no performance-critical function will have more than 25 exception handlers. If one ever does, I&#39;m willing to raise the limit to 26.</p><p>A minor issue occurs during the bootstrap process due to storing all constructors in a single method table. In the second bootstrap step, where <code>inference.ji</code> is compiled using <code>inference0.ji</code>, constructors for <code>inference0</code>&#39;s types remain in the table, so there are still references to the old inference module and <code>inference.ji</code> is 2x the size it should be. This was fixed in <code>dump.c</code> by filtering definitions from &quot;replaced modules&quot; out of method tables and caches before saving a system image. A &quot;replaced module&quot; is one that satisfies the condition <code>m != jl_get_global(m-&gt;parent, m-&gt;name)</code> â in other words, some newer module has taken its name and place.</p><p>Another type inference worst case was triggered by the following code from the <a href="https://github.com/JuliaMath/QuadGK.jl">QuadGK.jl package</a>, formerly part of Base:</p><pre><code class="language-julia">function do_quadgk(f, s, n, ::Type{Tw}, abstol, reltol, maxevals, nrm) where Tw
    if eltype(s) &lt;: Real # check for infinite or semi-infinite intervals
        s1 = s[1]; s2 = s[end]; inf1 = isinf(s1); inf2 = isinf(s2)
        if inf1 || inf2
            if inf1 &amp;&amp; inf2 # x = t/(1-t^2) coordinate transformation
                return do_quadgk(t -&gt; begin t2 = t*t; den = 1 / (1 - t2);
                                            f(t*den) * (1+t2)*den*den; end,
                                 map(x -&gt; isinf(x) ? copysign(one(x), x) : 2x / (1+hypot(1,2x)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
            s0,si = inf1 ? (s2,s1) : (s1,s2)
            if si &lt; 0 # x = s0 - t/(1-t)
                return do_quadgk(t -&gt; begin den = 1 / (1 - t);
                                            f(s0 - t*den) * den*den; end,
                                 reverse!(map(x -&gt; 1 / (1 + 1 / (s0 - x)), s)),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            else # x = s0 + t/(1-t)
                return do_quadgk(t -&gt; begin den = 1 / (1 - t);
                                            f(s0 + t*den) * den*den; end,
                                 map(x -&gt; 1 / (1 + 1 / (x - s0)), s),
                                 n, Tw, abstol, reltol, maxevals, nrm)
            end
        end
    end</code></pre><p>This code has a 3-way tail recursion, where each call wraps the current function argument <code>f</code> in a different new closure. Inference must consider 3^n (where n is the call depth) possible signatures. This blows up way too quickly, so logic was added to <code>typeinf_uncached</code> to immediately widen any argument that is a subtype of <code>Function</code> and that grows in depth down the stack.</p><footer><hr/><a class="previous" href="compiler.html"><span class="direction">Previous</span><span class="title">High-level Overview of the Native-Code Generation Process</span></a><a class="next" href="cartesian.html"><span class="direction">Next</span><span class="title">Base.Cartesian</span></a></footer></article></body></html>
