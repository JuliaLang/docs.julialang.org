<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Tasks Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://docs.julialang.org/en/v1/base/parallel/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="The Julia Language logo" class="docs-light-only" src="../../assets/logo.svg"/><img alt="The Julia Language logo" class="docs-dark-only" src="../../assets/logo-dark.svg"/></a><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../../manual/strings/">Strings</a></li><li><a class="tocitem" href="../../manual/functions/">Functions</a></li><li><a class="tocitem" href="../../manual/control-flow/">Control Flow</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../../manual/types/">Types</a></li><li><a class="tocitem" href="../../manual/methods/">Methods</a></li><li><a class="tocitem" href="../../manual/constructors/">Constructors</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../../manual/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../../manual/modules/">Modules</a></li><li><a class="tocitem" href="../../manual/documentation/">Documentation</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="../../manual/missing/">Missing Values</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../../manual/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="tocitem" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">Code Loading</a></li><li><a class="tocitem" href="../../manual/profile/">Profiling</a></li><li><a class="tocitem" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../../manual/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode Input</a></li><li><a class="tocitem" href="../../manual/command-line-options/">Command-line Options</a></li></ul></li><li><input checked="" class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/">Essentials</a></li><li><a class="tocitem" href="../collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../math/">Mathematics</a></li><li><a class="tocitem" href="../numbers/">Numbers</a></li><li><a class="tocitem" href="../strings/">Strings</a></li><li><a class="tocitem" href="../arrays/">Arrays</a></li><li class="is-active"><a class="tocitem" href="">Tasks</a><ul class="internal"><li><a class="tocitem" href="#Scheduling"><span>Scheduling</span></a></li><li><a class="tocitem" href="#lib-task-sync"><span>Synchronization</span></a></li><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li></ul></li><li><a class="tocitem" href="../multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../constants/">Constants</a></li><li><a class="tocitem" href="../file/">Filesystem</a></li><li><a class="tocitem" href="../io-network/">I/O and Network</a></li><li><a class="tocitem" href="../punctuation/">Punctuation</a></li><li><a class="tocitem" href="../sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../c/">C Interface</a></li><li><a class="tocitem" href="../libc/">C Standard Library</a></li><li><a class="tocitem" href="../stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Artifacts/">Artifacts</a></li><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LazyArtifacts/">Lazy Artifacts</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">Logging</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">Profiling</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="tocitem" href="../../stdlib/SuiteSparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">Inference</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="">Tasks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Tasks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/parallel.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="Tasks"><a class="docs-heading-anchor" href="#Tasks">Tasks</a><a id="Tasks-1"></a><a class="docs-heading-anchor-permalink" href="#Tasks" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" href="#Core.Task" id="Core.Task"><code>Core.Task</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Task(func)</code></pre><p>Create a <code>Task</code> (i.e. coroutine) to execute the given function <code>func</code> (which must be callable with no arguments). The task exits when this function returns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a() = sum(i for i in 1:1000);

julia&gt; b = Task(a);</code></pre><p>In this example, <code>b</code> is a runnable <code>Task</code> that hasn't started yet.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/docs/basedocs.jl#L1392-L1406" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@task" id="Base.@task"><code>Base.@task</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@task</code></pre><p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> without executing it, and return the <a href="#Core.Task"><code>Task</code></a>. This only creates a task, and does not run it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a1() = sum(i for i in 1:1000);

julia&gt; b = @task a1();

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L94-L116" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@async" id="Base.@async"><code>Base.@async</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@async</code></pre><p>Wrap an expression in a <a href="#Core.Task"><code>Task</code></a> and add it to the local machine's scheduler queue.</p><p>Values can be interpolated into <code>@async</code> via <code>$</code>, which copies the value directly into the constructed underlying closure. This allows you to insert the <em>value</em> of a variable, isolating the asynchronous code from changes to the variable's value in the current task.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.4</header><div class="admonition-body"><p>Interpolating values via <code>$</code> is available as of Julia 1.4.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L391-L402" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.asyncmap" id="Base.asyncmap"><code>Base.asyncmap</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">asyncmap(f, c...; ntasks=0, batch_size=nothing)</code></pre><p>Uses multiple concurrent tasks to map <code>f</code> over a collection (or multiple equal length collections). For multiple collection arguments, <code>f</code> is applied elementwise.</p><p><code>ntasks</code> specifies the number of tasks to run concurrently. Depending on the length of the collections, if <code>ntasks</code> is unspecified, up to 100 tasks will be used for concurrent mapping.</p><p><code>ntasks</code> can also be specified as a zero-arg function. In this case, the number of tasks to run in parallel is checked before processing every element and a new task started if the value of <code>ntasks_func</code> is less than the current number of tasks.</p><p>If <code>batch_size</code> is specified, the collection is processed in batch mode. <code>f</code> must then be a function that must accept a <code>Vector</code> of argument tuples and must return a vector of results. The input vector will have a length of <code>batch_size</code> or less.</p><p>The following examples highlight execution in different tasks by returning the <code>objectid</code> of the tasks in which the mapping function is executed.</p><p>First, with <code>ntasks</code> undefined, each element is processed in a different task.</p><pre><code class="language-none">julia&gt; tskoid() = objectid(current_task());

julia&gt; asyncmap(x-&gt;tskoid(), 1:5)
5-element Array{UInt64,1}:
 0x6e15e66c75c75853
 0x440f8819a1baa682
 0x9fb3eeadd0c83985
 0xebd3e35fe90d4050
 0x29efc93edce2b961

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5)))
5</code></pre><p>With <code>ntasks=2</code> all elements are processed in 2 tasks.</p><pre><code class="language-none">julia&gt; asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)
5-element Array{UInt64,1}:
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94
 0xa23d2f80cd7cf157
 0x027ab1680df7ae94

julia&gt; length(unique(asyncmap(x-&gt;tskoid(), 1:5; ntasks=2)))
2</code></pre><p>With <code>batch_size</code> defined, the mapping function needs to be changed to accept an array of argument tuples and return an array of results. <code>map</code> is used in the modified mapping function to achieve this.</p><pre><code class="language-none">julia&gt; batch_func(input) = map(x-&gt;string("args_tuple: ", x, ", element_val: ", x[1], ", task: ", tskoid()), input)
batch_func (generic function with 1 method)

julia&gt; asyncmap(batch_func, 1:5; ntasks=2, batch_size=2)
5-element Array{String,1}:
 "args_tuple: (1,), element_val: 1, task: 9118321258196414413"
 "args_tuple: (2,), element_val: 2, task: 4904288162898683522"
 "args_tuple: (3,), element_val: 3, task: 9118321258196414413"
 "args_tuple: (4,), element_val: 4, task: 4904288162898683522"
 "args_tuple: (5,), element_val: 5, task: 9118321258196414413"</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, <code>asyncmap</code> is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/asyncmap.jl#L5-L79" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.asyncmap!" id="Base.asyncmap!"><code>Base.asyncmap!</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">asyncmap!(f, results, c...; ntasks=0, batch_size=nothing)</code></pre><p>Like <a href="#Base.asyncmap"><code>asyncmap</code></a>, but stores output in <code>results</code> rather than returning a collection.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/asyncmap.jl#L411-L416" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.current_task" id="Base.current_task"><code>Base.current_task</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">current_task()</code></pre><p>Get the currently running <a href="#Core.Task"><code>Task</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L121-L125" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.istaskdone" id="Base.istaskdone"><code>Base.istaskdone</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">istaskdone(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a2() = sum(i for i in 1:1000);

julia&gt; b = Task(a2);

julia&gt; istaskdone(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L169-L190" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.istaskstarted" id="Base.istaskstarted"><code>Base.istaskstarted</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">istaskstarted(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has started executing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a3() = sum(i for i in 1:1000);

julia&gt; b = Task(a3);

julia&gt; istaskstarted(b)
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L193-L207" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.istaskfailed" id="Base.istaskfailed"><code>Base.istaskfailed</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">istaskfailed(t::Task) -&gt; Bool</code></pre><p>Determine whether a task has exited because an exception was thrown.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a4() = error("task failed");

julia&gt; b = Task(a4);

julia&gt; istaskfailed(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskfailed(b)
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L210-L234" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.task_local_storage-Tuple{Any}" id="Base.task_local_storage-Tuple{Any}"><code>Base.task_local_storage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">task_local_storage(key)</code></pre><p>Look up the value of a key in the current task's task-local storage.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L249-L253" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.task_local_storage-Tuple{Any, Any}" id="Base.task_local_storage-Tuple{Any, Any}"><code>Base.task_local_storage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">task_local_storage(key, value)</code></pre><p>Assign a value to a key in the current task's task-local storage.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L256-L260" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.task_local_storage-Tuple{Function, Any, Any}" id="Base.task_local_storage-Tuple{Function, Any, Any}"><code>Base.task_local_storage</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">task_local_storage(body, key, value)</code></pre><p>Call the function <code>body</code> with a modified task-local storage, in which <code>value</code> is assigned to <code>key</code>; the previous value of <code>key</code>, or lack thereof, is restored afterwards. Useful for emulating dynamic scoping.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L263-L269" target="_blank">source</a></section></article><h2 id="Scheduling"><a class="docs-heading-anchor" href="#Scheduling">Scheduling</a><a id="Scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.yield" id="Base.yield"><code>Base.yield</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yield()</code></pre><p>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L646-L652" target="_blank">source</a></section><section><div><pre><code class="language-none">yield(t::Task, arg = nothing)</code></pre><p>A fast, unfair-scheduling version of <code>schedule(t, arg); yield()</code> which immediately yields to <code>t</code> before calling the scheduler.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L666-L671" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.yieldto" id="Base.yieldto"><code>Base.yieldto</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yieldto(t::Task, arg = nothing)</code></pre><p>Switch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, <code>arg</code> is returned from the task's last call to <code>yieldto</code>. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L679-L686" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.sleep" id="Base.sleep"><code>Base.sleep</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sleep(seconds)</code></pre><p>Block the current task for a specified number of seconds. The minimum sleep time is 1 millisecond or input of <code>0.001</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/asyncevent.jl#L206-L211" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.schedule" id="Base.schedule"><code>Base.schedule</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schedule(t::Task, [val]; error=false)</code></pre><p>Add a <a href="#Core.Task"><code>Task</code></a> to the scheduler's queue. This causes the task to run constantly when the system is otherwise idle, unless the task performs a blocking operation such as <a href="#Base.wait"><code>wait</code></a>.</p><p>If a second argument <code>val</code> is provided, it will be passed to the task (via the return value of <a href="#Base.yieldto"><code>yieldto</code></a>) when it runs again. If <code>error</code> is <code>true</code>, the value is raised as an exception in the woken task.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a5() = sum(i for i in 1:1000);

julia&gt; b = Task(a5);

julia&gt; istaskstarted(b)
false

julia&gt; schedule(b);

julia&gt; yield();

julia&gt; istaskstarted(b)
true

julia&gt; istaskdone(b)
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L601-L630" target="_blank">source</a></section></article><h2 id="lib-task-sync"><a class="docs-heading-anchor" href="#lib-task-sync">Synchronization</a><a id="lib-task-sync-1"></a><a class="docs-heading-anchor-permalink" href="#lib-task-sync" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.@sync" id="Base.@sync"><code>Base.@sync</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@sync</code></pre><p>Wait until all lexically-enclosed uses of <code>@async</code>, <code>@spawn</code>, <code>@spawnat</code> and <code>@distributed</code> are complete. All exceptions thrown by enclosed async operations are collected and thrown as a <code>CompositeException</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L371-L377" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.wait" id="Base.wait"><code>Base.wait</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wait(r::Future)</code></pre><p>Wait for a value to become available for the specified <a href="../../stdlib/Distributed/#Distributed.Future"><code>Future</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/stdlib/Distributed/src/remotecall.jl#L510-L514" target="_blank">source</a></section><section><div><pre><code class="language-none">wait(r::RemoteChannel, args...)</code></pre><p>Wait for a value to become available on the specified <a href="../../stdlib/Distributed/#Distributed.RemoteChannel"><code>RemoteChannel</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/stdlib/Distributed/src/remotecall.jl#L517-L521" target="_blank">source</a></section><section><div><p>Special note for <a href="../multi-threading/#Base.Threads.Condition"><code>Threads.Condition</code></a>:</p><p>The caller must be holding the <a href="#Base.lock"><code>lock</code></a> that owns a <code>Threads.Condition</code> before calling this method. The calling task will be blocked until some other task wakes it, usually by calling <a href="#Base.notify"><code>notify</code></a> on the same <code>Threads.Condition</code> object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L253-L261" target="_blank">source</a></section><section><div><pre><code class="language-none">wait([x])</code></pre><p>Block the current task until some event occurs, depending on the type of the argument:</p><ul><li><a href="#Base.Channel"><code>Channel</code></a>: Wait for a value to be appended to the channel.</li><li><a href="#Base.Condition"><code>Condition</code></a>: Wait for <a href="#Base.notify"><code>notify</code></a> on a condition.</li><li><code>Process</code>: Wait for a process or process chain to exit. The <code>exitcode</code> field of a process can be used to determine success or failure.</li><li><a href="#Core.Task"><code>Task</code></a>: Wait for a <code>Task</code> to finish. If the task fails with an exception, a <code>TaskFailedException</code> (which wraps the failed task) is thrown.</li><li><a href="../file/#Base.Libc.RawFD"><code>RawFD</code></a>: Wait for changes on a file descriptor (see the <code>FileWatching</code> package).</li></ul><p>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to <a href="#Base.schedule"><code>schedule</code></a> or <a href="#Base.yieldto"><code>yieldto</code></a>.</p><p>Often <code>wait</code> is called within a <code>while</code> loop to ensure a waited-for condition is met before proceeding.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/condition.jl#L81-L99" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.fetch-Tuple{Task}" id="Base.fetch-Tuple{Task}"><code>Base.fetch</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fetch(t::Task)</code></pre><p>Wait for a Task to finish, then return its result value. If the task fails with an exception, a <code>TaskFailedException</code> (which wraps the failed task) is thrown.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/task.jl#L324-L330" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.timedwait" id="Base.timedwait"><code>Base.timedwait</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timedwait(callback::Function, timeout::Real; pollint::Real=0.1)</code></pre><p>Waits until <code>callback</code> returns <code>true</code> or <code>timeout</code> seconds have passed, whichever is earlier. <code>callback</code> is polled every <code>pollint</code> seconds. The minimum value for <code>timeout</code> and <code>pollint</code> is <code>0.001</code>, that is, 1 millisecond.</p><p>Returns :ok or :timed_out</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/asyncevent.jl#L258-L266" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Condition" id="Base.Condition"><code>Base.Condition</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Condition()</code></pre><p>Create an edge-triggered event source that tasks can wait for. Tasks that call <a href="#Base.wait"><code>wait</code></a> on a <code>Condition</code> are suspended and queued. Tasks are woken up when <a href="#Base.notify"><code>notify</code></a> is later called on the <code>Condition</code>. Edge triggering means that only tasks waiting at the time <a href="#Base.notify"><code>notify</code></a> is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The <a href="#Base.Channel"><code>Channel</code></a> and <a href="../multi-threading/#Base.Event"><code>Threads.Event</code></a> types do this, and can be used for level-triggered events.</p><p>This object is NOT thread-safe. See <a href="../multi-threading/#Base.Threads.Condition"><code>Threads.Condition</code></a> for a thread-safe version.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/condition.jl#L151-L162" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.notify" id="Base.notify"><code>Base.notify</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">notify(condition, val=nothing; all=true, error=false)</code></pre><p>Wake up tasks waiting for a condition, passing them <code>val</code>. If <code>all</code> is <code>true</code> (the default), all waiting tasks are woken, otherwise only one is. If <code>error</code> is <code>true</code>, the passed value is raised as an exception in the woken tasks.</p><p>Return the count of tasks woken up. Return 0 if no tasks are waiting on <code>condition</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/condition.jl#L115-L123" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Semaphore" id="Base.Semaphore"><code>Base.Semaphore</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Semaphore(sem_size)</code></pre><p>Create a counting semaphore that allows at most <code>sem_size</code> acquires to be in use at any time. Each acquire must be matched with a release.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L265-L271" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.acquire" id="Base.acquire"><code>Base.acquire</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">acquire(s::Semaphore)</code></pre><p>Wait for one of the <code>sem_size</code> permits to be available, blocking until one can be acquired.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L279-L284" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.release" id="Base.release"><code>Base.release</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">release(s::Semaphore)</code></pre><p>Return one permit to the pool, possibly allowing another task to acquire it and resume execution.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L298-L304" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.AbstractLock" id="Base.AbstractLock"><code>Base.AbstractLock</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLock</code></pre><p>Abstract supertype describing types that implement the synchronization primitives: <a href="#Base.lock"><code>lock</code></a>, <a href="#Base.trylock"><code>trylock</code></a>, <a href="#Base.unlock"><code>unlock</code></a>, and <a href="#Base.islocked"><code>islocked</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/condition.jl#L11-L17" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.lock" id="Base.lock"><code>Base.lock</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lock(lock)</code></pre><p>Acquire the <code>lock</code> when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>Each <code>lock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L77-L85" target="_blank">source</a></section><section><div><pre><code class="language-none">lock(f::Function, lock)</code></pre><p>Acquire the <code>lock</code>, execute <code>f</code> with the <code>lock</code> held, and release the <code>lock</code> when <code>f</code> returns. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>When this function returns, the <code>lock</code> has been released, so the caller should not attempt to <code>unlock</code> it.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L174-L183" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.unlock" id="Base.unlock"><code>Base.unlock</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unlock(lock)</code></pre><p>Releases ownership of the <code>lock</code>.</p><p>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L111-L118" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.trylock" id="Base.trylock"><code>Base.trylock</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trylock(lock) -&gt; Success (Boolean)</code></pre><p>Acquire the lock if it is available, and return <code>true</code> if successful. If the lock is already locked by a different task/thread, return <code>false</code>.</p><p>Each successful <code>trylock</code> must be matched by an <a href="#Base.unlock"><code>unlock</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L48-L57" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.islocked" id="Base.islocked"><code>Base.islocked</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">islocked(lock) -&gt; Status (Boolean)</code></pre><p>Check whether the <code>lock</code> is held by any task/thread. This should not be used for synchronization (see instead <a href="#Base.trylock"><code>trylock</code></a>).</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L38-L43" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.ReentrantLock" id="Base.ReentrantLock"><code>Base.ReentrantLock</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReentrantLock()</code></pre><p>Creates a re-entrant lock for synchronizing <a href="#Core.Task"><code>Task</code></a>s. The same task can acquire the lock as many times as required. Each <a href="#Base.lock"><code>lock</code></a> must be matched with an <a href="#Base.unlock"><code>unlock</code></a>.</p><p>Calling 'lock' will also inhibit running of finalizers on that thread until the corresponding 'unlock'. Use of the standard lock pattern illustrated below should naturally be supported, but beware of inverting the try/lock order or missing the try block entirely (e.g. attempting to return with the lock still held):</p><pre><code class="language-none">lock(l)
try
    &lt;atomic work&gt;
finally
    unlock(l)
end</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/lock.jl#L6-L27" target="_blank">source</a></section></article><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" href="#Base.Channel" id="Base.Channel"><code>Base.Channel</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Channel{T=Any}(size::Int=0)</code></pre><p>Constructs a <code>Channel</code> with an internal buffer that can hold a maximum of <code>size</code> objects of type <code>T</code>. <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> calls on a full channel block until an object is removed with <a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a>.</p><p><code>Channel(0)</code> constructs an unbuffered channel. <code>put!</code> blocks until a matching <code>take!</code> is called. And vice-versa.</p><p>Other constructors:</p><ul><li><code>Channel()</code>: default constructor, equivalent to <code>Channel{Any}(0)</code></li><li><code>Channel(Inf)</code>: equivalent to <code>Channel{Any}(typemax(Int))</code></li><li><code>Channel(sz)</code>: equivalent to <code>Channel{Any}(sz)</code></li></ul><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The default constructor <code>Channel()</code> and default <code>size=0</code> were added in Julia 1.3.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L13-L31" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Channel-Tuple{Function}" id="Base.Channel-Tuple{Function}"><code>Base.Channel</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Channel{T=Any}(func::Function, size=0; taskref=nothing, spawn=false)</code></pre><p>Create a new task from <code>func</code>, bind it to a new channel of type <code>T</code> and size <code>size</code>, and schedule the task, all in a single call.</p><p><code>func</code> must accept the bound channel as its only argument.</p><p>If you need a reference to the created task, pass a <code>Ref{Task}</code> object via the keyword argument <code>taskref</code>.</p><p>If <code>spawn = true</code>, the Task created for <code>func</code> may be scheduled on another thread in parallel, equivalent to creating a task via <a href="../multi-threading/#Base.Threads.@spawn"><code>Threads.@spawn</code></a>.</p><p>Return a <code>Channel</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; chnl = Channel() do ch
           foreach(i -&gt; put!(ch, i), 1:4)
       end;

julia&gt; typeof(chnl)
Channel{Any}

julia&gt; for i in chnl
           @show i
       end;
i = 1
i = 2
i = 3
i = 4</code></pre><p>Referencing the created task:</p><pre><code class="language-julia-repl">julia&gt; taskref = Ref{Task}();

julia&gt; chnl = Channel(taskref=taskref) do ch
           println(take!(ch))
       end;

julia&gt; istaskdone(taskref[])
false

julia&gt; put!(chnl, "Hello");
Hello

julia&gt; istaskdone(taskref[])
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>The <code>spawn=</code> parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set <code>size</code> and <code>T</code>, but those constructors are deprecated.</p></div></div><pre><code class="language-julia-repl">julia&gt; chnl = Channel{Char}(1, spawn=true) do ch
           for c in "hello world"
               put!(ch, c)
           end
       end
Channel{Char}(1) (1 item available)

julia&gt; String(collect(chnl))
"hello world"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L60-L129" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.put!-Tuple{Channel, Any}" id="Base.put!-Tuple{Channel, Any}"><code>Base.put!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">put!(c::Channel, v)</code></pre><p>Append an item <code>v</code> to the channel <code>c</code>. Blocks if the channel is full.</p><p>For unbuffered channels, blocks until a <a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> is performed by a different task.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p><code>v</code> now gets converted to the channel's type with <a href="../base/#Base.convert"><code>convert</code></a> as <code>put!</code> is called.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L302-L312" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.take!-Tuple{Channel}" id="Base.take!-Tuple{Channel}"><code>Base.take!</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">take!(c::Channel)</code></pre><p>Remove and return a value from a <a href="#Base.Channel"><code>Channel</code></a>. Blocks until data is available.</p><p>For unbuffered channels, blocks until a <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> is performed by a different task.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L375-L382" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isready-Tuple{Channel}" id="Base.isready-Tuple{Channel}"><code>Base.isready</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isready(c::Channel)</code></pre><p>Determine whether a <a href="#Base.Channel"><code>Channel</code></a> has a value stored to it. Returns immediately, does not block.</p><p>For unbuffered channels returns <code>true</code> if there are tasks waiting on a <a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L411-L419" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.fetch-Tuple{Channel}" id="Base.fetch-Tuple{Channel}"><code>Base.fetch</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fetch(c::Channel)</code></pre><p>Wait for and get the first available item from the channel. Does not remove the item. <code>fetch</code> is unsupported on an unbuffered (0-size) channel.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L353-L358" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.close-Tuple{Channel}" id="Base.close-Tuple{Channel}"><code>Base.close</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">close(c::Channel[, excp::Exception])</code></pre><p>Close a channel. An exception (optionally given by <code>excp</code>), is thrown by:</p><ul><li><a href="#Base.put!-Tuple{Channel, Any}"><code>put!</code></a> on a closed channel.</li><li><a href="../io-network/#Base.take!-Tuple{Base.GenericIOBuffer}"><code>take!</code></a> and <a href="#Base.fetch-Tuple{Task}"><code>fetch</code></a> on an empty, closed channel.</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L174-L181" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.bind-Tuple{Channel, Task}" id="Base.bind-Tuple{Channel, Task}"><code>Base.bind</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bind(chnl::Channel, task::Task)</code></pre><p>Associate the lifetime of <code>chnl</code> with a task. <code>Channel</code><code>chnl</code> is automatically closed when the task terminates. Any uncaught exception in the task is propagated to all waiters on <code>chnl</code>.</p><p>The <code>chnl</code> object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed <code>Channel</code> objects.</p><p>When a channel is bound to multiple tasks, the first task to terminate will close the channel. When multiple channels are bound to the same task, termination of the task will close all of the bound channels.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @async foreach(i-&gt;put!(c, i), 1:4);

julia&gt; bind(c,task);

julia&gt; for i in c
           @show i
       end;
i = 1
i = 2
i = 3
i = 4

julia&gt; isopen(c)
false</code></pre><pre><code class="language-julia-repl">julia&gt; c = Channel(0);

julia&gt; task = @async (put!(c, 1); error("foo"));

julia&gt; bind(c, task);

julia&gt; take!(c)
1

julia&gt; put!(c, 1);
ERROR: TaskFailedException
Stacktrace:
[...]
    nested task error: foo
[...]</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/f9720dc2ebd6cd9e3086365f281e62506444ef37/base/channels.jl#L197-L248" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../arrays/">Â« Arrays</a><a class="docs-footer-nextpage" href="../multi-threading/">Multi-Threading Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 29 May 2021 15:17">Saturday 29 May 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>