<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Strings Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://docs.julialang.org/en/v1/base/strings/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="../../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link href="../../assets/julia.ico" rel="icon" type="image/x-icon"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="The Julia Language logo" class="docs-light-only" src="../../assets/logo.svg"/><img alt="The Julia Language logo" class="docs-dark-only" src="../../assets/logo-dark.svg"/></a><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Julia Documentation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../../manual/strings/">Strings</a></li><li><a class="tocitem" href="../../manual/functions/">Functions</a></li><li><a class="tocitem" href="../../manual/control-flow/">Control Flow</a></li><li><a class="tocitem" href="../../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="tocitem" href="../../manual/types/">Types</a></li><li><a class="tocitem" href="../../manual/methods/">Methods</a></li><li><a class="tocitem" href="../../manual/constructors/">Constructors</a></li><li><a class="tocitem" href="../../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="tocitem" href="../../manual/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../../manual/modules/">Modules</a></li><li><a class="tocitem" href="../../manual/documentation/">Documentation</a></li><li><a class="tocitem" href="../../manual/metaprogramming/">Metaprogramming</a></li><li><a class="tocitem" href="../../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="../../manual/missing/">Missing Values</a></li><li><a class="tocitem" href="../../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="tocitem" href="../../manual/parallel-computing/">Parallel Computing</a></li><li><a class="tocitem" href="../../manual/asynchronous-programming/">Asynchronous Programming</a></li><li><a class="tocitem" href="../../manual/multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../../manual/distributed-computing/">Multi-processing and Distributed Computing</a></li><li><a class="tocitem" href="../../manual/running-external-programs/">Running External Programs</a></li><li><a class="tocitem" href="../../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="tocitem" href="../../manual/environment-variables/">Environment Variables</a></li><li><a class="tocitem" href="../../manual/embedding/">Embedding Julia</a></li><li><a class="tocitem" href="../../manual/code-loading/">Code Loading</a></li><li><a class="tocitem" href="../../manual/profile/">Profiling</a></li><li><a class="tocitem" href="../../manual/stacktraces/">Stack Traces</a></li><li><a class="tocitem" href="../../manual/performance-tips/">Performance Tips</a></li><li><a class="tocitem" href="../../manual/workflow-tips/">Workflow Tips</a></li><li><a class="tocitem" href="../../manual/style-guide/">Style Guide</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../../manual/unicode-input/">Unicode Input</a></li><li><a class="tocitem" href="../../manual/command-line-options/">Command-line Options</a></li></ul></li><li><input checked="" class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../base/">Essentials</a></li><li><a class="tocitem" href="../collections/">Collections and Data Structures</a></li><li><a class="tocitem" href="../math/">Mathematics</a></li><li><a class="tocitem" href="../numbers/">Numbers</a></li><li class="is-active"><a class="tocitem" href="">Strings</a></li><li><a class="tocitem" href="../arrays/">Arrays</a></li><li><a class="tocitem" href="../parallel/">Tasks</a></li><li><a class="tocitem" href="../multi-threading/">Multi-Threading</a></li><li><a class="tocitem" href="../constants/">Constants</a></li><li><a class="tocitem" href="../file/">Filesystem</a></li><li><a class="tocitem" href="../io-network/">I/O and Network</a></li><li><a class="tocitem" href="../punctuation/">Punctuation</a></li><li><a class="tocitem" href="../sort/">Sorting and Related Functions</a></li><li><a class="tocitem" href="../iterators/">Iteration utilities</a></li><li><a class="tocitem" href="../c/">C Interface</a></li><li><a class="tocitem" href="../libc/">C Standard Library</a></li><li><a class="tocitem" href="../stacktraces/">StackTraces</a></li><li><a class="tocitem" href="../simd-types/">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../stdlib/Base64/">Base64</a></li><li><a class="tocitem" href="../../stdlib/CRC32c/">CRC32c</a></li><li><a class="tocitem" href="../../stdlib/Dates/">Dates</a></li><li><a class="tocitem" href="../../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="tocitem" href="../../stdlib/Distributed/">Distributed Computing</a></li><li><a class="tocitem" href="../../stdlib/Downloads/">Downloads</a></li><li><a class="tocitem" href="../../stdlib/FileWatching/">File Events</a></li><li><a class="tocitem" href="../../stdlib/Future/">Future</a></li><li><a class="tocitem" href="../../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="tocitem" href="../../stdlib/LibGit2/">LibGit2</a></li><li><a class="tocitem" href="../../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="tocitem" href="../../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/Logging/">Logging</a></li><li><a class="tocitem" href="../../stdlib/Markdown/">Markdown</a></li><li><a class="tocitem" href="../../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="tocitem" href="../../stdlib/Pkg/">Pkg</a></li><li><a class="tocitem" href="../../stdlib/Printf/">Printf</a></li><li><a class="tocitem" href="../../stdlib/Profile/">Profiling</a></li><li><a class="tocitem" href="../../stdlib/REPL/">The Julia REPL</a></li><li><a class="tocitem" href="../../stdlib/Random/">Random Numbers</a></li><li><a class="tocitem" href="../../stdlib/SHA/">SHA</a></li><li><a class="tocitem" href="../../stdlib/Serialization/">Serialization</a></li><li><a class="tocitem" href="../../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="tocitem" href="../../stdlib/Sockets/">Sockets</a></li><li><a class="tocitem" href="../../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="tocitem" href="../../stdlib/Statistics/">Statistics</a></li><li><a class="tocitem" href="../../stdlib/SuiteSparse/">Sparse Linear Algebra</a></li><li><a class="tocitem" href="../../stdlib/TOML/">TOML</a></li><li><a class="tocitem" href="../../stdlib/Test/">Unit Testing</a></li><li><a class="tocitem" href="../../stdlib/UUIDs/">UUIDs</a></li><li><a class="tocitem" href="../../stdlib/Unicode/">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/reflection/">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia's Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/ast/">Julia ASTs</a></li><li><a class="tocitem" href="../../devdocs/types/">More about types</a></li><li><a class="tocitem" href="../../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../../devdocs/eval/">Eval of Julia code</a></li><li><a class="tocitem" href="../../devdocs/callconv/">Calling Conventions</a></li><li><a class="tocitem" href="../../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../../devdocs/functions/">Julia Functions</a></li><li><a class="tocitem" href="../../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="tocitem" href="../../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../../devdocs/subarrays/">SubArrays</a></li><li><a class="tocitem" href="../../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="tocitem" href="../../devdocs/sysimg/">System Image Building</a></li><li><a class="tocitem" href="../../devdocs/llvm/">Working with LLVM</a></li><li><a class="tocitem" href="../../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../../devdocs/boundscheck/">Bounds checking</a></li><li><a class="tocitem" href="../../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="tocitem" href="../../devdocs/require/">Module loading</a></li><li><a class="tocitem" href="../../devdocs/inference/">Inference</a></li><li><a class="tocitem" href="../../devdocs/ssair/">Julia SSA-form IR</a></li><li><a class="tocitem" href="../../devdocs/gc-sa/">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia's C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="tocitem" href="../../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="">Strings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Strings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/strings.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="lib-strings"><a class="docs-heading-anchor" href="#lib-strings">Strings</a><a id="lib-strings-1"></a><a class="docs-heading-anchor-permalink" href="#lib-strings" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" href="#Core.AbstractChar" id="Core.AbstractChar"><code>Core.AbstractChar</code></a> â <span class="docstring-category">Type</span></header><section><div><p>The <code>AbstractChar</code> type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the <a href="#Base.codepoint"><code>codepoint</code></a> function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with <code>&lt;</code> and <code>==</code>, for example.  New <code>T &lt;: AbstractChar</code> types should define a <code>codepoint(::T)</code> method and a <code>T(::UInt32)</code> constructor, at minimum.</p><p>A given <code>AbstractChar</code> subtype may be capable of representing only a subset of Unicode, in which case conversion from an unsupported <code>UInt32</code> value may throw an error. Conversely, the built-in <a href="#Core.Char"><code>Char</code></a> type represents a <em>superset</em> of Unicode (in order to losslessly encode invalid byte streams), in which case conversion of a non-Unicode value <em>to</em><code>UInt32</code> throws an error. The <a href="#Base.isvalid-Tuple{Any}"><code>isvalid</code></a> function can be used to check which codepoints are representable in a given <code>AbstractChar</code> type.</p><p>Internally, an <code>AbstractChar</code> type may use a variety of encodings.  Conversion via <code>codepoint(char)</code> will not reveal this encoding because it always returns the Unicode value of the character. <code>print(io, c)</code> of any <code>c::AbstractChar</code> produces an encoding determined by <code>io</code> (UTF-8 for all built-in <code>IO</code> types), via conversion to <code>Char</code> if necessary.</p><p><code>write(io, c)</code>, in contrast, may emit an encoding depending on <code>typeof(c)</code>, and <code>read(io, typeof(c))</code> should read the same encoding as <code>write</code>. New <code>AbstractChar</code> types must provide their own implementations of <code>write</code> and <code>read</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/char.jl#L3-L30" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Core.Char" id="Core.Char"><code>Core.Char</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Char(c::Union{Number,AbstractChar})</code></pre><p><code>Char</code> is a 32-bit <a href="#Core.AbstractChar"><code>AbstractChar</code></a> type that is the default representation of characters in Julia. <code>Char</code> is the type used for character literals like <code>'x'</code> and it is also the element type of <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>.</p><p>In order to losslessly represent arbitrary byte streams stored in a <code>String</code>, a <code>Char</code> value may store information that cannot be converted to a Unicode codepoint â converting such a <code>Char</code> to <code>UInt32</code> will throw an error. The <a href="#Base.isvalid-Tuple{Any}"><code>isvalid(c::Char)</code></a> function can be used to query whether <code>c</code> represents a valid Unicode character.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/char.jl#L33-L45" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.codepoint" id="Base.codepoint"><code>Base.codepoint</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codepoint(c::AbstractChar) -&gt; Integer</code></pre><p>Return the Unicode codepoint (an unsigned integer) corresponding to the character <code>c</code> (or throw an exception if <code>c</code> does not represent a valid character). For <code>Char</code>, this is a <code>UInt32</code> value, but <code>AbstractChar</code> types that represent only a subset of Unicode may return a different-sized integer (e.g. <code>UInt8</code>).</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/char.jl#L66-L74" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.length-Tuple{AbstractString}" id="Base.length-Tuple{AbstractString}"><code>Base.length</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(s::AbstractString) -&gt; Int
length(s::AbstractString, i::Integer, j::Integer) -&gt; Int</code></pre><p>Return the number of characters in string <code>s</code> from indices <code>i</code> through <code>j</code>.</p><p>This is computed as the number of code unit indices from <code>i</code> to <code>j</code> which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With <code>i</code> and <code>j</code> arguments it computes the number of indices between <code>i</code> and <code>j</code> inclusive that are valid indices in the string <code>s</code>. In addition to in-bounds values, <code>i</code> may take the out-of-bounds value <code>ncodeunits(s) + 1</code> and <code>j</code> may take the out-of-bounds value <code>0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The time complexity of this operation is linear in general. That is, it will take the time proportional to the number of bytes or characters in the string because it counts the value on the fly. This is in contrast to the method for arrays, which is a constant-time operation.</p></div></div><p>See also: <a href="#Base.isvalid-Tuple{Any}"><code>isvalid</code></a>, <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="../collections/#Base.lastindex"><code>lastindex</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length("jÎ¼ÎIÎ±")
5</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L358-L386" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.sizeof-Tuple{AbstractString}" id="Base.sizeof-Tuple{AbstractString}"><code>Base.sizeof</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof(str::AbstractString)</code></pre><p>Size, in bytes, of the string <code>str</code>. Equal to the number of code units in <code>str</code> multiplied by the size, in bytes, of one code unit in <code>str</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sizeof("")
0

julia&gt; sizeof("â")
3</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L164-L178" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}" id="Base.:*-Tuple{Union{AbstractChar, AbstractString}, Vararg{Union{AbstractChar, AbstractString}, N} where N}"><code>Base.:*</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(s::Union{AbstractString, AbstractChar}, t::Union{AbstractString, AbstractChar}...) -&gt; AbstractString</code></pre><p>Concatenate strings and/or characters, producing a <a href="#Core.String-Tuple{AbstractString}"><code>String</code></a>. This is equivalent to calling the <a href="#Base.string"><code>string</code></a> function on the arguments. Concatenation of built-in string types always produces a value of type <code>String</code> but other string types may choose to return a string of a different type as appropriate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; "Hello " * "world"
"Hello world"

julia&gt; 'j' * "ulia"
"julia"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L243-L259" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}" id="Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>Base.:^</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">^(s::Union{AbstractString,AbstractChar}, n::Integer)</code></pre><p>Repeat a string or character <code>n</code> times. This can also be written as <code>repeat(s, n)</code>.</p><p>See also: <a href="../arrays/#Base.repeat"><code>repeat</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; "Test "^3
"Test Test Test "</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L705-L717" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.string" id="Base.string"><code>Base.string</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">string(n::Integer; base::Integer = 10, pad::Integer = 1)</code></pre><p>Convert an integer <code>n</code> to a string in the given <code>base</code>, optionally specifying a number of digits to pad to.</p><pre><code class="language-julia-repl">julia&gt; string(5, base = 13, pad = 4)
"0005"

julia&gt; string(13, base = 5, pad = 4)
"0023"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/intfuncs.jl#L746-L759" target="_blank">source</a></section><section><div><pre><code class="language-none">string(xs...)</code></pre><p>Create a string from any values using the <a href="../io-network/#Base.print"><code>print</code></a> function.</p><p><code>string</code> should usually not be defined directly. Instead, define a method <code>print(io::IO, x::MyType)</code>. If <code>string(x)</code> for a certain type needs to be highly efficient, then it may make sense to add a method to <code>string</code> and define <code>print(io::IO, x::MyType) = print(io, string(x))</code> to ensure the functions are consistent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; string("a", 1, true)
"a1true"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L157-L173" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.repeat-Tuple{AbstractString, Integer}" id="Base.repeat-Tuple{AbstractString, Integer}"><code>Base.repeat</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">repeat(s::AbstractString, r::Integer)</code></pre><p>Repeat a string <code>r</code> times. This can be written as <code>s^r</code>.</p><p>See also: <a href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>^</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat("ha", 3)
"hahaha"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L690-L702" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.repeat-Tuple{AbstractChar, Integer}" id="Base.repeat-Tuple{AbstractChar, Integer}"><code>Base.repeat</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">repeat(c::AbstractChar, r::Integer) -&gt; String</code></pre><p>Repeat a character <code>r</code> times. This can equivalently be accomplished by calling <a href="#Base.:^-Tuple{Union{AbstractChar, AbstractString}, Integer}"><code>c^r</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repeat('A', 3)
"AAA"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/string.jl#L321-L332" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.repr-Tuple{Any}" id="Base.repr-Tuple{Any}"><code>Base.repr</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">repr(x; context=nothing)</code></pre><p>Create a string from any value using the <a href="../io-network/#Base.show-Tuple{IO, Any}"><code>show</code></a> function. You should not add methods to <code>repr</code>; define a <code>show</code> method instead.</p><p>The optional keyword argument <code>context</code> can be set to an <code>IO</code> or <a href="../io-network/#Base.IOContext"><code>IOContext</code></a> object whose attributes are used for the I/O stream passed to <code>show</code>.</p><p>Note that <code>repr(x)</code> is usually similar to how the value of <code>x</code> would be entered in Julia.  See also <a href="../io-network/#Base.repr-Tuple{MIME, Any}"><code>repr(MIME("text/plain"), x)</code></a> to instead return a "pretty-printed" version of <code>x</code> designed more for human consumption, equivalent to the REPL display of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; repr(1)
"1"

julia&gt; repr(zeros(3))
"[0.0, 0.0, 0.0]"

julia&gt; repr(big(1/3))
"0.333333333333333314829616256247390992939472198486328125"

julia&gt; repr(big(1/3), context=:compact =&gt; true)
"0.333333"
</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L199-L228" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Core.String-Tuple{AbstractString}" id="Core.String-Tuple{AbstractString}"><code>Core.String</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">String(s::AbstractString)</code></pre><p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/string.jl#L76-L81" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.SubString" id="Base.SubString"><code>Base.SubString</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SubString(s::AbstractString, i::Integer, j::Integer=lastindex(s))
SubString(s::AbstractString, r::UnitRange{&lt;:Integer})</code></pre><p>Like <a href="../collections/#Base.getindex"><code>getindex</code></a>, but returns a view into the parent string <code>s</code> within range <code>i:j</code> or <code>r</code> respectively instead of making a copy.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; SubString("abc", 1, 2)
"ab"

julia&gt; SubString("abc", 1:2)
"ab"

julia&gt; SubString("abc", 2)
"bc"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/substring.jl#L3-L21" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.transcode" id="Base.transcode"><code>Base.transcode</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transcode(T, src)</code></pre><p>Convert string data between Unicode encodings. <code>src</code> is either a <code>String</code> or a <code>Vector{UIntXX}</code> of UTF-XX code units, where <code>XX</code> is 8, 16, or 32. <code>T</code> indicates the encoding of the return value: <code>String</code> to return a (UTF-8 encoded) <code>String</code> or <code>UIntXX</code> to return a <code>Vector{UIntXX}</code> of UTF-<code>XX</code> data. (The alias <a href="../c/#Base.Cwchar_t"><code>Cwchar_t</code></a> can also be used as the integer type, for converting <code>wchar_t*</code> strings used by external C libraries.)</p><p>The <code>transcode</code> function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</p><p>Only conversion to/from UTF-8 is currently supported.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/c.jl#L257-L273" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.unsafe_string" id="Base.unsafe_string"><code>Base.unsafe_string</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unsafe_string(p::Ptr{UInt8}, [length::Integer])</code></pre><p>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If <code>length</code> is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</p><p>This function is labeled "unsafe" because it will crash if <code>p</code> is not a valid memory address to data of the requested length.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/string.jl#L55-L64" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.ncodeunits-Tuple{AbstractString}" id="Base.ncodeunits-Tuple{AbstractString}"><code>Base.ncodeunits</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ncodeunits(s::AbstractString) -&gt; Int</code></pre><p>Return the number of code units in a string. Indices that are in bounds to access this string must satisfy <code>1 â¤ i â¤Â ncodeunits(s)</code>. Not all such indices are valid âÂ they may not be the start of a character, but they will return a code unit value when calling <code>codeunit(s,i)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ncodeunits("The Julia Language")
18

julia&gt; ncodeunits("â«eË£")
6

julia&gt; ncodeunits('â«'), ncodeunits('e'), ncodeunits('Ë£')
(3, 1, 2)</code></pre><p>See also: <a href="#Base.codeunit"><code>codeunit</code></a>, <a href="../arrays/#Base.checkbounds"><code>checkbounds</code></a>, <a href="../base/#Base.sizeof-Tuple{Type}"><code>sizeof</code></a>, <a href="../collections/#Base.length"><code>length</code></a>, <a href="../collections/#Base.lastindex"><code>lastindex</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L45-L67" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.codeunit" id="Base.codeunit"><code>Base.codeunit</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codeunit(s::AbstractString) -&gt; Type{&lt;:Union{UInt8, UInt16, UInt32}}</code></pre><p>Return the code unit type of the given string object. For ASCII, Latin-1, or UTF-8 encoded strings, this would be <code>UInt8</code>; for UCS-2 and UTF-16 it would be <code>UInt16</code>; for UTF-32 it would be <code>UInt32</code>. The code unit type need not be limited to these three types, but it's hard to think of widely used string encodings that don't use one of these units. <code>codeunit(s)</code> is the same as <code>typeof(codeunit(s,1))</code> when <code>s</code> is a non-empty string.</p><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L70-L81" target="_blank">source</a></section><section><div><pre><code class="language-none">codeunit(s::AbstractString, i::Integer) -&gt; Union{UInt8, UInt16, UInt32}</code></pre><p>Return the code unit value in the string <code>s</code> at index <code>i</code>. Note that</p><pre><code class="language-none">codeunit(s, i) :: codeunit(s)</code></pre><p>I.e. the value returned by <code>codeunit(s, i)</code> is of the type returned by <code>codeunit(s)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = codeunit("Hello", 2)
0x65

julia&gt; typeof(a)
UInt8</code></pre><p>See also: <a href="#Base.ncodeunits-Tuple{AbstractString}"><code>ncodeunits</code></a>, <a href="../arrays/#Base.checkbounds"><code>checkbounds</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L86-L106" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.codeunits" id="Base.codeunits"><code>Base.codeunits</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">codeunits(s::AbstractString)</code></pre><p>Obtain a vector-like object containing the code units of a string. Returns a <code>CodeUnits</code> wrapper by default, but <code>codeunits</code> may optionally be defined for new string types if necessary.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; codeunits("JuÎ»ia")
6-element Base.CodeUnits{UInt8, String}:
 0x4a
 0x75
 0xce
 0xbb
 0x69
 0x61</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L751-L769" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.ascii" id="Base.ascii"><code>Base.ascii</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ascii(s::AbstractString)</code></pre><p>Convert a string to <code>String</code> type and check that it contains only ASCII data, otherwise throwing an <code>ArgumentError</code> indicating the position of the first non-ASCII byte.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ascii("abcdeÎ³fgh")
ERROR: ArgumentError: invalid ASCII at index 6 in "abcdeÎ³fgh"
Stacktrace:
[...]

julia&gt; ascii("abcdefgh")
"abcdefgh"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L716-L732" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Regex" id="Base.Regex"><code>Base.Regex</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Regex(pattern[, flags])</code></pre><p>A type representing a regular expression. <code>Regex</code> objects can be used to match strings with <a href="#Base.match"><code>match</code></a>.</p><p><code>Regex</code> objects can be created using the <a href="#Base.@r_str"><code>@r_str</code></a> string macro. The <code>Regex(pattern[, flags])</code> constructor is usually used if the <code>pattern</code> string needs to be interpolated. See the documentation of the string macro for details on flags.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L17-L26" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@r_str" id="Base.@r_str"><code>Base.@r_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@r_str -&gt; Regex</code></pre><p>Construct a regex, such as <code>r"^[a-z]*$"</code>, without interpolation and unescaping (except for quotation mark <code>"</code> which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</p><ul><li><code>i</code> enables case-insensitive matching</li><li><code>m</code> treats the <code>^</code> and <code>$</code> tokens as matching the start and end of individual lines, as opposed to the whole string.</li><li><code>s</code> allows the <code>.</code> modifier to match newlines.</li><li><code>x</code> enables "comment mode": whitespace is enabled except when escaped with <code>\</code>, and <code>#</code> is treated as starting a comment.</li><li><code>a</code> disables <code>UCP</code> mode (enables ASCII mode). By default <code>\B</code>, <code>\b</code>, <code>\D</code>, <code>\d</code>, <code>\S</code>, <code>\s</code>, <code>\W</code>, <code>\w</code>, etc. match based on Unicode character properties. With this option, these sequences only match ASCII characters.</li></ul><p>See <a href="#Base.Regex"><code>Regex</code></a> if interpolation is needed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; match(r"a+.*b+.*?d$"ism, "Goodbye,\nOh, angry,\nBad world\n")
RegexMatch("angry,\nBad world")</code></pre><p>This regex has the first three flags enabled.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L90-L115" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.SubstitutionString" id="Base.SubstitutionString"><code>Base.SubstitutionString</code></a> â <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SubstitutionString(substr)</code></pre><p>Stores the given string <code>substr</code> as a <code>SubstitutionString</code>, for use in regular expression substitutions. Most commonly constructed using the <a href="#Base.@s_str"><code>@s_str</code></a> macro.</p><pre><code class="language-julia-repl">julia&gt; SubstitutionString("Hello \\g&lt;name&gt;, it's \\1")
s"Hello \g&lt;name&gt;, it's \1"

julia&gt; subst = s"Hello \g&lt;name&gt;, it's \1"
s"Hello \g&lt;name&gt;, it's \1"

julia&gt; typeof(subst)
SubstitutionString{String}
</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L429-L447" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@s_str" id="Base.@s_str"><code>Base.@s_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@s_str -&gt; SubstitutionString</code></pre><p>Construct a substitution string, used for regular expression substitutions.  Within the string, sequences of the form <code>\N</code> refer to the Nth capture group in the regex, and <code>\g&lt;groupname&gt;</code> refers to a named capture group with name <code>groupname</code>.</p><pre><code class="language-julia-repl">julia&gt; msg = "#Hello# from Julia";

julia&gt; replace(msg, r"#(.+)# from (?&lt;from&gt;\w+)" =&gt; s"FROM: \g&lt;from&gt;; MESSAGE: \1")
"FROM: Julia; MESSAGE: Hello"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L463-L476" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@raw_str" id="Base.@raw_str"><code>Base.@raw_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@raw_str -&gt; String</code></pre><p>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; println(raw"\ $x")
\ $x

julia&gt; println(raw"\"")
"

julia&gt; println(raw"\\\"")
\"

julia&gt; println(raw"\\x \\\"")
\\x \"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L501-L525" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.@b_str" id="Base.@b_str"><code>Base.@b_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@b_str</code></pre><p>Create an immutable byte (<code>UInt8</code>) vector using string syntax.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; v = b"12\x01\x02"
4-element Base.CodeUnits{UInt8, String}:
 0x31
 0x32
 0x01
 0x02

julia&gt; v[2]
0x32</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L478-L495" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Docs.@html_str" id="Base.Docs.@html_str"><code>Base.Docs.@html_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@html_str -&gt; Docs.HTML</code></pre><p>Create an <code>HTML</code> object from a literal string.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/docs/utils.jl#L37-L41" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Docs.@text_str" id="Base.Docs.@text_str"><code>Base.Docs.@text_str</code></a> â <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@text_str -&gt; Docs.Text</code></pre><p>Create a <code>Text</code> object from a literal string.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/docs/utils.jl#L78-L82" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isvalid-Tuple{Any}" id="Base.isvalid-Tuple{Any}"><code>Base.isvalid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvalid(value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for its type, which currently can be either <code>AbstractChar</code> or <code>String</code> or <code>SubString{String}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isvalid(Char(0xd800))
false

julia&gt; isvalid(SubString(String(UInt8[0xfe,0x80,0x80,0x80,0x80,0x80]),1,2))
false

julia&gt; isvalid(Char(0xd799))
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L11-L28" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isvalid-Tuple{Any, Any}" id="Base.isvalid-Tuple{Any, Any}"><code>Base.isvalid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvalid(T, value) -&gt; Bool</code></pre><p>Returns <code>true</code> if the given value is valid for that type. Types currently can be either <code>AbstractChar</code> or <code>String</code>. Values for <code>AbstractChar</code> can be of type <code>AbstractChar</code> or <a href="../numbers/#Core.UInt32"><code>UInt32</code></a>. Values for <code>String</code> can be of that type, <code>SubString{String}</code>, <code>Vector{UInt8}</code>, or a contiguous subarray thereof.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isvalid(Char, 0xd800)
false

julia&gt; isvalid(String, SubString("thisisvalid",1,5))
true

julia&gt; isvalid(Char, 0xd799)
true</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.6</header><div class="admonition-body"><p>Support for subarray values was added in Julia 1.6.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L31-L53" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isvalid-Tuple{AbstractString, Integer}" id="Base.isvalid-Tuple{AbstractString, Integer}"><code>Base.isvalid</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvalid(s::AbstractString, i::Integer) -&gt; Bool</code></pre><p>Predicate indicating whether the given index is the start of the encoding of a character in <code>s</code> or not. If <code>isvalid(s, i)</code> is true then <code>s[i]</code> will return the character whose encoding starts at that index, if it's false, then <code>s[i]</code> will raise an invalid index error or a bounds error depending on if <code>i</code> is in bounds. In order for <code>isvalid(s, i)</code> to be an O(1) function, the encoding of <code>s</code> must be <a href="https://en.wikipedia.org/wiki/Self-synchronizing_code">self-synchronizing</a>. This is a basic assumption of Julia's generic string support.</p><p>See also: <a href="../collections/#Base.getindex"><code>getindex</code></a>, <a href="../collections/#Base.iterate"><code>iterate</code></a>, <a href="#Base.thisind"><code>thisind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>, <a href="#Base.prevind"><code>prevind</code></a>, <a href="../collections/#Base.length"><code>length</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; str = "Î±Î²Î³def";

julia&gt; isvalid(str, 1)
true

julia&gt; str[1]
'Î±': Unicode U+03B1 (category Ll: Letter, lowercase)

julia&gt; isvalid(str, 2)
false

julia&gt; str[2]
ERROR: StringIndexError: invalid index [2], valid nearby indices [1]=&gt;'Î±', [3]=&gt;'Î²'
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L110-L142" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.match" id="Base.match"><code>Base.match</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">match(r::Regex, s::AbstractString[, idx::Integer[, addopts]])</code></pre><p>Search for the first match of the regular expression <code>r</code> in <code>s</code> and return a <code>RegexMatch</code> object containing the match, or nothing if the match failed. The matching substring can be retrieved by accessing <code>m.match</code> and the captured sequences can be retrieved by accessing <code>m.captures</code> The optional <code>idx</code> argument specifies an index at which to start the search.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rx = r"a(.)a"
r"a(.)a"

julia&gt; m = match(rx, "cabac")
RegexMatch("aba", 1="b")

julia&gt; m.captures
1-element Vector{Union{Nothing, SubString{String}}}:
 "b"

julia&gt; m.match
"aba"

julia&gt; match(rx, "cabac", 3) === nothing
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L265-L291" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.eachmatch" id="Base.eachmatch"><code>Base.eachmatch</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eachmatch(r::Regex, s::AbstractString; overlap::Bool=false)</code></pre><p>Search for all matches of the regular expression <code>r</code> in <code>s</code> and return an iterator over the matches. If <code>overlap</code> is <code>true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from distinct character ranges.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rx = r"a.a"
r"a.a"

julia&gt; m = eachmatch(rx, "a1a2a3a")
Base.RegexMatchIterator(r"a.a", "a1a2a3a", false)

julia&gt; collect(m)
2-element Vector{RegexMatch}:
 RegexMatch("a1a")
 RegexMatch("a3a")

julia&gt; collect(eachmatch(rx, "a1a2a3a", overlap = true))
3-element Vector{RegexMatch}:
 RegexMatch("a1a")
 RegexMatch("a2a")
 RegexMatch("a3a")</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L609-L635" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isless-Tuple{AbstractString, AbstractString}" id="Base.isless-Tuple{AbstractString, AbstractString}"><code>Base.isless</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isless(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether string <code>a</code> comes before string <code>b</code> in alphabetical order (technically, in lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isless("a", "b")
true

julia&gt; isless("Î²", "Î±")
false

julia&gt; isless("a", "a")
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L326-L343" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.:==-Tuple{AbstractString, AbstractString}" id="Base.:==-Tuple{AbstractString, AbstractString}"><code>Base.:==</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(a::AbstractString, b::AbstractString) -&gt; Bool</code></pre><p>Test whether two strings are equal character by character (technically, Unicode code point by code point).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; "abc" == "abc"
true

julia&gt; "abc" == "Î±Î²Î³"
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L309-L323" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.cmp-Tuple{AbstractString, AbstractString}" id="Base.cmp-Tuple{AbstractString, AbstractString}"><code>Base.cmp</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cmp(a::AbstractString, b::AbstractString) -&gt; Int</code></pre><p>Compare two strings. Return <code>0</code> if both strings have the same length and the character at each index is the same in both strings. Return <code>-1</code> if <code>a</code> is a prefix of <code>b</code>, or if <code>a</code> comes before <code>b</code> in alphabetical order. Return <code>1</code> if <code>b</code> is a prefix of <code>a</code>, or if <code>b</code> comes before <code>a</code> in alphabetical order (technically, lexicographical order by Unicode code points).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmp("abc", "abc")
0

julia&gt; cmp("ab", "abc")
-1

julia&gt; cmp("abc", "ab")
1

julia&gt; cmp("ab", "ac")
-1

julia&gt; cmp("ac", "ab")
1

julia&gt; cmp("Î±", "a")
1

julia&gt; cmp("b", "Î²")
-1</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L266-L298" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.lpad" id="Base.lpad"><code>Base.lpad</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the left with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lpad("March", 10)
"     March"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L314-L326" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.rpad" id="Base.rpad"><code>Base.rpad</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rpad(s, n::Integer, p::Union{AbstractChar,AbstractString}=' ') -&gt; String</code></pre><p>Stringify <code>s</code> and pad the resulting string on the right with <code>p</code> to make it <code>n</code> characters (code points) long. If <code>s</code> is already <code>n</code> characters long, an equal string is returned. Pad with spaces by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rpad("March", 20)
"March               "</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L342-L354" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findfirst-Tuple{AbstractString, AbstractString}" id="Base.findfirst-Tuple{AbstractString, AbstractString}"><code>Base.findfirst</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findfirst(pattern::AbstractString, string::AbstractString)
findfirst(pattern::AbstractPattern, string::String)</code></pre><p>Find the first occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="../arrays/#Base.findnext-Tuple{Any, Integer}"><code>findnext(pattern, string, firstindex(s))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findfirst("z", "Hello to the world") # returns nothing, but not printed in the REPL

julia&gt; findfirst("Julia", "JuliaLang")
1:5</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L89-L103" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findnext-Tuple{AbstractString, AbstractString, Integer}" id="Base.findnext-Tuple{AbstractString, AbstractString, Integer}"><code>Base.findnext</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnext(pattern::AbstractString, string::AbstractString, start::Integer)
findnext(pattern::AbstractPattern, string::String, start::Integer)</code></pre><p>Find the next occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>. <code>pattern</code> can be either a string, or a regular expression, in which case <code>string</code> must be of type <code>String</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findnext(x, s, i)] == x</code>:</p><p><code>findnext("substring", string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == "substring"</code> and <code>i &lt;= start</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findnext("z", "Hello to the world", 1) === nothing
true

julia&gt; findnext("o", "Hello to the world", 6)
8:8

julia&gt; findnext("Lang", "JuliaLang", 2)
6:9</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L276-L301" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findnext-Tuple{AbstractChar, AbstractString, Integer}" id="Base.findnext-Tuple{AbstractChar, AbstractString, Integer}"><code>Base.findnext</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnext(ch::AbstractChar, string::AbstractString, start::Integer)</code></pre><p>Find the next occurrence of character <code>ch</code> in <code>string</code> starting at position <code>start</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findnext('z', "Hello to the world", 1) === nothing
true

julia&gt; findnext('o', "Hello to the world", 6)
8</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L304-L320" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findlast-Tuple{AbstractString, AbstractString}" id="Base.findlast-Tuple{AbstractString, AbstractString}"><code>Base.findlast</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findlast(pattern::AbstractString, string::AbstractString)</code></pre><p>Find the last occurrence of <code>pattern</code> in <code>string</code>. Equivalent to <a href="../arrays/#Base.findprev-Tuple{Any, Integer}"><code>findprev(pattern, string, lastindex(string))</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findlast("o", "Hello to the world")
15:15

julia&gt; findfirst("Julia", "JuliaLang")
1:5</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L348-L362" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findlast-Tuple{AbstractChar, AbstractString}" id="Base.findlast-Tuple{AbstractChar, AbstractString}"><code>Base.findlast</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findlast(ch::AbstractChar, string::AbstractString)</code></pre><p>Find the last occurrence of character <code>ch</code> in <code>string</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This method requires at least Julia 1.3.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findlast('p', "happy")
4

julia&gt; findlast('z', "happy") === nothing
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L383-L399" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.findprev-Tuple{AbstractString, AbstractString, Integer}" id="Base.findprev-Tuple{AbstractString, AbstractString, Integer}"><code>Base.findprev</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findprev(pattern::AbstractString, string::AbstractString, start::Integer)</code></pre><p>Find the previous occurrence of <code>pattern</code> in <code>string</code> starting at position <code>start</code>.</p><p>The return value is a range of indices where the matching sequence is found, such that <code>s[findprev(x, s, i)] == x</code>:</p><p><code>findprev("substring", string, i)</code> == <code>start:stop</code> such that <code>string[start:stop] == "substring"</code> and <code>stop &lt;= i</code>, or <code>nothing</code> if unmatched.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findprev("z", "Hello to the world", 18) === nothing
true

julia&gt; findprev("o", "Hello to the world", 18)
15:15

julia&gt; findprev("Julia", "JuliaLang", 6)
1:5</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L533-L555" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.occursin" id="Base.occursin"><code>Base.occursin</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">occursin(needle::Union{AbstractString,AbstractPattern,AbstractChar}, haystack::AbstractString)</code></pre><p>Determine whether the first argument is a substring of the second. If <code>needle</code> is a regular expression, checks whether <code>haystack</code> contains a match.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; occursin("Julia", "JuliaLang is pretty cool!")
true

julia&gt; occursin('a', "JuliaLang is pretty cool!")
true

julia&gt; occursin(r"a.a", "aba")
true

julia&gt; occursin(r"a.a", "abba")
false</code></pre><p>See also: <a href="#Base.contains"><code>contains</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L598-L620" target="_blank">source</a></section><section><div><pre><code class="language-none">occursin(haystack)</code></pre><p>Create a function that checks whether its argument occurs in <code>haystack</code>, i.e. a function equivalent to <code>needle -&gt; occursin(needle, haystack)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(occursin)}</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/search.jl#L624-L631" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.reverse-Tuple{Union{SubString{String}, String}}" id="Base.reverse-Tuple{Union{SubString{String}, String}}"><code>Base.reverse</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reverse(s::AbstractString) -&gt; AbstractString</code></pre><p>Reverses a string. Technically, this function reverses the codepoints in a string and its main utility is for reversed-order string processing, especially for reversed regular-expression searches. See also <a href="../arrays/#Base.reverseind"><code>reverseind</code></a> to convert indices in <code>s</code> to indices in <code>reverse(s)</code> and vice-versa, and <code>graphemes</code> from module <code>Unicode</code> to operate on user-visible "characters" (graphemes) rather than codepoints. See also <a href="../iterators/#Base.Iterators.reverse"><code>Iterators.reverse</code></a> for reverse-order iteration without making a copy. Custom string types must implement the <code>reverse</code> function themselves and should typically return a string with the same type and encoding. If they return a string with a different encoding, they must also override <code>reverseind</code> for that string type to satisfy <code>s[reverseind(s,i)] == reverse(s)[i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reverse("JuliaLang")
"gnaLailuJ"</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The examples below may be rendered differently on different systems. The comments indicate how they're supposed to be rendered</p></div></div><p>Combining characters can lead to surprising results:</p><pre><code class="language-julia-repl">julia&gt; reverse("axÌe") # hat is above x in the input, above e in the output
"eÌxa"

julia&gt; using Unicode

julia&gt; join(reverse(collect(graphemes("axÌe")))) # reverses graphemes; hat is above x in both in- and output
"exÌa"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/substring.jl#L130-L165" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.replace-Tuple{AbstractString, Pair}" id="Base.replace-Tuple{AbstractString, Pair}"><code>Base.replace</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(s::AbstractString, pat=&gt;r; [count::Integer])</code></pre><p>Search for the given pattern <code>pat</code> in <code>s</code>, and replace each occurrence with <code>r</code>. If <code>count</code> is provided, replace at most <code>count</code> occurrences. <code>pat</code> may be a single character, a vector or a set of characters, a string, or a regular expression. If <code>r</code> is a function, each occurrence is replaced with <code>r(s)</code> where <code>s</code> is the matched substring (when <code>pat</code> is a <code>AbstractPattern</code> or <code>AbstractString</code>) or character (when <code>pat</code> is an <code>AbstractChar</code> or a collection of <code>AbstractChar</code>). If <code>pat</code> is a regular expression and <code>r</code> is a <a href="#Base.SubstitutionString"><code>SubstitutionString</code></a>, then capture group references in <code>r</code> are replaced with the corresponding matched text. To remove instances of <code>pat</code> from <code>string</code>, set <code>r</code> to the empty <code>String</code> (<code>""</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace("Python is a programming language.", "Python" =&gt; "Julia")
"Julia is a programming language."

julia&gt; replace("The quick foxes run quickly.", "quick" =&gt; "slow", count=1)
"The slow foxes run quickly."

julia&gt; replace("The quick foxes run quickly.", "quick" =&gt; "", count=1)
"The  foxes run quickly."

julia&gt; replace("The quick foxes run quickly.", r"fox(es)?" =&gt; s"bus\1")
"The quick buses run quickly."</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L561-L589" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.split" id="Base.split"><code>Base.split</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">split(str::AbstractString, dlm; limit::Integer=0, keepempty::Bool=true)
split(str::AbstractString; limit::Integer=0, keepempty::Bool=false)</code></pre><p>Split <code>str</code> into an array of substrings on occurrences of the delimiter(s) <code>dlm</code>.  <code>dlm</code> can be any of the formats allowed by <a href="../arrays/#Base.findnext-Tuple{Any, Integer}"><code>findnext</code></a>'s first argument (i.e. as a string, regular expression or a function), or as a single character or collection of characters.</p><p>If <code>dlm</code> is omitted, it defaults to <a href="#Base.Unicode.isspace"><code>isspace</code></a>.</p><p>The optional keyword arguments are:</p><ul><li><code>limit</code>: the maximum size of the result. <code>limit=0</code> implies no maximum (default)</li><li><code>keepempty</code>: whether empty fields should be kept in the result. Default is <code>false</code> without a <code>dlm</code> argument, <code>true</code> with a <code>dlm</code> argument.</li></ul><p>See also <a href="#Base.rsplit"><code>rsplit</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = "Ma.rch"
"Ma.rch"

julia&gt; split(a, ".")
2-element Vector{SubString{String}}:
 "Ma"
 "rch"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L370-L398" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.rsplit" id="Base.rsplit"><code>Base.rsplit</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rsplit(s::AbstractString; limit::Integer=0, keepempty::Bool=false)
rsplit(s::AbstractString, chars; limit::Integer=0, keepempty::Bool=true)</code></pre><p>Similar to <a href="#Base.split"><code>split</code></a>, but starting from the end of the string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = "M.a.r.c.h"
"M.a.r.c.h"

julia&gt; rsplit(a, ".")
5-element Vector{SubString{String}}:
 "M"
 "a"
 "r"
 "c"
 "h"

julia&gt; rsplit(a, "."; limit=1)
1-element Vector{SubString{String}}:
 "M.a.r.c.h"

julia&gt; rsplit(a, "."; limit=2)
2-element Vector{SubString{String}}:
 "M.a.r.c"
 "h"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L446-L474" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.strip" id="Base.strip"><code>Base.strip</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">strip([pred=isspace,] str::AbstractString) -&gt; SubString
strip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove leading and trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, vector or set of characters.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>The method which accepts a predicate function requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; strip("{3, 5}\n", ['{', '}', '\n'])
"3, 5"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L286-L307" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.lstrip" id="Base.lstrip"><code>Base.lstrip</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lstrip([pred=isspace,] str::AbstractString) -&gt; SubString
lstrip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove leading characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove leading whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = lpad("March", 20)
"               March"

julia&gt; lstrip(a)
"March"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L223-L244" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.rstrip" id="Base.rstrip"><code>Base.rstrip</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rstrip([pred=isspace,] str::AbstractString) -&gt; SubString
rstrip(str::AbstractString, chars) -&gt; SubString</code></pre><p>Remove trailing characters from <code>str</code>, either those specified by <code>chars</code> or those for which the function <code>pred</code> returns <code>true</code>.</p><p>The default behaviour is to remove trailing whitespace and delimiters: see <a href="#Base.Unicode.isspace"><code>isspace</code></a> for precise details.</p><p>The optional <code>chars</code> argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = rpad("March", 20)
"March               "

julia&gt; rstrip(a)
"March"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L255-L276" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.startswith" id="Base.startswith"><code>Base.startswith</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">startswith(s::AbstractString, prefix::AbstractString)</code></pre><p>Return <code>true</code> if <code>s</code> starts with <code>prefix</code>. If <code>prefix</code> is a vector or set of characters, test whether the first character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.endswith"><code>endswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; startswith("JuliaLang", "Julia")
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L7-L20" target="_blank">source</a></section><section><div><pre><code class="language-none">startswith(prefix)</code></pre><p>Create a function that checks whether its argument starts with <code>prefix</code>, i.e. a function equivalent to <code>y -&gt; startswith(y, prefix)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(startswith)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The single argument <code>startswith(prefix)</code> requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; startswith_julia = startswith("Julia");

julia&gt; startswith_julia("Julia")
true

julia&gt; startswith_julia("NotJulia")
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L125-L147" target="_blank">source</a></section><section><div><pre><code class="language-none">startswith(s::AbstractString, prefix::Regex)</code></pre><p>Return <code>true</code> if <code>s</code> starts with the regex pattern, <code>prefix</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>startswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r"^...", s)</code> is faster than <code>startswith(s, r"...")</code>.</p></div></div><p>See also <a href="#Base.occursin"><code>occursin</code></a> and <a href="#Base.endswith"><code>endswith</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires at least Julia 1.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; startswith("JuliaLang", r"Julia|Romeo")
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L201-L222" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.endswith" id="Base.endswith"><code>Base.endswith</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">endswith(s::AbstractString, suffix::AbstractString)</code></pre><p>Return <code>true</code> if <code>s</code> ends with <code>suffix</code>. If <code>suffix</code> is a vector or set of characters, test whether the last character of <code>s</code> belongs to that set.</p><p>See also <a href="#Base.startswith"><code>startswith</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; endswith("Sunday", "day")
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L27-L40" target="_blank">source</a></section><section><div><pre><code class="language-none">endswith(suffix)</code></pre><p>Create a function that checks whether its argument ends with <code>suffix</code>, i.e. a function equivalent to <code>y -&gt; endswith(y, suffix)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(endswith)}</code>, which can be used to implement specialized methods.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The single argument <code>endswith(suffix)</code> requires at least Julia 1.5.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; endswith_julia = endswith("Julia");

julia&gt; endswith_julia("Julia")
true

julia&gt; endswith_julia("JuliaLang")
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L100-L122" target="_blank">source</a></section><section><div><pre><code class="language-none">endswith(s::AbstractString, suffix::Regex)</code></pre><p>Return <code>true</code> if <code>s</code> ends with the regex pattern, <code>suffix</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>endswith</code> does not compile the anchoring into the regular expression, but instead passes the anchoring as <code>match_option</code> to PCRE. If compile time is amortized, <code>occursin(r"...$", s)</code> is faster than <code>endswith(s, r"...")</code>.</p></div></div><p>See also <a href="#Base.occursin"><code>occursin</code></a> and <a href="#Base.startswith"><code>startswith</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires at least Julia 1.2.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; endswith("JuliaLang", r"Lang|Roberts")
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/regex.jl#L233-L254" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.contains" id="Base.contains"><code>Base.contains</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">contains(haystack::AbstractString, needle)</code></pre><p>Return <code>true</code> if <code>haystack</code> contains <code>needle</code>. This is the same as <code>occursin(needle, haystack)</code>, but is provided for consistency with <code>startswith(haystack, needle)</code> and <code>endswith(haystack, needle)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; contains("JuliaLang is pretty cool!", "Julia")
true

julia&gt; contains("JuliaLang is pretty cool!", 'a')
true

julia&gt; contains("aba", r"a.a")
true

julia&gt; contains("abba", r"a.a")
false</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>The <code>contains</code> function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L73-L97" target="_blank">source</a></section><section><div><pre><code class="language-none">contains(needle)</code></pre><p>Create a function that checks whether its argument contains <code>needle</code>, i.e. a function equivalent to <code>haystack -&gt; contains(haystack, needle)</code>.</p><p>The returned function is of type <code>Base.Fix2{typeof(contains)}</code>, which can be used to implement specialized methods.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L150-L158" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.first-Tuple{AbstractString, Integer}" id="Base.first-Tuple{AbstractString, Integer}"><code>Base.first</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">first(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the first <code>n</code> characters of <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; first("âÏµâ 0: ÏµÂ²&gt;0", 0)
""

julia&gt; first("âÏµâ 0: ÏµÂ²&gt;0", 1)
"â"

julia&gt; first("âÏµâ 0: ÏµÂ²&gt;0", 3)
"âÏµâ "</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L632-L648" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.last-Tuple{AbstractString, Integer}" id="Base.last-Tuple{AbstractString, Integer}"><code>Base.last</code></a> â <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">last(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the last <code>n</code> characters of <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; last("âÏµâ 0: ÏµÂ²&gt;0", 0)
""

julia&gt; last("âÏµâ 0: ÏµÂ²&gt;0", 1)
"0"

julia&gt; last("âÏµâ 0: ÏµÂ²&gt;0", 3)
"Â²&gt;0"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L651-L667" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.uppercase" id="Base.Unicode.uppercase"><code>Base.Unicode.uppercase</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uppercase(s::AbstractString)</code></pre><p>Return <code>s</code> with all characters converted to uppercase.</p><p>See also: <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a>, <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; uppercase("Julia")
"JULIA"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L517-L529" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.lowercase" id="Base.Unicode.lowercase"><code>Base.Unicode.lowercase</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lowercase(s::AbstractString)</code></pre><p>Return <code>s</code> with all characters converted to lowercase.</p><p>See also: <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a>, <a href="#Base.Unicode.lowercasefirst"><code>lowercasefirst</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lowercase("STRINGS AND THINGS")
"strings and things"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L532-L544" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.titlecase" id="Base.Unicode.titlecase"><code>Base.Unicode.titlecase</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">titlecase(s::AbstractString; [wordsep::Function], strict::Bool=true) -&gt; String</code></pre><p>Capitalize the first character of each word in <code>s</code>; if <code>strict</code> is true, every other character is converted to lowercase, otherwise they are left unchanged. By default, all non-letters beginning a new grapheme are considered as word separators; a predicate can be passed as the <code>wordsep</code> keyword to determine which characters should be considered as word separators. See also <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a> to capitalize only the first character in <code>s</code>.</p><p>See also: <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; titlecase("the JULIA programming language")
"The Julia Programming Language"

julia&gt; titlecase("ISS - international space station", strict=false)
"ISS - International Space Station"

julia&gt; titlecase("a-a b-b", wordsep = c-&gt;c==' ')
"A-a B-b"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L547-L572" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.uppercasefirst" id="Base.Unicode.uppercasefirst"><code>Base.Unicode.uppercasefirst</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uppercasefirst(s::AbstractString) -&gt; String</code></pre><p>Return <code>s</code> with the first character converted to uppercase (technically "title case" for Unicode). See also <a href="#Base.Unicode.titlecase"><code>titlecase</code></a> to capitalize the first character of every word in <code>s</code>.</p><p>See also: <a href="#Base.Unicode.lowercasefirst"><code>lowercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; uppercasefirst("python")
"Python"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L594-L609" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.lowercasefirst" id="Base.Unicode.lowercasefirst"><code>Base.Unicode.lowercasefirst</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lowercasefirst(s::AbstractString)</code></pre><p>Return <code>s</code> with the first character converted to lowercase.</p><p>See also: <a href="#Base.Unicode.uppercasefirst"><code>uppercasefirst</code></a>, <a href="#Base.Unicode.uppercase"><code>uppercase</code></a>, <a href="#Base.Unicode.lowercase"><code>lowercase</code></a>, <a href="#Base.Unicode.titlecase"><code>titlecase</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lowercasefirst("Julia")
"julia"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L618-L631" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.join" id="Base.join"><code>Base.join</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">join([io::IO,] strings [, delim [, last]])</code></pre><p>Join an array of <code>strings</code> into a single string, inserting the given delimiter (if any) between adjacent strings. If <code>last</code> is given, it will be used instead of <code>delim</code> between the last two strings. If <code>io</code> is given, the result is written to <code>io</code> rather than returned as a <code>String</code>.</p><p><code>strings</code> can be any iterable over elements <code>x</code> which are convertible to strings via <code>print(io::IOBuffer, x)</code>. <code>strings</code> will be printed to <code>io</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; join(["apples", "bananas", "pineapples"], ", ", " and ")
"apples, bananas and pineapples"

julia&gt; join([1,2,3,4,5])
"12345"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L256-L275" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.chop" id="Base.chop"><code>Base.chop</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">chop(s::AbstractString; head::Integer = 0, tail::Integer = 1)</code></pre><p>Remove the first <code>head</code> and the last <code>tail</code> characters from <code>s</code>. The call <code>chop(s)</code> removes the last character from <code>s</code>. If it is requested to remove more characters than <code>length(s)</code> then an empty string is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = "March"
"March"

julia&gt; chop(a)
"Marc"

julia&gt; chop(a, head = 1, tail = 2)
"ar"

julia&gt; chop(a, head = 5, tail = 5)
""</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L161-L183" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.chomp" id="Base.chomp"><code>Base.chomp</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">chomp(s::AbstractString) -&gt; SubString</code></pre><p>Remove a single trailing newline from a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; chomp("Hello\n")
"Hello"</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/util.jl#L194-L204" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.thisind" id="Base.thisind"><code>Base.thisind</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thisind(s::AbstractString, i::Integer) -&gt; Int</code></pre><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding code unit <code>i</code> is part of. In other words, if <code>i</code> is the start of a character, return <code>i</code>; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to 0 or <code>ncodeunits(s)+1</code> return <code>i</code>. In all other cases throw <code>BoundsError</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; thisind("Î±", 0)
0

julia&gt; thisind("Î±", 1)
1

julia&gt; thisind("Î±", 2)
1

julia&gt; thisind("Î±", 3)
3

julia&gt; thisind("Î±", 4)
ERROR: BoundsError: attempt to access 2-codeunit String at index [4]
[...]

julia&gt; thisind("Î±", -1)
ERROR: BoundsError: attempt to access 2-codeunit String at index [-1]
[...]</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L404-L435" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.nextind" id="Base.nextind"><code>Base.nextind</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts after index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the next character; if <code>i</code> is not the start of a character, move forward until the start of a character and return that index. If <code>i</code> is equal to <code>0</code> return <code>1</code>. If <code>i</code> is in bounds but greater or equal to <code>lastindex(str)</code> return <code>ncodeunits(str)+1</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>nextind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>nextind</code> would reach <code>ncodeunits(str)+1</code> then each remaining iteration increases the returned value by <code>1</code>. This means that in this case <code>nextind</code> can return a value greater than <code>ncodeunits(str)+1</code>.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>s</code> or is equal to <code>0</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nextind("Î±", 0)
1

julia&gt; nextind("Î±", 1)
3

julia&gt; nextind("Î±", 3)
ERROR: BoundsError: attempt to access 2-codeunit String at index [3]
[...]

julia&gt; nextind("Î±", 0, 2)
3

julia&gt; nextind("Î±", 1, 2)
4</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L507-L550" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.prevind" id="Base.prevind"><code>Base.prevind</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prevind(str::AbstractString, i::Integer, n::Integer=1) -&gt; Int</code></pre><ul><li><p>Case <code>n == 1</code></p><p>If <code>i</code> is in bounds in <code>s</code> return the index of the start of the character whose encoding starts before index <code>i</code>. In other words, if <code>i</code> is the start of a character, return the start of the previous character; if <code>i</code> is not the start of a character, rewind until the start of a character and return that index. If <code>i</code> is equal to <code>1</code> return <code>0</code>. If <code>i</code> is equal to <code>ncodeunits(str)+1</code> return <code>lastindex(str)</code>. Otherwise throw <code>BoundsError</code>.</p></li><li><p>Case <code>n &gt; 1</code></p><p>Behaves like applying <code>n</code> times <code>prevind</code> for <code>n==1</code>. The only difference is that if <code>n</code> is so large that applying <code>prevind</code> would reach <code>0</code> then each remaining iteration decreases the returned value by <code>1</code>. This means that in this case <code>prevind</code> can return a negative value.</p></li><li><p>Case <code>n == 0</code></p><p>Return <code>i</code> only if <code>i</code> is a valid index in <code>str</code> or is equal to <code>ncodeunits(str)+1</code>. Otherwise <code>StringIndexError</code> or <code>BoundsError</code> is thrown.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prevind("Î±", 3)
1

julia&gt; prevind("Î±", 1)
0

julia&gt; prevind("Î±", 0)
ERROR: BoundsError: attempt to access 2-codeunit String at index [0]
[...]

julia&gt; prevind("Î±", 2, 2)
0

julia&gt; prevind("Î±", 2, 3)
-1</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L448-L491" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.textwidth" id="Base.Unicode.textwidth"><code>Base.Unicode.textwidth</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">textwidth(c)</code></pre><p>Give the number of columns needed to print a character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; textwidth('Î±')
1

julia&gt; textwidth('âµ')
2</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L217-L230" target="_blank">source</a></section><section><div><pre><code class="language-none">textwidth(s::AbstractString)</code></pre><p>Give the number of columns needed to print a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; textwidth("March")
5</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L236-L246" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.isascii" id="Base.isascii"><code>Base.isascii</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isascii(c::Union{AbstractChar,AbstractString}) -&gt; Bool</code></pre><p>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isascii('a')
true

julia&gt; isascii('Î±')
false

julia&gt; isascii("abc")
true

julia&gt; isascii("Î±Î²Î³")
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/basic.jl#L579-L599" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.iscntrl" id="Base.Unicode.iscntrl"><code>Base.Unicode.iscntrl</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iscntrl(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; iscntrl('\x01')
true

julia&gt; iscntrl('a')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L415-L429" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isdigit" id="Base.Unicode.isdigit"><code>Base.Unicode.isdigit</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isdigit(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a decimal digit (0-9).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isdigit('â¤')
false

julia&gt; isdigit('9')
true

julia&gt; isdigit('Î±')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L346-L362" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isletter" id="Base.Unicode.isletter"><code>Base.Unicode.isletter</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isletter(c::AbstractChar) -&gt; Bool</code></pre><p>Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isletter('â¤')
false

julia&gt; isletter('Î±')
true

julia&gt; isletter('9')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L365-L383" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.islowercase" id="Base.Unicode.islowercase"><code>Base.Unicode.islowercase</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">islowercase(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</p><p>See also: <a href="#Base.Unicode.isuppercase"><code>isuppercase</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; islowercase('Î±')
true

julia&gt; islowercase('Î')
false

julia&gt; islowercase('â¤')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L280-L300" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isnumeric" id="Base.Unicode.isnumeric"><code>Base.Unicode.isnumeric</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnumeric(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</p><p>Note that this broad category includes characters such as Â¾ and à¯°. Use <a href="#Base.Unicode.isdigit"><code>isdigit</code></a> to check whether a character a decimal digit between 0 and 9.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isnumeric('à¯°')
true

julia&gt; isnumeric('9')
true

julia&gt; isnumeric('Î±')
false

julia&gt; isnumeric('â¤')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L386-L410" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isprint" id="Base.Unicode.isprint"><code>Base.Unicode.isprint</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isprint(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is printable, including spaces, but not a control character.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isprint('\x01')
false

julia&gt; isprint('A')
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L480-L493" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.ispunct" id="Base.Unicode.ispunct"><code>Base.Unicode.ispunct</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ispunct(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ispunct('Î±')
false

julia&gt; ispunct('/')
true

julia&gt; ispunct(';')
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L432-L449" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isspace" id="Base.Unicode.isspace"><code>Base.Unicode.isspace</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isspace(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isspace('\n')
true

julia&gt; isspace('\r')
true

julia&gt; isspace(' ')
true

julia&gt; isspace('\x20')
true</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L454-L475" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isuppercase" id="Base.Unicode.isuppercase"><code>Base.Unicode.isuppercase</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isuppercase(c::AbstractChar) -&gt; Bool</code></pre><p>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</p><p>See also: <a href="#Base.Unicode.islowercase"><code>islowercase</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isuppercase('Î³')
false

julia&gt; isuppercase('Î')
true

julia&gt; isuppercase('â¤')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L305-L325" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.Unicode.isxdigit" id="Base.Unicode.isxdigit"><code>Base.Unicode.isxdigit</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isxdigit(c::AbstractChar) -&gt; Bool</code></pre><p>Test whether a character is a valid hexadecimal digit. Note that this does not include <code>x</code> (as in the standard <code>0x</code> prefix).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isxdigit('a')
true

julia&gt; isxdigit('x')
false</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/unicode.jl#L498-L512" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.escape_string" id="Base.escape_string"><code>Base.escape_string</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escape_string(str::AbstractString[, esc])::AbstractString
escape_string(io, str::AbstractString[, esc::])::Nothing</code></pre><p>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>.</p><p>Backslashes (<code>\</code>) are escaped with a double-backslash (<code>"\\"</code>). Non-printable characters are escaped either with their standard C escape codes, <code>"\0"</code> for NUL (if unambiguous), unicode code point (<code>"\u"</code> prefix) or hex (<code>"\x"</code> prefix).</p><p>The optional <code>esc</code> argument specifies any additional characters that should also be escaped by a prepending backslash (<code>"</code> is also escaped by default in the first form).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; escape_string("aaa\nbbb")
"aaa\\nbbb"

julia&gt; escape_string("\xfe\xff") # invalid utf-8
"\\xfe\\xff"

julia&gt; escape_string(string('\u2135','\0')) # unambiguous
"âµ\\0"

julia&gt; escape_string(string('\u2135','\0','0')) # \0 would be ambiguous
"âµ\\x000"</code></pre><p><strong>See also</strong></p><p><a href="#Base.unescape_string"><code>unescape_string</code></a> for the reverse operation.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L312-L343" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#Base.unescape_string" id="Base.unescape_string"><code>Base.unescape_string</code></a> â <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unescape_string(str::AbstractString, keep = ())::AbstractString
unescape_string(io, s::AbstractString, keep = ())::Nothing</code></pre><p>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to <code>io</code>. The argument <code>keep</code> specifies a collection of characters which (along with backlashes) are to be kept as they are.</p><p>The following escape sequences are recognised:</p><ul><li>Escaped backslash (<code>\\</code>)</li><li>Escaped double-quote (<code>\"</code>)</li><li>Standard C escape sequences (<code>\a</code>, <code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code>, <code>\e</code>)</li><li>Unicode BMP code points (<code>\u</code> with 1-4 trailing hex digits)</li><li>All Unicode code points (<code>\U</code> with 1-8 trailing hex digits; max value = 0010ffff)</li><li>Hex bytes (<code>\x</code> with 1-2 trailing hex digits)</li><li>Octal bytes (<code>\</code> with 1-3 trailing octal digits)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unescape_string("aaa\\nbbb") # C escape sequence
"aaa\nbbb"

julia&gt; unescape_string("\\u03c0") # unicode
"Ï"

julia&gt; unescape_string("\\101") # octal
"A"

julia&gt; unescape_string("aaa \\g \\n", ['g']) # using `keep` argument
"aaa \\g \n"</code></pre><p><strong>See also</strong></p><p><a href="#Base.escape_string"><code>escape_string</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaLang/julia/blob/599d3299c9666d8aae13843c3551eaeb2d25f07d/base/strings/io.jl#L382-L417" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../numbers/">Â« Numbers</a><a class="docs-footer-nextpage" href="../arrays/">Arrays Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 9 December 2020 09:12">Wednesday 9 December 2020</span>. Using Julia version 1.6.0-DEV.1722.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>