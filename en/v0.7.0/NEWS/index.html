<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia v0.7.0 Release Notes Â· The Julia Language</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-28835595-6', 'auto');
ga('send', 'pageview', {'page': location.pathname+location.search+location.hash});
</script><link rel="canonical" href="https://docs.julialang.org/en/stable/NEWS/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="The Julia Language logo"/></a><h1>The Julia Language</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Julia v0.7.0 Release Notes</a><ul class="internal"><li><a class="toctext" href="#New-language-features-1">New language features</a></li><li><a class="toctext" href="#Language-changes-1">Language changes</a></li><li><a class="toctext" href="#Breaking-changes-1">Breaking changes</a></li><li><a class="toctext" href="#Library-improvements-1">Library improvements</a></li><li><a class="toctext" href="#Compiler/Runtime-improvements-1">Compiler/Runtime improvements</a></li><li><a class="toctext" href="#Deprecated-or-removed-1">Deprecated or removed</a></li><li><a class="toctext" href="#Command-line-option-changes-1">Command-line option changes</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../manual/getting-started/">Getting Started</a></li><li><a class="toctext" href="../manual/variables/">Variables</a></li><li><a class="toctext" href="../manual/integers-and-floating-point-numbers/">Integers and Floating-Point Numbers</a></li><li><a class="toctext" href="../manual/mathematical-operations/">Mathematical Operations and Elementary Functions</a></li><li><a class="toctext" href="../manual/complex-and-rational-numbers/">Complex and Rational Numbers</a></li><li><a class="toctext" href="../manual/strings/">Strings</a></li><li><a class="toctext" href="../manual/functions/">Functions</a></li><li><a class="toctext" href="../manual/control-flow/">Control Flow</a></li><li><a class="toctext" href="../manual/variables-and-scoping/">Scope of Variables</a></li><li><a class="toctext" href="../manual/types/">Types</a></li><li><a class="toctext" href="../manual/methods/">Methods</a></li><li><a class="toctext" href="../manual/constructors/">Constructors</a></li><li><a class="toctext" href="../manual/conversion-and-promotion/">Conversion and Promotion</a></li><li><a class="toctext" href="../manual/interfaces/">Interfaces</a></li><li><a class="toctext" href="../manual/modules/">Modules</a></li><li><a class="toctext" href="../manual/documentation/">Documentation</a></li><li><a class="toctext" href="../manual/metaprogramming/">Metaprogramming</a></li><li><a class="toctext" href="../manual/arrays/">Multi-dimensional Arrays</a></li><li><a class="toctext" href="../manual/missing/">Missing Values</a></li><li><a class="toctext" href="../manual/networking-and-streams/">Networking and Streams</a></li><li><a class="toctext" href="../manual/parallel-computing/">Parallel Computing</a></li><li><a class="toctext" href="../manual/running-external-programs/">Running External Programs</a></li><li><a class="toctext" href="../manual/calling-c-and-fortran-code/">Calling C and Fortran Code</a></li><li><a class="toctext" href="../manual/handling-operating-system-variation/">Handling Operating System Variation</a></li><li><a class="toctext" href="../manual/environment-variables/">Environment Variables</a></li><li><a class="toctext" href="../manual/embedding/">Embedding Julia</a></li><li><a class="toctext" href="../manual/code-loading/">Code Loading</a></li><li><a class="toctext" href="../manual/profile/">Profiling</a></li><li><a class="toctext" href="../manual/stacktraces/">Stack Traces</a></li><li><a class="toctext" href="../manual/performance-tips/">Performance Tips</a></li><li><a class="toctext" href="../manual/workflow-tips/">Workflow Tips</a></li><li><a class="toctext" href="../manual/style-guide/">Style Guide</a></li><li><a class="toctext" href="../manual/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></li><li><a class="toctext" href="../manual/unicode-input/">Unicode Input</a></li></ul></li><li><span class="toctext">Base</span><ul><li><a class="toctext" href="../base/base/">Essentials</a></li><li><a class="toctext" href="../base/collections/">Collections and Data Structures</a></li><li><a class="toctext" href="../base/math/">Mathematics</a></li><li><a class="toctext" href="../base/numbers/">Numbers</a></li><li><a class="toctext" href="../base/strings/">Strings</a></li><li><a class="toctext" href="../base/arrays/">Arrays</a></li><li><a class="toctext" href="../base/parallel/">Tasks</a></li><li><a class="toctext" href="../base/multi-threading/">Multi-Threading</a></li><li><a class="toctext" href="../base/constants/">Constants</a></li><li><a class="toctext" href="../base/file/">Filesystem</a></li><li><a class="toctext" href="../base/io-network/">I/O and Network</a></li><li><a class="toctext" href="../base/punctuation/">Punctuation</a></li><li><a class="toctext" href="../base/sort/">Sorting and Related Functions</a></li><li><a class="toctext" href="../base/iterators/">Iteration utilities</a></li><li><a class="toctext" href="../base/c/">C Interface</a></li><li><a class="toctext" href="../base/libc/">C Standard Library</a></li><li><a class="toctext" href="../base/stacktraces/">StackTraces</a></li><li><a class="toctext" href="../base/simd-types/">SIMD Support</a></li></ul></li><li><span class="toctext">Standard Library</span><ul><li><a class="toctext" href="../stdlib/Base64/">Base64</a></li><li><a class="toctext" href="../stdlib/CRC32c/">CRC32c</a></li><li><a class="toctext" href="../stdlib/Dates/">Dates</a></li><li><a class="toctext" href="../stdlib/DelimitedFiles/">Delimited Files</a></li><li><a class="toctext" href="../stdlib/Distributed/">Distributed Computing</a></li><li><a class="toctext" href="../stdlib/FileWatching/">File Events</a></li><li><a class="toctext" href="../stdlib/InteractiveUtils/">Interactive Utilities</a></li><li><a class="toctext" href="../stdlib/LibGit2/">LibGit2</a></li><li><a class="toctext" href="../stdlib/Libdl/">Dynamic Linker</a></li><li><a class="toctext" href="../stdlib/LinearAlgebra/">Linear Algebra</a></li><li><a class="toctext" href="../stdlib/Logging/">Logging</a></li><li><a class="toctext" href="../stdlib/Markdown/">Markdown</a></li><li><a class="toctext" href="../stdlib/Mmap/">Memory-mapped I/O</a></li><li><a class="toctext" href="../stdlib/Pkg/">Pkg</a></li><li><a class="toctext" href="../stdlib/Printf/">Printf</a></li><li><a class="toctext" href="../stdlib/Profile/">Profiling</a></li><li><a class="toctext" href="../stdlib/REPL/">The Julia REPL</a></li><li><a class="toctext" href="../stdlib/Random/">Random Numbers</a></li><li><a class="toctext" href="../stdlib/SHA/">SHA</a></li><li><a class="toctext" href="../stdlib/Serialization/">Serialization</a></li><li><a class="toctext" href="../stdlib/SharedArrays/">Shared Arrays</a></li><li><a class="toctext" href="../stdlib/Sockets/">Sockets</a></li><li><a class="toctext" href="../stdlib/SparseArrays/">Sparse Arrays</a></li><li><a class="toctext" href="../stdlib/Statistics/">Statistics</a></li><li><a class="toctext" href="../stdlib/Test/">Unit Testing</a></li><li><a class="toctext" href="../stdlib/UUIDs/">UUIDs</a></li><li><a class="toctext" href="../stdlib/Unicode/">Unicode</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../devdocs/reflection/">Reflection and introspection</a></li><li><span class="toctext">Documentation of Julia&#39;s Internals</span><ul><li><a class="toctext" href="../devdocs/init/">Initialization of the Julia runtime</a></li><li><a class="toctext" href="../devdocs/ast/">Julia ASTs</a></li><li><a class="toctext" href="../devdocs/types/">More about types</a></li><li><a class="toctext" href="../devdocs/object/">Memory layout of Julia Objects</a></li><li><a class="toctext" href="../devdocs/eval/">Eval of Julia code</a></li><li><a class="toctext" href="../devdocs/callconv/">Calling Conventions</a></li><li><a class="toctext" href="../devdocs/compiler/">High-level Overview of the Native-Code Generation Process</a></li><li><a class="toctext" href="../devdocs/functions/">Julia Functions</a></li><li><a class="toctext" href="../devdocs/cartesian/">Base.Cartesian</a></li><li><a class="toctext" href="../devdocs/meta/">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="toctext" href="../devdocs/subarrays/">SubArrays</a></li><li><a class="toctext" href="../devdocs/isbitsunionarrays/">isbits Union Optimizations</a></li><li><a class="toctext" href="../devdocs/sysimg/">System Image Building</a></li><li><a class="toctext" href="../devdocs/llvm/">Working with LLVM</a></li><li><a class="toctext" href="../devdocs/stdio/">printf() and stdio in the Julia runtime</a></li><li><a class="toctext" href="../devdocs/boundscheck/">Bounds checking</a></li><li><a class="toctext" href="../devdocs/locks/">Proper maintenance and care of multi-threading locks</a></li><li><a class="toctext" href="../devdocs/offset-arrays/">Arrays with custom indices</a></li><li><a class="toctext" href="../devdocs/require/">Module loading</a></li><li><a class="toctext" href="../devdocs/inference/">Inference</a></li></ul></li><li><span class="toctext">Developing/debugging Julia&#39;s C code</span><ul><li><a class="toctext" href="../devdocs/backtraces/">Reporting and analyzing crashes (segfaults)</a></li><li><a class="toctext" href="../devdocs/debuggingtips/">gdb debugging tips</a></li><li><a class="toctext" href="../devdocs/valgrind/">Using Valgrind with Julia</a></li><li><a class="toctext" href="../devdocs/sanitizers/">Sanitizer support</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Julia v0.7.0 Release Notes</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/julia/blob/master/doc/src/NEWS.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Julia v0.7.0 Release Notes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Julia-v0.7.0-Release-Notes-1" href="#Julia-v0.7.0-Release-Notes-1">Julia v0.7.0 Release Notes</a></h1><h2><a class="nav-anchor" id="New-language-features-1" href="#New-language-features-1">New language features</a></h2><ul><li><p>Local variables can be tested for being defined using the new <code>@isdefined variable</code> macro (<a href="https://github.com/JuliaLang/julia/issues/22281">#22281</a>).</p></li><li><p>Destructuring in function arguments: when an expression such as <code>(x, y)</code> is used as a function argument name, the argument is unpacked into local variables <code>x</code> and <code>y</code> as in the assignment <code>(x, y) = arg</code> (<a href="https://github.com/JuliaLang/julia/issues/6614">#6614</a>).</p></li><li><p>Named tuples, with the syntax <code>(a=1, b=2)</code>. These behave very similarly to tuples, except components can also be accessed by name using dot syntax <code>t.a</code> (<a href="https://github.com/JuliaLang/julia/issues/22194">#22194</a>).</p></li><li><p>Keyword argument containers (<code>kw</code> in <code>f(; kw...)</code>) are now based on named tuples. Dictionary functions like <code>haskey</code> and indexing can be used on them, and name-value pairs can be iterated using <code>pairs(kw)</code>. <code>kw</code> can no longer contain multiple entries for the same argument name (<a href="https://github.com/JuliaLang/julia/issues/4916">#4916</a>).</p></li><li><p>Custom infix operators can now be defined by appending Unicode combining marks, primes, and sub/superscripts to other operators. For example, <code>+Ìââ³</code> is parsed as an infix operator with the same precedence as <code>+</code> (<a href="https://github.com/JuliaLang/julia/issues/22089">#22089</a>).</p></li><li><p>The macro call syntax <code>@macroname[args]</code> is now available and is parsed as <code>@macroname([args])</code> (<a href="https://github.com/JuliaLang/julia/issues/23519">#23519</a>).</p></li><li><p>The construct <code>if @generated ...; else ...; end</code> can be used to provide both <code>@generated</code> and normal implementations of part of a function. Surrounding code will be common to both versions (<a href="https://github.com/JuliaLang/julia/issues/23168">#23168</a>).</p></li><li><p>Added <code>â</code> (<code>\perp</code>) operator with comparison precedence (<a href="https://github.com/JuliaLang/julia/issues/24404">#24404</a>).</p></li><li><p>The <code>missing</code> singleton object (of type <code>Missing</code>) has been added to represent missing values (<a href="https://github.com/JuliaLang/julia/issues/24653">#24653</a>). It propagates through standard operators and mathematical functions, and implements three-valued logic, similar to SQLs <code>NULL</code> and R&#39;s <code>NA</code>.</p></li><li><p>Field access via dot-syntax can now be overloaded by adding methods to <code>Base.getproperty</code> and <code>Base.setproperty!</code> (<a href="https://github.com/JuliaLang/julia/issues/1974">#1974</a>), optionally along with a corresponding <code>Base.propertynames</code> method for reflection (<a href="https://github.com/JuliaLang/julia/issues/25311">#25311</a>).</p></li><li><p>Values for <code>Enum</code>s can now be specified inside of a <code>begin</code> block when using the <code>@enum</code> macro (<a href="https://github.com/JuliaLang/julia/issues/25424">#25424</a>).</p></li><li><p>Keyword arguments can be required: if a default value is omitted, then an exception is thrown if the caller does not assign the keyword a value (<a href="https://github.com/JuliaLang/julia/issues/25830">#25830</a>).</p></li><li><p>The pair operator <code>=&gt;</code> is now broadcastable as <code>.=&gt;</code> which was previously a parsing error (<a href="https://github.com/JuliaLang/julia/issues/27447">#27447</a>)</p></li></ul><h2><a class="nav-anchor" id="Language-changes-1" href="#Language-changes-1">Language changes</a></h2><ul><li><p>The syntax for parametric methods, <code>function f{T}(x::T)</code>, has been changed to <code>function f(x::T) where {T}</code> (<a href="https://github.com/JuliaLang/julia/issues/11310">#11310</a>).</p></li><li><p>The fallback constructor that calls <code>convert</code> is deprecated. Instead, new types should prefer to define constructors, and add <code>convert</code> methods that call those constructors only as necessary (<a href="https://github.com/JuliaLang/julia/issues/15120">#15120</a>).</p></li><li><p>The syntax <code>1.+2</code> is deprecated, since it is ambiguous: it could mean either <code>1 .+ 2</code> (the current meaning) or <code>1. + 2</code> (<a href="https://github.com/JuliaLang/julia/issues/19089">#19089</a>).</p></li><li><p>Mutable structs with no fields are no longer singletons; it is now possible to make multiple instances of them that can be distinguished by <code>===</code> (<a href="https://github.com/JuliaLang/julia/issues/25854">#25854</a>). Zero-size immutable structs are still singletons.</p></li><li><p>In string and character literals, backslash <code>\</code> may no longer precede unrecognized escape characters (<a href="https://github.com/JuliaLang/julia/issues/22800">#22800</a>).</p></li><li><p>Juxtaposing binary, octal, and hexadecimal literals is deprecated, since it can lead to confusing code such as <code>0xapi == 0xa * pi</code> (<a href="https://github.com/JuliaLang/julia/issues/16356">#16356</a>).</p></li><li><p>Numeric literal juxtaposition now has slighty lower precedence than unary operators, so for example <code>â2x</code> parses as <code>(â2) * x</code> (<a href="https://github.com/JuliaLang/julia/issues/27641">#27641</a>).</p></li><li><p>Declaring arguments as <code>x::ANY</code> to avoid specialization has been replaced by <code>@nospecialize x</code>. (<a href="https://github.com/JuliaLang/julia/issues/22666">#22666</a>).</p><p>This can also be used in global scope, to apply to all subsequent method definitions in the module (until <code>@specialize</code>). (<a href="https://github.com/JuliaLang/julia/issues/28065">#28065</a>)</p></li><li><p>Keyword argument default values are now evaluated in successive scopes â- the scope for each expression includes only previous keyword arguments, in left-to-right order (<a href="https://github.com/JuliaLang/julia/issues/17240">#17240</a>).</p></li><li><p>The parsing of <code>1&lt;&lt;2*3</code> as <code>1&lt;&lt;(2*3)</code> is deprecated, and will change to <code>(1&lt;&lt;2)*3</code> in a future version (<a href="https://github.com/JuliaLang/julia/issues/13079">#13079</a>).</p></li><li><p>The parsing of <code>&lt;|</code> is now right associative. <code>|&gt;</code> remains left associative (<a href="https://github.com/JuliaLang/julia/issues/24153">#24153</a>).</p></li><li><p><code>:</code> now parses like other operators, as a call to a function named <code>:</code>, instead of calling <code>colon</code> (<a href="https://github.com/JuliaLang/julia/issues/25947">#25947</a>).</p></li><li><p><code>{ }</code> expressions now use <code>braces</code> and <code>bracescat</code> as expression heads instead of <code>cell1d</code> and <code>cell2d</code>, and parse similarly to <code>vect</code> and <code>vcat</code> (<a href="https://github.com/JuliaLang/julia/issues/8470">#8470</a>).</p></li><li><p>Nested <code>if</code> expressions that arise from the keyword <code>elseif</code> now use <code>elseif</code> as their expression head instead of <code>if</code> (<a href="https://github.com/JuliaLang/julia/issues/21774">#21774</a>).</p></li><li><p><code>let</code> blocks now parse the same as <code>for</code> loops; the first argument is either an assignment or <code>block</code> of assignments, and the second argument is a block of statements (<a href="https://github.com/JuliaLang/julia/issues/21774">#21774</a>).</p></li><li><p><code>do</code> syntax now parses to an expression with head <code>:do</code>, instead of as a function call (<a href="https://github.com/JuliaLang/julia/issues/21774">#21774</a>).</p></li><li><p>Parsed and lowered forms of type definitions have been synchronized with their new keywords (<a href="https://github.com/JuliaLang/julia/issues/23157">#23157</a>). Expression heads are renamed as follows:</p><ul><li><p><code>type</code>           =&gt; <code>struct</code></p></li><li><p><code>bitstype</code>       =&gt; <code>primitive</code> (order of arguments is also reversed, to match syntax)</p></li><li><p><code>composite_type</code> =&gt; <code>struct_type</code></p></li><li><p><code>bits_type</code>      =&gt; <code>primitive_type</code></p></li></ul></li><li><p>The <code>global</code> keyword now only introduces a new binding if one doesn&#39;t already exist in the module. This means that assignment to a global (<code>global sin = 3</code>) may now throw the error: &quot;cannot assign variable Base.sin from module Main&quot;, rather than emitting a warning. Additionally, the new bindings are now created before the statement is executed. For example, <code>f() = (global sin = &quot;gluttony&quot;; nothing)</code> will now resolve which module contains <code>sin</code> eagerly, rather than delaying that decision until <code>f</code> is run. (<a href="https://github.com/JuliaLang/julia/issues/22984">#22984</a>).</p></li><li><p><code>global const</code> declarations may no longer appear inside functions (<a href="https://github.com/JuliaLang/julia/issues/12010">#12010</a>).</p></li><li><p>Uninitialized <code>BitArray</code> constructors of the form <code>BitArray[{N}](shape...)</code> have been deprecated in favor of equivalents accepting <code>undef</code> (an alias for <code>UndefInitializer()</code>) as their first argument, as in <code>BitArray[{N}](undef, shape...)</code>. For example, <code>BitVector(3)</code> is now <code>BitVector(undef, 3)</code>, <code>BitMatrix((2, 4))</code> is now <code>BitMatrix(undef, (2, 4))</code>, and <code>BitArray{3}(11, 13, 17)</code> is now <code>BitArray{3}(undef, 11, 14, 17)</code> (<a href="https://github.com/JuliaLang/julia/issues/24785">#24785</a>).</p></li><li><p>Dispatch rules have been simplified: method matching is now determined exclusively by subtyping; the rule that method type parameters must also be captured has been removed. Instead, attempting to access the unconstrained parameters will throw an <code>UndefVarError</code>. Linting in package tests is recommended to confirm that the set of methods which might throw <code>UndefVarError</code> when accessing the static parameters (<code>need_to_handle_undef_sparam = Set{Any}(m.sig for m in Test.detect_unbound_args(Base, recursive=true))</code>) is equal (<code>==</code>) to some known set (<code>expected = Set()</code>). (<a href="https://github.com/JuliaLang/julia/issues/23117">#23117</a>)</p></li><li><p><code>const</code> declarations on local variables were previously ignored. They now give a warning, so that this syntax can be disallowed or given a new meaning in a future version (<a href="https://github.com/JuliaLang/julia/issues/5148">#5148</a>).</p></li><li><p>Placing an expression after <code>catch</code>, as in <code>catch f(x)</code>, is deprecated. Use <code>catch; f(x)</code> instead (<a href="https://github.com/JuliaLang/julia/issues/19987">#19987</a>).</p></li><li><p>In <code>for i = ...</code>, if a local variable <code>i</code> already existed it would be overwritten during the loop. This behavior is deprecated, and in the future <code>for</code> loop variables will always be new variables local to the loop (<a href="https://github.com/JuliaLang/julia/issues/22314">#22314</a>). The old behavior of overwriting an existing variable is available via <code>for outer i = ...</code>.</p></li><li><p>In <code>for i in x</code>, <code>x</code> used to be evaluated in a new scope enclosing the <code>for</code> loop. Now it is evaluated in the scope outside the <code>for</code> loop.</p></li><li><p>In <code>for i in x, j in y</code>, all variables now have fresh bindings on each iteration of the innermost loop. For example, an assignment to <code>i</code> will not be visible on the next <code>j</code> loop iteration (<a href="https://github.com/JuliaLang/julia/issues/330">#330</a>).</p></li><li><p>Variable bindings local to <code>while</code> loop bodies are now freshly allocated on each loop iteration, matching the behavior of <code>for</code> loops.</p></li><li><p>Prefix <code>&amp;</code> for by-reference arguments to <code>ccall</code> has been deprecated in favor of <code>Ref</code> argument types (<a href="https://github.com/JuliaLang/julia/issues/6080">#6080</a>).</p></li><li><p>The constructor <code>Ref(x::T)</code> now always returns a <code>Ref{T}</code> (<a href="https://github.com/JuliaLang/julia/issues/21527">#21527</a>).</p></li><li><p>All line numbers in ASTs are represented by <code>LineNumberNode</code>s; the <code>:line</code> expression head is no longer used. <code>QuoteNode</code>s are also consistently used for quoted symbols instead of the <code>:quote</code> expression head (though <code>:quote</code> <code>Expr</code>s are still used for quoted expressions) (<a href="https://github.com/JuliaLang/julia/issues/23885">#23885</a>).</p></li><li><p>The <code>+</code> and <code>-</code> methods for <code>Number</code> and <code>UniformScaling</code> are not ambiguous anymore since <code>+</code> and <code>-</code> no longer do automatic broadcasting. Hence, the methods for <code>UniformScaling</code> and <code>Number</code> are no longer deprecated (<a href="https://github.com/JuliaLang/julia/issues/23923">#23923</a>).</p></li><li><p>The keyword <code>importall</code> is deprecated. Use <code>using</code> and/or individual <code>import</code> statements instead (<a href="https://github.com/JuliaLang/julia/issues/22789">#22789</a>).</p></li><li><p><code>reduce(+, [...])</code> and <code>reduce(*, [...])</code> no longer widen the iterated over arguments to system word size. <code>sum</code> and <code>prod</code> still preserve this behavior. (<a href="https://github.com/JuliaLang/julia/issues/22825">#22825</a>)</p></li><li><p>Like <code>_</code>, variable names consisting only of underscores can be assigned, but accessing their values is deprecated (<a href="https://github.com/JuliaLang/julia/issues/24221">#24221</a>).</p></li><li><p>Raw string literal escaping rules have been changed to make it possible to write all strings. The rule is that backslashes escape both quotes and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character (<a href="https://github.com/JuliaLang/julia/issues/22926">#22926</a>).</p></li><li><p><code>reprmime(mime, x)</code> has been renamed to <code>repr(mime, x)</code>, and along with <code>repr(x)</code> and <code>sprint</code> it now accepts an optional <code>context</code> keyword for <code>IOContext</code> attributes. <code>stringmime</code> has been moved to the Base64 stdlib package (<a href="https://github.com/JuliaLang/julia/issues/25990">#25990</a>).</p></li><li><p>The syntax <code>(x...)</code> for constructing a tuple is deprecated; use <code>(x...,)</code> instead (<a href="https://github.com/JuliaLang/julia/issues/24452">#24452</a>).</p></li><li><p>Non-parenthesized interpolated variables in strings, e.g. <code>&quot;$x&quot;</code>, must be followed by a character that will never be an allowed identifier character (currently operators, space/control characters, or common punctuation characters) (<a href="https://github.com/JuliaLang/julia/issues/25231">#25231</a>).</p></li><li><p>The syntax <code>using A.B</code> can now only be used when <code>A.B</code> is a module, and the syntax <code>using A: B</code> can only be used for adding single bindings (<a href="https://github.com/JuliaLang/julia/issues/8000">#8000</a>).</p></li><li><p><code>=&gt;</code> now has its own precedence level, giving it strictly higher precedence than <code>=</code> and <code>,</code> (<a href="https://github.com/JuliaLang/julia/issues/25391">#25391</a>).</p></li><li><p>The conditions under which unary operators followed by <code>(</code> are parsed as prefix function calls have changed (<a href="https://github.com/JuliaLang/julia/issues/26154">#26154</a>).</p></li><li><p><code>begin</code> is disallowed inside indexing expressions, in order to enable the syntax <code>a[begin]</code> (for selecting the first element) in the future (<a href="https://github.com/JuliaLang/julia/issues/23354">#23354</a>).</p></li><li><p>Underscores for <code>_italics_</code> and <code>__bold__</code> are now supported by the Base Markdown parser. (<a href="https://github.com/JuliaLang/julia/issues/25564">#25564</a>)</p></li><li><p><code>â¦</code> (<code>\dots</code>) and <code>â</code> (<code>\tricolon</code>) are now parsed as binary operators (<a href="https://github.com/JuliaLang/julia/issues/26262">#26262</a>).</p></li><li><p>Assignment syntax (<code>a=b</code>) inside square bracket expressions (e.g. <code>A[...]</code>, <code>[x, y]</code>) is deprecated. It will likely be reclaimed in a later version for passing keyword arguments. Note this does not affect updating operators like <code>+=</code> (<a href="https://github.com/JuliaLang/julia/issues/25631">#25631</a>).</p></li><li><p><code>try</code> blocks without <code>catch</code> or <code>finally</code> are no longer allowed. An explicit empty <code>catch</code> block should be written instead (<a href="https://github.com/JuliaLang/julia/issues/27554">#27554</a>).</p></li><li><p><code>AbstractArray</code> types that use unconventional (not 1-based) indexing can now support <code>size</code>, <code>length</code>, and <code>@inbounds</code>. To optionally enforce conventional indices, you can <code>@assert !has_offset_axes(A)</code>.</p></li><li><p>Module pre-compilation is now the default for code loading. Adding a <code>__precompile__()</code> declaration is no longer necessary, although <code>__precompile__(false)</code> can still be used to opt-out (<a href="https://github.com/JuliaLang/julia/issues/26991">#26991</a>).</p></li></ul><h2><a class="nav-anchor" id="Breaking-changes-1" href="#Breaking-changes-1">Breaking changes</a></h2><p>This section lists changes that do not have deprecation warnings.</p><ul><li><p>The package manager <code>Pkg</code> has been replaced with a new one. See the manual entries on &quot;Code Loading&quot; and &quot;Pkg&quot; for documentation.</p></li><li><p><code>replace(s::AbstractString, pat=&gt;repl)</code> for function <code>repl</code> arguments formerly passed a substring to <code>repl</code> in all cases.  It now passes substrings for string patterns <code>pat</code>, but a <code>Char</code> for character patterns (when <code>pat</code> is a <code>Char</code>, collection of <code>Char</code>, or a character predicate) (<a href="https://github.com/JuliaLang/julia/issues/25815">#25815</a>).</p></li><li><p><code>readuntil</code> now does <em>not</em> include the delimiter in its result, matching the behavior of <code>readline</code>. Pass <code>keep=true</code> to get the old behavior (<a href="https://github.com/JuliaLang/julia/issues/25633">#25633</a>).</p></li><li><p><code>lu</code> methods now return decomposition objects such as <code>LU</code> rather than tuples of arrays or tuples of numbers (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>schur</code> methods now return decomposition objects such as <code>Schur</code> and <code>GeneralizedSchur</code> rather than tuples of arrays (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>lq</code> methods now return decomposition objects such as <code>LQ</code> rather than tuples of arrays (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>qr</code> methods now return decomposition objects such as <code>QR</code>, <code>QRPivoted</code>, and <code>QRCompactWY</code> rather than tuples of arrays (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>svd</code> methods now return decomposition objects such as <code>SVD</code> and <code>GeneralizedSVD</code> rather than tuples of arrays or tuples of numbers (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>countlines</code> now always counts the last non-empty line even if it does not end with EOL, matching the behavior of <code>eachline</code> and <code>readlines</code> (<a href="https://github.com/JuliaLang/julia/issues/25845">#25845</a>).</p></li><li><p><code>getindex(s::String, r::UnitRange{Int})</code> now throws <code>StringIndexError</code> if <code>last(r)</code> is not a valid index into <code>s</code> (<a href="https://github.com/JuliaLang/julia/issues/22572">#22572</a>).</p></li><li><p><code>ntuple(f, n::Integer)</code> throws <code>ArgumentError</code> if <code>n</code> is negative. Previously an empty tuple was returned (<a href="https://github.com/JuliaLang/julia/issues/21697">#21697</a>).</p></li><li><p><code>â®</code>, <code>â±</code>, <code>â°</code>, and <code>â¯</code> are now parsed as binary operators, not ordinary identifiers.  <code>â</code>, <code>â</code>, and <code>â©´</code> now parse with assignment rather than comparison precedence (<a href="https://github.com/JuliaLang/julia/issues/26262">#26262</a>).</p></li><li><p>Juxtaposing string literals (e.g. <code>&quot;x&quot;y</code>) is now a syntax error (<a href="https://github.com/JuliaLang/julia/issues/20575">#20575</a>).</p></li><li><p><code>finalizer(function, object)</code> now returns <code>object</code> rather than <code>nothing</code> (<a href="https://github.com/JuliaLang/julia/issues/24679">#24679</a>).</p></li><li><p>The constructor of <code>SubString</code> now checks if the requested view range is defined by valid indices in the parent <code>AbstractString</code> (<a href="https://github.com/JuliaLang/julia/issues/22511">#22511</a>).</p></li><li><p>Macro calls with <code>for</code> expressions are now parsed as generators inside function argument lists (<a href="https://github.com/JuliaLang/julia/issues/18650">#18650</a>). Examples:</p><ul><li><p><code>sum(@inbounds a[i] for i = 1:n)</code> used to give a syntax error, but is now parsed as <code>sum(@inbounds(a[i]) for i = 1:n)</code>.</p></li><li><p><code>sum(@m x for i = 1:n end)</code> used to parse the argument to <code>sum</code> as a 2-argument call to macro <code>@m</code>, but now parses it as a generator plus a syntax error for the dangling <code>end</code>.</p></li></ul></li><li><p><code>@__DIR__</code> returns the current working directory rather than <code>nothing</code> when not run from a file (<a href="https://github.com/JuliaLang/julia/issues/21759">#21759</a>).</p></li><li><p><code>@__FILE__</code> and <code>@__DIR__</code> return information relative to the file that it was parsed from, rather than from the task-local <code>SOURCE_PATH</code> global when it was expanded.</p></li><li><p>All macros receive an extra argument <code>__source__::LineNumberNode</code> which describes the parser location in the source file for the <code>@</code> of the macro call. It can be accessed as a normal argument variable in the body of the macro. This is implemented by inserting an extra leading argument into the <code>Expr(:macrocall, :@name, LineNumberNode(...), args...)</code> surface syntax. (<a href="https://github.com/JuliaLang/julia/issues/21746">#21746</a>)</p></li><li><p>Passing the same keyword argument multiple times is now a syntax error (<a href="https://github.com/JuliaLang/julia/issues/16937">#16937</a>).</p></li><li><p><code>getsockname</code> on a <code>TCPSocket</code> now returns the locally bound address and port of the socket. Previously the address of the remote endpoint was being returned (<a href="https://github.com/JuliaLang/julia/issues/21825">#21825</a>).</p></li><li><p>The <code>~/.juliarc.jl</code> file has been moved to <code>~/.julia/config/startup.jl</code> and <code>/etc/julia/juliarc.jl</code> file has been renamed to <code>/etc/julia/startup.jl</code> (<a href="https://github.com/JuliaLang/julia/issues/26161">#26161</a>).</p></li><li><p>Using <code>ARGS</code> within <code>startup.jl</code> files or within a .jl file loaded with <code>--load</code> will no longer contain the script name as the first argument. Instead, the script name will be assigned to <code>PROGRAM_FILE</code>. (<a href="https://github.com/JuliaLang/julia/issues/22092">#22092</a>)</p></li><li><p>The format for a <code>ClusterManager</code> specifying the cookie on the command line is now <code>--worker=&lt;cookie&gt;</code>. <code>--worker &lt;cookie&gt;</code> will not work as it is now an optional argument.</p></li><li><p>The representation of <code>CartesianRange</code> has changed to a tuple-of-AbstractUnitRanges; the <code>start</code> and <code>stop</code> fields are no longer present. Use <code>first(R)</code> and <code>last(R)</code> to obtain start/stop. (<a href="https://github.com/JuliaLang/julia/issues/20974">#20974</a>)</p></li><li><p>The <code>Diagonal</code>, <code>Bidiagonal</code>, <code>Tridiagonal</code> and <code>SymTridiagonal</code> type definitions have changed from <code>Diagonal{T}</code>, <code>Bidiagonal{T}</code>, <code>Tridiagonal{T}</code> and <code>SymTridiagonal{T}</code> to <code>Diagonal{T,V&lt;:AbstractVector{T}}</code>, <code>Bidiagonal{T,V&lt;:AbstractVector{T}}</code>, <code>Tridiagonal{T,V&lt;:AbstractVector{T}}</code> and <code>SymTridiagonal{T,V&lt;:AbstractVector{T}}</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/22718">#22718</a>, <a href="https://github.com/JuliaLang/julia/issues/22925">#22925</a>, <a href="https://github.com/JuliaLang/julia/issues/23035">#23035</a>, <a href="https://github.com/JuliaLang/julia/issues/23154">#23154</a>).</p></li><li><p>The immediate supertype of <code>BitArray</code> is now simply <code>AbstractArray</code>. <code>BitArray</code> is no longer considered a subtype of <code>DenseArray</code> and <code>StridedArray</code> (<a href="https://github.com/JuliaLang/julia/issues/25858">#25858</a>).</p></li><li><p>When called with an argument that contains <code>NaN</code> elements, <code>findmin</code> and <code>findmax</code> now return the first <code>NaN</code> found and its corresponding index. Previously, <code>NaN</code> elements were ignored. The new behavior matches that of <code>min</code>, <code>max</code>, <code>minimum</code>, and <code>maximum</code>.</p></li><li><p><code>isapprox(x,y)</code> now tests <code>norm(x-y) &lt;= max(atol, rtol*max(norm(x), norm(y)))</code> rather than <code>norm(x-y) &lt;= atol + ...</code>, and <code>rtol</code> defaults to zero if an <code>atol &gt; 0</code> is specified (<a href="https://github.com/JuliaLang/julia/issues/22742">#22742</a>).</p></li><li><p>Spaces are no longer allowed between <code>@</code> and the name of a macro in a macro call (<a href="https://github.com/JuliaLang/julia/issues/22868">#22868</a>).</p></li><li><p>Juxtaposition of a non-literal with a macro call (<code>x@macro</code>) is no longer valid syntax (<a href="https://github.com/JuliaLang/julia/issues/22868">#22868</a>).</p></li><li><p>On a cluster, all files are now loaded from the local file system rather than node 1 (<a href="https://github.com/JuliaLang/julia/issues/22588">#22588</a>). To load the same file everywhere from node 1, one possible alternative is to broadcast a call to <code>include_string</code>: <code>@everywhere include_string(Main, $(read(&quot;filename&quot;, String)), &quot;filename&quot;)</code>. Improving upon this API is left as an opportunity for packages.</p></li><li><p><code>randperm(n)</code> and <code>randcycle(n)</code> now always return a <code>Vector{Int}</code> (independent of the type of <code>n</code>). Use the corresponding mutating functions <code>randperm!</code> and <code>randcycle!</code> to control the array type (<a href="https://github.com/JuliaLang/julia/issues/22723">#22723</a>).</p></li><li><p>Hermitian now ignores any imaginary components in the diagonal instead of checking the diagonal. (<a href="https://github.com/JuliaLang/julia/issues/17367">#17367</a>)</p></li><li><p>Worker-worker connections are setup lazily for an <code>:all_to_all</code> topology. Use keyword arg <code>lazy=false</code> to force all connections to be setup during a <code>addprocs</code> call. (<a href="https://github.com/JuliaLang/julia/issues/22814">#22814</a>)</p></li><li><p>In <code>joinpath(a, b)</code> on Windows, if the drive specifications of <code>a</code> and <code>b</code> do not match, <code>joinpath</code> now returns <code>b</code> instead of throwing an <code>ArgumentError</code>. <code>joinpath(path...)</code> is defined to be left associative, so if any argument has a drive path which does not match the drive of the join of the preceding paths, the prior ones are dropped. (<a href="https://github.com/JuliaLang/julia/issues/20912">#20912</a>)</p></li><li><p><code>^(A::AbstractMatrix{&lt;:Integer}, p::Integer)</code> now throws a <code>DomainError</code> if <code>p &lt; 0</code>, unless <code>A == one(A)</code> or <code>A == -one(A)</code> (same as for <code>^(A::Integer, p::Integer)</code>) (<a href="https://github.com/JuliaLang/julia/issues/23366">#23366</a>).</p></li><li><p><code>^(A::AbstractMatrix{&lt;:Integer}, p::Integer)</code> now promotes the element type in the same way as <code>^(A::Integer, p::Integer)</code>. This means, for instance, that <code>[1 1; 0 1]^big(1)</code> will return a <code>Matrix{BigInt}</code> instead of a <code>Matrix{Int}</code> (<a href="https://github.com/JuliaLang/julia/issues/23366">#23366</a>).</p></li><li><p>The element type of the input is now preserved in <code>unique</code>. Previously the element type of the output was shrunk to fit the union of the type of each element in the input. (<a href="https://github.com/JuliaLang/julia/issues/22696">#22696</a>)</p></li><li><p>The <code>promote</code> function now raises an error if its arguments are of different types and if attempting to convert them to a common type fails to change any of their types. This avoids stack overflows in the common case of definitions like <code>f(x, y) = f(promote(x, y)...)</code> (<a href="https://github.com/JuliaLang/julia/issues/22801">#22801</a>).</p></li><li><p><code>indmin</code> and <code>indmax</code> have been renamed to <code>argmin</code> and <code>argmax</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/25654">#25654</a>).</p></li><li><p><code>findmin</code>, <code>findmax</code>, <code>argmin</code>, and <code>argmax</code> used to always return linear indices. They now return <code>CartesianIndex</code>es for all but 1-d arrays, and in general return the <code>keys</code> of indexed collections (e.g. dictionaries) (<a href="https://github.com/JuliaLang/julia/issues/22907">#22907</a>).</p></li><li><p>The <code>openspecfun</code> library is no longer built and shipped with Julia, as it is no longer used internally (<a href="https://github.com/JuliaLang/julia/issues/22390">#22390</a>).</p></li><li><p>All loaded packages used to have bindings in <code>Main</code> (e.g. <code>Main.Package</code>). This is no longer the case; now bindings will only exist for packages brought into scope by typing <code>using Package</code> or <code>import Package</code> (<a href="https://github.com/JuliaLang/julia/issues/17997">#17997</a>).</p></li><li><p>The rules for mixed-signedness integer arithmetic (e.g. <code>Int32(1) + UInt64(1)</code>) have been simplified: if the arguments have different sizes (in bits), then the type of the larger argument is used. If the arguments have the same size, the unsigned type is used (<a href="https://github.com/JuliaLang/julia/issues/9292">#9292</a>).</p></li><li><p>All command line arguments passed via <code>-e</code>, <code>-E</code>, and <code>-L</code> will be executed in the order given on the command line (<a href="https://github.com/JuliaLang/julia/issues/23665">#23665</a>).</p></li><li><p><code>I</code> now yields <code>UniformScaling{Bool}(true)</code> rather than <code>UniformScaling{Int64}(1)</code> to better preserve types in operations involving <code>I</code> (<a href="https://github.com/JuliaLang/julia/issues/24396">#24396</a>).</p></li><li><p>The return type of <code>reinterpret</code> has changed to <code>ReinterpretArray</code>. <code>reinterpret</code> on sparse arrays has been discontinued.</p></li><li><p><code>Base.find_in_path</code> is now <code>Base.find_package</code> or <code>Base.find_source_file</code> (<a href="https://github.com/JuliaLang/julia/issues/24320">#24320</a>).</p></li><li><p><code>finalizer</code> now takes functions or pointers as its first argument, and the object being finalized as its second (rather than the reverse). For the majority of use cases deprecation warnings will be triggered. However, deprecation warnings will not trigger where (1) the callable argument is not a subtype of <code>Function</code>; or (2) both arguments are <code>Function</code>s or <code>Ptr{Cvoid}</code>s (<a href="https://github.com/JuliaLang/julia/issues/24605">#24605</a>).</p></li><li><p>The <code>kill</code> function now throws errors on user error (e.g. on permission errors), but returns successfully if the process had previously exited. Its return value has been removed. Use the <code>process_running</code> function to determine if a process has already exited.</p></li><li><p>The logging system has been redesigned - <code>info</code> and <code>warn</code> are deprecated and replaced with the logging macros <code>@info</code>, <code>@warn</code>, <code>@debug</code> and <code>@error</code>.  The <code>logging</code> function is also deprecated and replaced with <code>AbstractLogger</code> and the functions from the new standard <code>Logging</code> library. (<a href="https://github.com/JuliaLang/julia/issues/24490">#24490</a>)</p></li><li><p>The <code>RevString</code> type has been removed from the language; <code>reverse(::String)</code> returns a <code>String</code> with code points (or fragments thereof) in reverse order. In general, <code>reverse(s)</code> should return a string of the same type and encoding as <code>s</code> with code points in reverse order; any string type overrides <code>reverse</code> to return a different type of string must also override <code>reverseind</code> to compute reversed indices correctly.</p></li><li><p><code>eachindex(A, B...)</code> now requires that all inputs have the same number of elements. When the chosen indexing is Cartesian, they must have the same axes.</p></li><li><p><code>AbstractRange</code> objects are now considered as equal to other <code>AbstractArray</code> objects by <code>==</code> and <code>isequal</code> if all of their elements are equal (<a href="https://github.com/JuliaLang/julia/issues/16401">#16401</a>). This has required changing the hashing algorithm: ranges now use an O(N) fallback instead of a O(1) specialized method unless they define the <code>Base.RangeStepStyle</code> trait; see its documentation for details. Types which support subtraction (operator <code>-</code>) must now implement <code>widen</code> for hashing to work inside heterogeneous arrays.</p></li><li><p><code>findn(x::AbstractArray)</code> has been deprecated in favor of <code>findall(!iszero, x)</code>, which now returns cartesian indices for multidimensional arrays (see below, <a href="https://github.com/JuliaLang/julia/issues/25532">#25532</a>).</p></li><li><p>Broadcasting operations are no longer fused into a single operation by Julia&#39;s parser. Instead, a lazy <code>Broadcasted</code> object is created to represent the fused expression and then realized with <code>copy(bc::Broadcasted)</code> or <code>copyto!(dest, bc::Broadcasted)</code> to evaluate the wrapper. Consequently, package authors generally need to specialize <code>copy</code> and <code>copyto!</code> methods rather than <code>broadcast</code> and <code>broadcast!</code>. This also allows for more customization and control of fused broadcasts. See the <a href="https://docs.julialang.org/en/latest/manual/interfaces/#man-interfaces-broadcasting-1">Interfaces chapter</a> for more information.</p></li><li><p><code>find</code> has been renamed to <code>findall</code>. <code>findall</code>, <code>findfirst</code>, <code>findlast</code>, <code>findnext</code> now take and/or return the same type of indices as <code>keys</code>/<code>pairs</code> for <code>AbstractArray</code>, <code>AbstractDict</code>, <code>AbstractString</code>, <code>Tuple</code> and <code>NamedTuple</code> objects (<a href="https://github.com/JuliaLang/julia/issues/24774">#24774</a>, <a href="https://github.com/JuliaLang/julia/issues/25545">#25545</a>). In particular, this means that they use <code>CartesianIndex</code> objects for matrices and higher-dimensional arrays instead of linear indices as was previously the case. Use <code>LinearIndices(a)[findall(f, a)]</code> and similar constructs to compute linear indices.</p></li><li><p>The <code>find*</code> functions, i.e. <code>findnext</code>, <code>findprev</code>, <code>findfirst</code>, and <code>findlast</code>, as well as <code>indexin</code>, now return <code>nothing</code> when no match is found rather than <code>0</code> or <code>0:-1</code> (<a href="https://github.com/JuliaLang/julia/issues/25472">#25472</a>, <a href="https://github.com/JuliaLang/julia/issues/25662">#25662</a>, <a href="https://github.com/JuliaLang/julia/issues/26149">#26149</a>)</p></li><li><p>The <code>Base.HasShape</code> iterator trait has gained a type parameter <code>N</code> indicating the number of dimensions, which must correspond to the length of the tuple returned by <code>size</code> (<a href="https://github.com/JuliaLang/julia/issues/25655">#25655</a>).</p></li><li><p><code>AbstractSet</code> objects are now considered equal by <code>==</code> and <code>isequal</code> if all of their elements are equal (<a href="https://github.com/JuliaLang/julia/issues/25368">#25368</a>). This has required changing the hashing algorithm for <code>BitSet</code>.</p></li><li><p>the default behavior of <code>titlecase</code> is changed in two ways (<a href="https://github.com/JuliaLang/julia/issues/23393">#23393</a>):</p><ul><li>characters not starting a word are converted to lowercase; a new keyword argument <code>strict</code> is added which allows to get the old behavior when it&#39;s <code>false</code>.</li><li>any non-letter character is considered as a word separator; to get the old behavior (only &quot;space&quot; characters are considered as word separators), use the keyword <code>wordsep=isspace</code>.</li></ul></li><li><p><code>writedlm</code> in the standard library module DelimitedFiles now writes numeric values using <code>print</code> rather than <code>print_shortest</code> (<a href="https://github.com/JuliaLang/julia/issues/25745">#25745</a>).</p></li><li><p>The <code>tempname</code> function used to create a file on Windows but not on other platforms. It now never creates a file (<a href="https://github.com/JuliaLang/julia/issues/9053">#9053</a>).</p></li><li><p>The <code>fieldnames</code> and <code>propertynames</code> functions now return a tuple rather than an array (<a href="https://github.com/JuliaLang/julia/issues/25725">#25725</a>).</p></li><li><p><code>indexin</code> now returns the first rather than the last matching index (<a href="https://github.com/JuliaLang/julia/issues/25998">#25998</a>).</p></li><li><p><code>parse(::Type, ::Char)</code> now uses a default base of 10, like other number parsing methods, instead of 36 (<a href="https://github.com/JuliaLang/julia/issues/26576">#26576</a>).</p></li><li><p><code>isequal</code> for <code>Ptr</code>s now compares element types; <code>==</code> still compares only addresses (<a href="https://github.com/JuliaLang/julia/issues/26858">#26858</a>).</p></li><li><p><code>widen</code> on 8- and 16-bit integer types now widens to 16- and 32-bit types, respectively. (<a href="https://github.com/JuliaLang/julia/issues/28045">#28045</a>).</p></li><li><p><code>mv</code>,<code>cp</code>, <code>touch</code>, <code>mkdir</code>, <code>mkpath</code>, <code>chmod</code> and <code>chown</code> now return the path that was created/modified rather than <code>nothing</code> (<a href="https://github.com/JuliaLang/julia/issues/27071">#27071</a>).</p></li><li><p>Regular expressions now default to UCP mode. Escape sequences such as <code>\w</code> will now match based on unicode character properties, e.g. <code>r&quot;\w+&quot;</code> will match <code>cafÃ©</code> (not just <code>caf</code>). Add the <code>a</code> modifier (e.g. <code>r&quot;\w+&quot;a</code>) to restore the previous behavior (<a href="https://github.com/JuliaLang/julia/issues/27189">#27189</a>).</p></li><li><p><code>@sync</code> now waits only for <em>lexically</em> enclosed (i.e. visible directly in the source text of its argument) <code>@async</code> expressions. If you need to wait for a task created by a called function <code>f</code>, have <code>f</code> return the task and put <code>@async wait(f(...))</code> within the <code>@sync</code> block. This change makes <code>@schedule</code> redundant with <code>@async</code>, so <code>@schedule</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/27164">#27164</a>).</p></li><li><p><code>norm(A::AbstractMatrix, p=2)</code> computes no longer the operator/matrix norm but the <code>norm</code> of <code>A</code> as for other iterables, i.e. as if it were a vector. Especially, <code>norm(A::AbstractMatrix)</code> is the Frobenius norm. To compute the operator/matrix norm, use the new function <code>opnorm</code> (<a href="https://github.com/JuliaLang/julia/issues/27401">#27401</a>).</p></li><li><p><code>dot(u, v)</code> now acts recursively. Instead of <code>sum(u[i]&#39; * v[i] for i in ...)</code>, it computes <code>sum(dot(u[i], v[i]) for i in ...)</code>, similarly to <code>vecdot</code> before (<a href="https://github.com/JuliaLang/julia/issues/27401">#27401</a>).</p></li><li><p><code>Sys.CPU_CORES</code> has been renamed to <code>Sys.CPU_THREADS</code>; it still gives the number of &quot;logical cores&quot; (including hyperthreading) rather than the number of physical cores present on the CPU. Similarly, the environment variable <code>JULIA_CPU_CORES</code> is deprecated in favor of <code>JULIA_CPU_THREADS</code> (<a href="https://github.com/JuliaLang/julia/issues/27856">#27856</a>).</p></li><li><p><code>WeakKeyDict</code> does not convert keys on insertion anymore (#24941).</p></li></ul><h2><a class="nav-anchor" id="Library-improvements-1" href="#Library-improvements-1">Library improvements</a></h2><ul><li><p>The function <code>thisind(s::AbstractString, i::Integer)</code> returns the largest valid index less or equal than <code>i</code> in the string <code>s</code> or <code>0</code> if no such index exists (<a href="https://github.com/JuliaLang/julia/issues/24414">#24414</a>).</p></li><li><p>Support for Unicode 11 (<a href="https://github.com/JuliaLang/julia/issues/28266">#28266</a>).</p></li><li><p><code>Char</code> is now a subtype of <code>AbstractChar</code>, and most of the functions that take character arguments now accept any <code>AbstractChar</code> (<a href="https://github.com/JuliaLang/julia/issues/26286">#26286</a>).</p></li><li><p><code>pathof(module)</code> returns the path a module was imported from (<a href="https://github.com/JuliaLang/julia/issues/28310">#28310</a>).</p></li><li><p><code>bytes2hex</code> now accepts an optional <code>io</code> argument to output to a hexadecimal stream without allocating a <code>String</code> first (<a href="https://github.com/JuliaLang/julia/issues/27121">#27121</a>).</p></li><li><p><code>String(array)</code> now accepts an arbitrary <code>AbstractVector{UInt8}</code>. For <code>Vector</code> inputs, it &quot;steals&quot; the memory buffer, leaving them with an empty buffer which is guaranteed not to be shared with the <code>String</code> object. For other types of vectors (in particular immutable vectors), a copy is made and the input is not truncated (<a href="https://github.com/JuliaLang/julia/issues/26093">#26093</a>).</p></li><li><p><code>Irrational</code> is now a subtype of <code>AbstractIrrational</code> (<a href="https://github.com/JuliaLang/julia/issues/24245">#24245</a>).</p></li><li><p>Introduced the <code>empty</code> function, the functional pair to <code>empty!</code> which returns a new, empty container (<a href="https://github.com/JuliaLang/julia/issues/24390">#24390</a>).</p></li><li><p>Jump to first/last history entries in the REPL via &quot;Alt-&lt;&quot; and &quot;Alt-&gt;&quot; (<a href="https://github.com/JuliaLang/julia/issues/22829">#22829</a>).</p></li><li><p>REPL LaTeX-like tab completions have been simplified for several Unicode characters, e.g. <code>ð¸</code> is now <code>\bbA</code> rather than <code>\BbbA</code> (<a href="https://github.com/JuliaLang/julia/issues/25980">#25980</a>).</p></li><li><p>The function <code>chop</code> now accepts two arguments <code>head</code> and <code>tail</code> allowing to specify number of characters to remove from the head and tail of the string (<a href="https://github.com/JuliaLang/julia/issues/24126">#24126</a>).</p></li><li><p><code>get(io, :color, false)</code> can now be used to query whether a stream <code>io</code> supports <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI color codes</a> (<a href="https://github.com/JuliaLang/julia/issues/25067">#25067</a>), rather than using the undocumented <code>Base.have_color</code> global flag.</p></li><li><p><code>print_with_color</code> has been deprecated in favor of <code>printstyled([io], xs...; bold=false, color=:normal)</code> for printing styled text (<a href="https://github.com/JuliaLang/julia/issues/25522">#25522</a>).</p></li><li><p>Functions <code>first</code> and <code>last</code> now accept <code>nchar</code> argument for <code>AbstractString</code>. If this argument is used they return a string consisting of first/last <code>nchar</code> characters from the original string (<a href="https://github.com/JuliaLang/julia/issues/23960">#23960</a>).</p></li><li><p>Expressions <code>x^-n</code> where <code>n</code> is an <em>integer literal</em> now correspond to <code>inv(x)^n</code>. For example, <code>x^-1</code> is now essentially a synonym for <code>inv(x)</code>, and works in a type-stable way even if <code>typeof(x) != typeof(inv(x))</code> (<a href="https://github.com/JuliaLang/julia/issues/24240">#24240</a>).</p></li><li><p>New <code>Iterators.reverse(itr)</code> for reverse-order iteration (<a href="https://github.com/JuliaLang/julia/issues/24187">#24187</a>).  Iterator types <code>T</code> can implement <code>start</code> etc. for <code>Iterators.Reverse{T}</code> to support this.</p></li><li><p>The functions <code>nextind</code> and <code>prevind</code> now accept <code>nchar</code> argument that indicates the number of characters to move (<a href="https://github.com/JuliaLang/julia/issues/23805">#23805</a>).</p></li><li><p>The functions <code>strip</code>, <code>lstrip</code> and <code>rstrip</code> now return <code>SubString</code> (<a href="https://github.com/JuliaLang/julia/issues/22496">#22496</a>).</p></li><li><p>The functions <code>strwidth</code> and <code>charwidth</code> have been merged into <code>textwidth</code>(<a href="https://github.com/JuliaLang/julia/issues/20816">#20816</a>).</p></li><li><p>The functions <code>base</code> and <code>digits</code> digits now accept a negative base (like <code>ndigits</code> did) (<a href="https://github.com/JuliaLang/julia/issues/21692">#21692</a>).</p></li><li><p>The function <code>randn</code> now accepts complex arguments (<code>Complex{T &lt;: AbstractFloat}</code>) (<a href="https://github.com/JuliaLang/julia/issues/21973">#21973</a>).</p></li><li><p><code>parse(Complex{T}, string)</code> can parse complex numbers in some common formats (<a href="https://github.com/JuliaLang/julia/issues/24713">#24713</a>).</p></li><li><p>The function <code>rand</code> can now pick up random elements from strings, associatives and sets (<a href="https://github.com/JuliaLang/julia/issues/22228">#22228</a>, <a href="https://github.com/JuliaLang/julia/issues/21960">#21960</a>, <a href="https://github.com/JuliaLang/julia/issues/18155">#18155</a>, <a href="https://github.com/JuliaLang/julia/issues/22224">#22224</a>).</p></li><li><p>It&#39;s now possible to specify the characters to pick from in the <code>randstring</code> function (<a href="https://github.com/JuliaLang/julia/issues/22222">#22222</a>).</p></li><li><p>Allow multidimensional arrays in <code>shuffle</code> and <code>shuffle!</code> functions (<a href="https://github.com/JuliaLang/julia/issues/22226">#22226</a>).</p></li><li><p>Method lists are now printed as a numbered list. In addition, the source code of a method can be opened in an editor by entering the corresponding number in the REPL and pressing <code>^Q</code> (<a href="https://github.com/JuliaLang/julia/issues/22007">#22007</a>).</p></li><li><p><code>getpeername</code> on a <code>TCPSocket</code> returns the address and port of the remote endpoint of the TCP connection (<a href="https://github.com/JuliaLang/julia/issues/21825">#21825</a>).</p></li><li><p><code>resize!</code> and <code>sizehint!</code> methods no longer over-reserve memory when the requested array size is more than double of its current size (<a href="https://github.com/JuliaLang/julia/issues/22038">#22038</a>).</p></li><li><p>The <code>crc32c</code> function for CRC-32c checksums is now exported (<a href="https://github.com/JuliaLang/julia/issues/22274">#22274</a>).</p></li><li><p><code>eye(::Type{Diagonal{T}}, m::Integer)</code> has been deprecated in favor of <code>Diagonal{T}(I, m)</code> (<a href="https://github.com/JuliaLang/julia/issues/24413">#24413</a>).</p></li><li><p>The output of <code>versioninfo</code> is now controlled with keyword arguments (<a href="https://github.com/JuliaLang/julia/issues/21974">#21974</a>).</p></li><li><p>The function <code>LibGit2.set_remote_url</code> now always sets both the fetch and push URLs for a git repo. Additionally, the argument order was changed to be consistent with the git command line tool (<a href="https://github.com/JuliaLang/julia/issues/22062">#22062</a>).</p></li><li><p>Added <code>unique!</code> which is an inplace version of <code>unique</code> (<a href="https://github.com/JuliaLang/julia/issues/20549">#20549</a>).</p></li><li><p><code>@test isequal(x, y)</code> and <code>@test isapprox(x, y)</code> now prints an evaluated expression when the test fails (<a href="https://github.com/JuliaLang/julia/issues/22296">#22296</a>).</p></li><li><p>Uses of <code>Val{c}</code> in <code>Base</code> has been replaced with <code>Val{c}()</code>, which is now easily accessible via the efficient constructor <code>Val(c)</code>. Functions are defined as <code>f(::Val{c}) = ...</code> and called by <code>f(Val(c))</code>. Notable affected functions include: <code>ntuple</code>, <code>Base.literal_pow</code>, <code>sqrtm</code>, <code>lufact</code>, <code>lufact!</code>, <code>qrfact</code>, <code>qrfact!</code>, <code>cholfact</code>, <code>cholfact!</code>, <code>_broadcast!</code>, <code>reshape</code>, <code>cat</code> and <code>cat_t</code>.</p></li><li><p>A new <code>@macroexpand1</code> macro for non recursive macro expansion (<a href="https://github.com/JuliaLang/julia/issues/21662">#21662</a>).</p></li><li><p><code>Char</code>s can now be concatenated with <code>String</code>s and/or other <code>Char</code>s using <code>*</code> (<a href="https://github.com/JuliaLang/julia/issues/22532">#22532</a>).</p></li><li><p><code>Diagonal</code>, <code>Bidiagonal</code>, <code>Tridiagonal</code> and <code>SymTridiagonal</code> are now parameterized on the type of the wrapped vectors, allowing <code>Diagonal</code>, <code>Bidiagonal</code>, <code>Tridiagonal</code> and <code>SymTridiagonal</code> matrices with arbitrary <code>AbstractVector</code>s (<a href="https://github.com/JuliaLang/julia/issues/22718">#22718</a>, <a href="https://github.com/JuliaLang/julia/issues/22925">#22925</a>, <a href="https://github.com/JuliaLang/julia/issues/23035">#23035</a>, <a href="https://github.com/JuliaLang/julia/issues/23154">#23154</a>).</p></li><li><p>Mutating versions of <code>randperm</code> and <code>randcycle</code> have been added: <code>randperm!</code> and <code>randcycle!</code> (<a href="https://github.com/JuliaLang/julia/issues/22723">#22723</a>).</p></li><li><p><code>BigFloat</code> random numbers can now be generated (<a href="https://github.com/JuliaLang/julia/issues/22720">#22720</a>).</p></li><li><p>The efficiency of random generation for MersenneTwister RNGs has been improved for integers, <code>Float64</code> and ranges; as a result, given a seed, the produced stream of numbers has changed (<a href="https://github.com/JuliaLang/julia/issues/27560">#27560</a>, <a href="https://github.com/JuliaLang/julia/issues/25277">#25277</a>, <a href="https://github.com/JuliaLang/julia/issues/25197">#25197</a>, <a href="https://github.com/JuliaLang/julia/issues/25058">#25058</a>, <a href="https://github.com/JuliaLang/julia/issues/25047">#25047</a>).</p></li><li><p>REPL Undo via Ctrl-/ and Ctrl-_</p></li><li><p><code>diagm</code> now accepts several diagonal index/vector <code>Pair</code>s (<a href="https://github.com/JuliaLang/julia/issues/24047">#24047</a>).</p></li><li><p><code>isequal</code>, <code>==</code>, and <code>in</code> have one argument &quot;curried&quot; forms. For example <code>isequal(x)</code> returns a function that compares its argument to <code>x</code> using <code>isequal</code> (<a href="https://github.com/JuliaLang/julia/issues/26436">#26436</a>).</p></li><li><p><code>reinterpret</code> now works on any AbstractArray using the new <code>ReinterpretArray</code> type. This supersedes the old behavior of reinterpret on Arrays. As a result, reinterpreting arrays with different alignment requirements (removed in 0.6) is once again allowed (<a href="https://github.com/JuliaLang/julia/issues/23750">#23750</a>).</p></li><li><p>The <code>keys</code> of an <code>Associative</code> are now an <code>AbstractSet</code>. <code>Base.KeyIterator{&lt;:Associative}</code> has been changed to <code>KeySet{K, &lt;:Associative{K}} &lt;: AbstractSet{K}</code> (<a href="https://github.com/JuliaLang/julia/issues/24580">#24580</a>).</p></li><li><p>New function <code>ncodeunits(s::AbstractString)</code> gives the number of code units in a string. The generic definition is constant time but calls <code>lastindex(s)</code> which may be inefficient. Therefore custom string types may want to define direct <code>ncodeunits</code> methods.</p></li><li><p><code>reverseind(s::AbstractString, i::Integer)</code> now has an efficient generic fallback, so custom string types do not need to provide their own efficient definitions. The generic definition relies on <code>ncodeunits</code> however, so for optimal performance you may need to define a custom method for that function.</p></li><li><p>The global RNG is being re-seeded with its own seed at the beginning of each <code>@testset</code>, and have its original state restored at the end (<a href="https://github.com/JuliaLang/julia/issues/24445">#24445</a>). This is breaking for testsets relying implicitly on the global RNG being in a specific state.</p></li><li><p><code>permutedims(m::AbstractMatrix)</code> is now short for <code>permutedims(m, (2,1))</code>, and is now a more convenient way of making a &quot;shallow transpose&quot; of a 2D array. This is the recommended approach for manipulating arrays of data, rather than the recursively defined, linear-algebra function <code>transpose</code>. Similarly, <code>permutedims(v::AbstractVector)</code> will create a row matrix (<a href="https://github.com/JuliaLang/julia/issues/24839">#24839</a>).</p></li><li><p>A new <code>replace(A, old=&gt;new)</code> function is introduced to replace <code>old</code> by <code>new</code> in collection <code>A</code>. There is also another method with a different API, and a mutating variant, <code>replace!</code> (<a href="https://github.com/JuliaLang/julia/issues/22324">#22324</a>, <a href="https://github.com/JuliaLang/julia/issues/25697">#25697</a>, <a href="https://github.com/JuliaLang/julia/issues/26206">#26206</a>, <a href="https://github.com/JuliaLang/julia/issues/27944">#27944</a>).</p></li><li><p>Adding integers to <code>CartesianIndex</code> objects is now deprecated. Instead of <code>i::Int + x::CartesianIndex</code>, use <code>i*one(x) + x</code> (<a href="https://github.com/JuliaLang/julia/issues/26284">#26284</a>).</p></li><li><p><code>CartesianRange</code> changes (<a href="https://github.com/JuliaLang/julia/issues/24715">#24715</a>):</p><ul><li>Inherits from <code>AbstractArray</code>, and linear indexing can be used to provide linear-to-cartesian conversion (<a href="https://github.com/JuliaLang/julia/issues/24715">#24715</a>)</li><li>It has a new constructor taking an array</li></ul></li><li><p>several missing set-like operations have been added (<a href="https://github.com/JuliaLang/julia/issues/23528">#23528</a>): <code>union</code>, <code>intersect</code>, <code>symdiff</code>, <code>setdiff</code> are now implemented for all collections with arbitrary many arguments, as well as the mutating counterparts (<code>union!</code> etc.). The performance is also much better in many cases. Note that this change is slightly breaking: all the non-mutating functions always return a new object even if only one argument is passed. Moreover the semantics of <code>intersect</code> and <code>symdiff</code> is changed for vectors:</p><ul><li><code>intersect</code> doesn&#39;t preserve the multiplicity anymore (use <code>filter</code> for the old behavior)</li><li><code>symdiff</code> has been made consistent with the corresponding methods for other containers, by taking the multiplicity of the arguments into account. Use <code>unique</code> to get the old behavior.</li></ul></li><li><p>The <code>linearindices</code> function has been deprecated in favor of the new <code>LinearIndices</code> type, which additionally provides conversion from cartesian indices to linear indices using the normal indexing operation. (<a href="https://github.com/JuliaLang/julia/issues/24715">#24715</a>, <a href="https://github.com/JuliaLang/julia/issues/26775">#26775</a>).</p></li><li><p><code>IdDict{K,V}</code> replaces <code>ObjectIdDict</code>.  It has type parameters like other <code>AbstractDict</code> subtypes and its constructors mirror the ones of <code>Dict</code>. (<a href="https://github.com/JuliaLang/julia/issues/25210">#25210</a>)</p></li><li><p><code>IOBuffer</code> can take the <code>sizehint</code> keyword argument to suggest a capacity of the buffer (<a href="https://github.com/JuliaLang/julia/issues/25944">#25944</a>).</p></li><li><p><code>lstrip</code> and <code>rstrip</code> now accept a predicate function that defaults to <code>isspace</code> (<a href="https://github.com/JuliaLang/julia/issues/27309">#27309</a>).</p></li><li><p><code>trunc</code>, <code>floor</code>, <code>ceil</code>, and <code>round</code> specify <code>digits</code>, <code>sigdigits</code> and <code>base</code> using keyword arguments. (<a href="https://github.com/JuliaLang/julia/issues/26156">#26156</a>, <a href="https://github.com/JuliaLang/julia/issues/26670">#26670</a>)</p></li><li><p><code>Sys.which()</code> provides a cross-platform method to find executable files, similar to the Unix <code>which</code> command. (<a href="https://github.com/JuliaLang/julia/issues/26559">#26559</a>)</p></li><li><p>Added an optimized method of <code>vecdot</code> for taking the Frobenius inner product of sparse matrices. (<a href="https://github.com/JuliaLang/julia/issues/27470">#27470</a>)</p></li><li><p>Added an optimized method of <code>kron</code> for taking the tensor product of two <code>Diagonal</code> matrices. ([27581])</p></li><li><p>An official API for extending <code>rand</code> is now defined (<a href="https://github.com/JuliaLang/julia/issues/23964">#23964</a>, <a href="https://github.com/JuliaLang/julia/issues/25002">#25002</a>).</p></li><li><p>The constructor <code>MersenneTwister()</code> is re-enabled, producing a randomly initialized RNG (similar to <code>Random.seed!(MersenneTwister(0))</code>) (<a href="https://github.com/JuliaLang/julia/issues/21909">#21909</a>).</p></li><li><p><code>BitSet</code> can now store any <code>Int</code> (instead of only positive ones) (<a href="https://github.com/JuliaLang/julia/issues/25029">#25029</a>).</p></li><li><p>The initial element <code>v0</code> in <code>reduce(op, v0, itr)</code> has been replaced with an <code>init</code> optional keyword argument, as in <code>reduce(op, itr; init=v0)</code>. Similarly for <code>foldl</code>, <code>foldr</code>, <code>mapreduce</code>, <code>mapfoldl</code>, <code>mapfoldr</code>, <code>accumulate</code> and <code>accumulate!</code>. (<a href="https://github.com/JuliaLang/julia/issues/27711">#27711</a>, <a href="https://github.com/JuliaLang/julia/issues/27859">#27859</a>)</p></li></ul><h2><a class="nav-anchor" id="Compiler/Runtime-improvements-1" href="#Compiler/Runtime-improvements-1">Compiler/Runtime improvements</a></h2><ul><li><p>The inlining heuristic now models the approximate runtime cost of a method (using some strongly-simplifying assumptions). Functions are inlined unless their estimated runtime cost substantially exceeds the cost of setting up and issuing a subroutine call. (<a href="https://github.com/JuliaLang/julia/issues/22210">#22210</a>, <a href="https://github.com/JuliaLang/julia/issues/22732">#22732</a>)</p></li><li><p>Inference recursion-detection heuristics are now more precise, allowing them to be triggered less often, but being more aggressive when they are triggered to drive the inference computation to a solution (<a href="https://github.com/JuliaLang/julia/issues/23912">#23912</a>).</p></li><li><p>Inference now propagates constants inter-procedurally, and can compute various constants expressions at compile-time (<a href="https://github.com/JuliaLang/julia/issues/24362">#24362</a>).</p></li><li><p>The LLVM SLP Vectorizer optimization pass is now enabled at the default optimization level.</p></li></ul><h2><a class="nav-anchor" id="Deprecated-or-removed-1" href="#Deprecated-or-removed-1">Deprecated or removed</a></h2><ul><li><p>The <code>JULIA_HOME</code> environment variable has been renamed to <code>JULIA_BINDIR</code> and <code>Base.JULIA_HOME</code> has been moved to <code>Sys.BINDIR</code> (<a href="https://github.com/JuliaLang/julia/issues/20899">#20899</a>).</p></li><li><p>The keyword <code>immutable</code> is fully deprecated to <code>struct</code>, and <code>type</code> is fully deprecated to <code>mutable struct</code> (<a href="https://github.com/JuliaLang/julia/issues/19157">#19157</a>, <a href="https://github.com/JuliaLang/julia/issues/20418">#20418</a>).</p></li><li><p><code>lufact</code>, <code>schurfact</code>, <code>lqfact</code>, <code>qrfact</code>, <code>ldltfact</code>, <code>svdfact</code>, <code>bkfact</code>, <code>hessfact</code>, <code>eigfact</code>, and <code>cholfact</code> have respectively been deprecated to <code>lu</code>, <code>schur</code>, <code>lq</code>, <code>qr</code>, <code>ldlt</code>, <code>svd</code>, <code>bunchkaufman</code>, <code>hessenberg</code>, <code>eigen</code>, and <code>cholesky</code> (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>lufact!</code>, <code>schurfact!</code>, <code>lqfact!</code>, <code>qrfact!</code>, <code>ldltfact!</code>, <code>svdfact!</code>, <code>bkfact!</code>, <code>hessfact!</code>, and <code>eigfact!</code> have respectively been deprecated to <code>lu!</code>, <code>schur!</code>, <code>lq!</code>, <code>qr!</code>, <code>ldlt!</code>, <code>svd!</code>, <code>bunchkaufman!</code>, <code>hessenberg!</code>, and <code>eigen!</code> (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>eig(A[, args...])</code> has been deprecated in favor of <code>eigen(A[, args...])</code>. Whereas the former returns a tuple of arrays, the latter returns an <code>Eigen</code> object. So for a direct replacement, use <code>(eigen(A[, args...])...,)</code>. But going forward, consider using the direct result of <code>eigen(A[, args...])</code> instead, either destructured into its components (<code>vals, vecs = eigen(A[, args...])</code>) or as an <code>Eigen</code> object (<code>X = eigen(A[, args...])</code>) (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>eig(A::AbstractMatrix, B::AbstractMatrix)</code> and <code>eig(A::Number, B::Number)</code> have been deprecated in favor of <code>eigen(A, B)</code>. Whereas the former each return a tuple of arrays, the latter returns a <code>GeneralizedEigen</code> object. So for a direct replacement, use <code>(eigen(A, B)...,)</code>. But going forward, consider using the direct result of <code>eigen(A, B)</code> instead, either destructured into its components (<code>vals, vecs = eigen(A, B)</code>), or as a <code>GeneralizedEigen</code> object (<code>X = eigen(A, B)</code>) (<a href="https://github.com/JuliaLang/julia/issues/26997">#26997</a>, <a href="https://github.com/JuliaLang/julia/issues/27159">#27159</a>, <a href="https://github.com/JuliaLang/julia/issues/27212">#27212</a>).</p></li><li><p><code>ordschur(T::StridedMatrix{Ty}, Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})</code> and <code>ordschur(S::StridedMatrix{Ty}, T::StridedMatrix{Ty}, Q::StridedMatrix{Ty}, Z::StridedMatrix{Ty}, select::Union{Vector{Bool},BitVector})</code> and their respective inplace versions have been deprecated. Use <code>ordschur(schur::Schur, select::Union{Vector{Bool},BitVector})</code> and <code>ordschur(gschur::GeneralizedSchur, select::Union{Vector{Bool},BitVector})</code> instead (<a href="https://github.com/JuliaLang/julia/issues/28155">#28155</a>).</p></li><li><p>Indexing into multidimensional arrays with more than one index but fewer indices than there are dimensions is no longer permitted when those trailing dimensions have lengths greater than 1. Instead, reshape the array or add trailing indices so the dimensionality and number of indices match (<a href="https://github.com/JuliaLang/julia/issues/14770">#14770</a>, <a href="https://github.com/JuliaLang/julia/issues/23628">#23628</a>).</p></li><li><p>The use of a positional dimension argument has largely been deprecated in favor of a <code>dims</code> keyword argument. This includes the functions <code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>, <code>all</code>, <code>any</code>, <code>findmax</code>, <code>findmin</code>, <code>mean</code>, <code>varm</code>, <code>std</code>, <code>var</code>, <code>cov</code>, <code>cor</code>, <code>median</code>, <code>mapreducedim</code>, <code>reducedim</code>, <code>sort</code>, <code>accumulate</code>, <code>accumulate!</code>, <code>cumsum</code>, <code>cumsum!</code>, <code>cumprod</code>, <code>cumprod!</code>, <code>flipdim</code>, <code>dropdims</code>, and <code>cat</code> (<a href="https://github.com/JuliaLang/julia/issues/25501">#25501</a>, <a href="https://github.com/JuliaLang/julia/issues/26660">#26660</a>, <a href="https://github.com/JuliaLang/julia/issues/27100">#27100</a>).</p></li><li><p><code>indices(a)</code> and <code>indices(a,d)</code> have been deprecated in favor of <code>axes(a)</code> and <code>axes(a, d)</code> (<a href="https://github.com/JuliaLang/julia/issues/25057">#25057</a>).</p></li><li><p><code>EnvHash</code> has been renamed to <code>EnvDict</code> (<a href="https://github.com/JuliaLang/julia/issues/24167">#24167</a>).</p></li><li><p>Uninitialized <code>Array</code> constructors of the form <code>Array[{T,N}](shape...)</code> have been deprecated in favor of equivalents accepting <code>undef</code> (an alias for <code>UndefInitializer()</code>) as their first argument, as in <code>Array[{T,N}](undef, shape...)</code>. For example, <code>Vector(3)</code> is now <code>Vector(undef, 3)</code>, <code>Matrix{Int}((2, 4))</code> is now, <code>Matrix{Int}(undef, (2, 4))</code>, and <code>Array{Float32,3}(11, 13, 17)</code> is now <code>Array{Float32,3}(undef, 11, 13, 17)</code> (<a href="https://github.com/JuliaLang/julia/issues/24781">#24781</a>).</p></li><li><p>Previously <code>setindex!(A, x, I...)</code> (and the syntax <code>A[I...] = x</code>) supported two different modes of operation when supplied with a set of non-scalar indices <code>I</code> (e.g., at least one index is an <code>AbstractArray</code>) depending upon the value of <code>x</code> on the right hand side. If <code>x</code> is an <code>AbstractArray</code>, its <em>contents</em> are copied elementwise into the locations in <code>A</code> selected by <code>I</code> and it must have the same number of elements as <code>I</code> selects locations. Otherwise, if <code>x</code> is not an <code>AbstractArray</code>, then its <em>value</em> is implicitly broadcast to all locations to all locations in <code>A</code> selected by <code>I</code>. This latter behaviorâimplicitly broadcasting &quot;scalar&quot;-like values across many locationsâis now deprecated in favor of explicitly using the broadcasted assignment syntax <code>A[I...] .= x</code> or <code>fill!(view(A, I...), x)</code> (<a href="https://github.com/JuliaLang/julia/issues/26347">#26347</a>).</p></li><li><p><code>broadcast_getindex(A, I...)</code> and <code>broadcast_setindex!(A, v, I...)</code> are deprecated in favor of <code>getindex.((A,), I...)</code> and <code>setindex!.((A,), v, I...)</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/27075">#27075</a>).</p></li><li><p><code>LinAlg.fillslots!</code> has been renamed <code>LinAlg.fillstored!</code> (<a href="https://github.com/JuliaLang/julia/issues/25030">#25030</a>).</p></li><li><p><code>fill!(A::Diagonal, x)</code> and <code>fill!(A::AbstractTriangular, x)</code> have been deprecated in favor of <code>Base.LinAlg.fillstored!(A, x)</code> (<a href="https://github.com/JuliaLang/julia/issues/24413">#24413</a>).</p></li><li><p><code>eye</code> has been deprecated in favor of <code>I</code> and <code>Matrix</code> constructors. Please see the deprecation warnings for replacement details (<a href="https://github.com/JuliaLang/julia/issues/24438">#24438</a>).</p></li><li><p><code>zeros(D::Diagonal[, opts...])</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/24654">#24654</a>).</p></li><li><p>Using Bool values directly as indices is now deprecated and will be an error in the future. Convert them to <code>Int</code> before indexing if you intend to access index <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>.</p></li><li><p><code>slicedim(A, d, i)</code> has been deprecated in favor of <code>copy(selectdim(A, d, i))</code>. The new <code>selectdim</code> function now always returns a view into <code>A</code>; in many cases the <code>copy</code> is not necessary. Previously, <code>slicedim</code> on a vector <code>V</code> over dimension <code>d=1</code> and scalar index <code>i</code> would return the just selected element (unless <code>V</code> was a <code>BitVector</code>). This has now been made consistent: <code>selectdim</code> now always returns a view into the original array, with a zero-dimensional view in this specific case (<a href="https://github.com/JuliaLang/julia/issues/26009">#26009</a>).</p></li><li><p><code>whos</code> has been renamed <code>varinfo</code>, and now returns a markdown table instead of printing output (<a href="https://github.com/JuliaLang/julia/issues/12131">#12131</a>).</p></li><li><p>Uninitialized <code>RowVector</code> constructors of the form <code>RowVector{T}(shape...)</code> have been deprecated in favor of equivalents accepting <code>undef</code> (an alias for <code>UndefInitializer()</code>) as their first argument, as in <code>RowVector{T}(undef, shape...)</code>. For example, <code>RowVector{Int}(3)</code> is now <code>RowVector{Int}(undef, 3)</code>, and <code>RowVector{Float32}((1, 4))</code> is now <code>RowVector{Float32}(undef, (1, 4))</code> (<a href="https://github.com/JuliaLang/julia/issues/24786">#24786</a>).</p></li><li><p><code>writecsv(io, a; opts...)</code> has been deprecated in favor of <code>writedlm(io, a, &#39;,&#39;; opts...)</code> (<a href="https://github.com/JuliaLang/julia/issues/23529">#23529</a>).</p></li><li><p>The method <code>srand(rng, filename, n=4)</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/21359">#21359</a>).</p></li><li><p><code>readcsv(io[, T::Type]; opts...)</code> has been deprecated in favor of <code>readdlm(io, &#39;,&#39;[, T]; opts...)</code> (<a href="https://github.com/JuliaLang/julia/issues/23530">#23530</a>).</p></li><li><p><code>sparse(s::UniformScaling, m::Integer)</code> has been deprecated in favor of the three-argument equivalent <code>sparse(s::UniformScaling, m, n)</code> (<a href="https://github.com/JuliaLang/julia/issues/24472">#24472</a>).</p></li><li><p>The <code>cholfact</code>/<code>cholfact!</code> methods that accepted an <code>uplo</code> symbol have been deprecated in favor of using <code>Hermitian</code> (or <code>Symmetric</code>) views (<a href="https://github.com/JuliaLang/julia/issues/22187">#22187</a>, <a href="https://github.com/JuliaLang/julia/issues/22188">#22188</a>).</p></li><li><p>The <code>thin</code> keyword argument for orthogonal decomposition methods has been deprecated in favor of <code>full</code>, which has the opposite meaning: <code>thin == true</code> if and only if <code>full == false</code> (<a href="https://github.com/JuliaLang/julia/issues/24279">#24279</a>).</p></li><li><p><code>isposdef(A::AbstractMatrix, UL::Symbol)</code> and <code>isposdef!(A::AbstractMatrix, UL::Symbol)</code> have been deprecated in favor of <code>isposdef(Hermitian(A, UL))</code> and <code>isposdef!(Hermitian(A, UL))</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/22245">#22245</a>).</p></li><li><p>The <code>bkfact</code>/<code>bkfact!</code> methods that accepted <code>uplo</code> and <code>issymmetric</code> symbols have been deprecated in favor of using <code>Hermitian</code> (or <code>Symmetric</code>) views (<a href="https://github.com/JuliaLang/julia/issues/22605">#22605</a>).</p></li><li><p>The function <code>current_module</code> is deprecated and replaced with <code>@__MODULE__</code>. This caused the deprecation of some reflection methods (such as <code>macroexpand</code> and <code>isconst</code>), which now require a module argument. And it caused the bugfix of other default arguments to use the Main module (including <code>whos</code>, <code>which</code>)  (<a href="https://github.com/JuliaLang/julia/issues/22064">#22064</a>).</p></li><li><p><code>expand(ex)</code> and <code>expand(module, ex)</code> have been deprecated in favor of <code>Meta.lower(module, ex)</code> (<a href="https://github.com/JuliaLang/julia/issues/22064">#22064</a>, <a href="https://github.com/JuliaLang/julia/issues/24278">#24278</a>).</p></li><li><p><code>ones(A::AbstractArray[, opts...])</code> and <code>zeros(A::AbstractArray[, opts...])</code> methods have been deprecated. For <code>zeros(A)</code>, consider <code>zero(A)</code>. For <code>ones(A)</code> or <code>zeros(A)</code>, consider <code>ones(size(A))</code>, <code>zeros(size(A))</code>, <code>fill(v, size(A))</code> for <code>v</code> an appropriate one or zero, <code>fill!(copy(A), {1|0})</code>, <code>fill!(similar(A), {1|0})</code>, or any of the preceding with different element type and/or shape depending on <code>opts...</code>. Where strictly necessary, consider <code>fill!(similar(A[, opts...]), {one(eltype(A)) | zero(eltype(A))})</code>. For an algebraic multiplicative identity, consider <code>one(A)</code> (<a href="https://github.com/JuliaLang/julia/issues/24656">#24656</a>).</p></li><li><p>The <code>similar(dims-&gt;f(..., dims...), [T], axes...)</code> method to add offset array support to a function <code>f</code> that would otherwise create a non-offset array has been deprecated. Instead, call <code>f(..., axes...)</code> directly and, if needed, the offset array implementation should add offset axis support to the function <code>f</code> directly (<a href="https://github.com/JuliaLang/julia/issues/26733">#26733</a>).</p></li><li><p>The functions <code>ones</code> and <code>zeros</code> used to accept any objects as dimensional arguments, implicitly converting them to <code>Int</code>s.  This is now deprecated; only <code>Integer</code>s or <code>AbstractUnitRange</code>s are accepted as arguments.  Instead, convert the arguments before calling <code>ones</code> or <code>zeros</code> (<a href="https://github.com/JuliaLang/julia/issues/26733">#26733</a>).</p></li><li><p>The variadic <code>size(A, dim1, dim2, dims...)</code> method to return a tuple of multiple dimension lengths of <code>A</code> has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/26862">#26862</a>).</p></li><li><p>The <code>Operators</code> module is deprecated. Instead, import required operators explicitly from <code>Base</code>, e.g. <code>import Base: +, -, *, /</code> (<a href="https://github.com/JuliaLang/julia/issues/22251">#22251</a>).</p></li><li><p>Bindings to the FFTW library have been removed from Base. The DFT framework for building FFT implementations is now in AbstractFFTs.jl, the bindings to the FFTW library are in FFTW.jl, and the Base signal processing functions which used FFTs are now in DSP.jl (<a href="https://github.com/JuliaLang/julia/issues/21956">#21956</a>).</p></li><li><p>The <code>corrected</code> positional argument to <code>cov</code> has been deprecated in favor of a keyword argument with the same name (<a href="https://github.com/JuliaLang/julia/issues/21709">#21709</a>).</p></li><li><p>Omitting spaces around the <code>?</code> and the <code>:</code> tokens in a ternary expression has been deprecated. Ternaries must now include some amount of whitespace, e.g. <code>x ? a : b</code> rather than <code>x?a:b</code> (<a href="https://github.com/JuliaLang/julia/issues/22523">#22523</a> and <a href="https://github.com/JuliaLang/julia/issues/22712">#22712</a>).</p></li><li><p><code>?</code> can no longer be used as an identifier name (<a href="https://github.com/JuliaLang/julia/issues/22712">#22712</a>)</p></li><li><p>The method <code>replace(s::AbstractString, pat, r, [count])</code> is deprecated in favor of <code>replace(s::AbstractString, pat =&gt; r; [count])</code> (<a href="https://github.com/JuliaLang/julia/issues/25165">#25165</a>). Moreover, <code>count</code> cannot be negative anymore (use <code>typemax(Int)</code> instead (<a href="https://github.com/JuliaLang/julia/issues/22325">#22325</a>).</p></li><li><p><code>read(io, type, dims)</code> is deprecated to <code>read!(io, Array{type}(undef, dims))</code> (<a href="https://github.com/JuliaLang/julia/issues/21450">#21450</a>).</p></li><li><p><code>read(::IO, ::Ref)</code> is now a method of <code>read!</code>, since it mutates its <code>Ref</code> argument (<a href="https://github.com/JuliaLang/julia/issues/21592">#21592</a>).</p></li><li><p><code>nb_available</code> is now <code>bytesavailable</code> (<a href="https://github.com/JuliaLang/julia/issues/25634">#25634</a>).</p></li><li><p><code>skipchars(io::IO, predicate; linecomment=nothing)</code> is deprecated in favor of <code>skipchars(predicate, io::IO; linecomment=nothing)</code> (<a href="https://github.com/JuliaLang/julia/issues/25667">#25667</a>).</p></li><li><p><code>Bidiagonal</code> constructors now use a <code>Symbol</code> (<code>:U</code> or <code>:L</code>) for the upper/lower argument, instead of a <code>Bool</code> or a <code>Char</code> (<a href="https://github.com/JuliaLang/julia/issues/22703">#22703</a>).</p></li><li><p><code>Bidiagonal</code>, <code>Tridiagonal</code> and <code>SymTridiagonal</code> constructors that automatically converted the input vectors to the same type are deprecated in favor of explicit conversion (<a href="https://github.com/JuliaLang/julia/issues/22925">#22925</a>, <a href="https://github.com/JuliaLang/julia/issues/23035">#23035</a>, <a href="https://github.com/JuliaLang/julia/issues/23154">#23154</a>.</p></li><li><p>Calling <code>nfields</code> on a type to find out how many fields its instances have is deprecated. Use <code>fieldcount</code> instead. Use <code>nfields</code> only to get the number of fields in a specific object (<a href="https://github.com/JuliaLang/julia/issues/22350">#22350</a>).</p></li><li><p><code>fieldnames</code> now operates only on types. To get the names of fields in an object, use <code>fieldnames(typeof(x))</code> (<a href="https://github.com/JuliaLang/julia/issues/22350">#22350</a>).</p></li><li><p><code>InexactError</code>, <code>DomainError</code>, and <code>OverflowError</code> now take arguments. <code>InexactError(func::Symbol, type, -3)</code> now prints as &quot;ERROR: InexactError: func(type, -3)&quot;, <code>DomainError(val, [msg])</code> prints as &quot;ERROR: DomainError with val:\nmsg&quot;, and <code>OverflowError(msg)</code> prints as &quot;ERROR: OverflowError: msg&quot;. (<a href="https://github.com/JuliaLang/julia/issues/20005">#20005</a>, <a href="https://github.com/JuliaLang/julia/issues/22751">#22751</a>, <a href="https://github.com/JuliaLang/julia/issues/22761">#22761</a>)</p></li><li><p>The operating system identification functions: <code>is_linux</code>, <code>is_bsd</code>, <code>is_apple</code>, <code>is_unix</code>, and <code>is_windows</code>, have been deprecated in favor of <code>Sys.islinux</code>, <code>Sys.isbsd</code>, <code>Sys.isapple</code>, <code>Sys.isunix</code>, and <code>Sys.iswindows</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/22182">#22182</a>).</p></li><li><p>The forms of <code>read</code>, <code>readstring</code>, and <code>eachline</code> that accepted both a <code>Cmd</code> object and an input stream are deprecated. Use e.g. <code>read(pipeline(stdin, cmd))</code> instead (<a href="https://github.com/JuliaLang/julia/issues/22762">#22762</a>).</p></li><li><p>The unexported type <code>AbstractIOBuffer</code> has been renamed to <code>GenericIOBuffer</code> (<a href="https://github.com/JuliaLang/julia/issues/17360">#17360</a> <a href="https://github.com/JuliaLang/julia/issues/22796">#22796</a>).</p></li><li><p><code>IOBuffer(data::AbstractVector{UInt8}, read::Bool, write::Bool, maxsize::Integer)</code>, <code>IOBuffer(read::Bool, write::Bool)</code>, and <code>IOBuffer(maxsize::Integer)</code> are deprecated in favor of constructors taking keyword arguments (<a href="https://github.com/JuliaLang/julia/issues/25872">#25872</a>).</p></li><li><p><code>Display</code> has been renamed to <code>AbstractDisplay</code> (<a href="https://github.com/JuliaLang/julia/issues/24831">#24831</a>).</p></li><li><p>Remaining vectorized methods over <code>SparseVector</code>s, particularly <code>floor</code>, <code>ceil</code>, <code>trunc</code>, <code>round</code>, and most common transcendental functions such as <code>exp</code>, <code>log</code>, and <code>sin</code> variants, have been deprecated in favor of dot-syntax (<a href="https://github.com/JuliaLang/julia/issues/22961">#22961</a>).</p></li><li><p>The method <code>String(io::IOBuffer)</code> is deprecated to <code>String(take!(copy(io)))</code> (<a href="https://github.com/JuliaLang/julia/issues/21438">#21438</a>).</p></li><li><p>The function <code>readstring</code> is deprecated in favor of <code>read(io, String)</code> (<a href="https://github.com/JuliaLang/julia/issues/22793">#22793</a>)</p></li><li><p>The function <code>showall</code> is deprecated. Showing entire values is the default, unless an <code>IOContext</code> specifying <code>:limit=&gt;true</code> is in use (<a href="https://github.com/JuliaLang/julia/issues/22847">#22847</a>).</p></li><li><p><code>issubtype</code> has been deprecated in favor of <code>&lt;:</code> (which used to be an alias for <code>issubtype</code>).</p></li><li><p>Calling <code>write</code> on non-isbits arrays is deprecated in favor of explicit loops or <code>serialize</code> (<a href="https://github.com/JuliaLang/julia/issues/6466">#6466</a>).</p></li><li><p>The default <code>startup.jl</code> file on Windows has been removed. Now must explicitly include the full path if you need access to executables or libraries in the <code>Sys.BINDIR</code> directory, e.g. <code>joinpath(Sys.BINDIR, &quot;7z.exe&quot;)</code> for <code>7z.exe</code> (<a href="https://github.com/JuliaLang/julia/issues/21540">#21540</a>).</p></li><li><p><code>sqrtm</code> has been deprecated in favor of <code>sqrt</code> (<a href="https://github.com/JuliaLang/julia/issues/23504">#23504</a>).</p></li><li><p><code>expm</code> has been deprecated in favor of <code>exp</code> (<a href="https://github.com/JuliaLang/julia/issues/23233">#23233</a>).</p></li><li><p><code>logm</code> has been deprecated in favor of <code>log</code> (<a href="https://github.com/JuliaLang/julia/issues/23505">#23505</a>).</p></li><li><p><code>full</code> has been deprecated in favor of more specific, better defined alternatives. On structured matrices <code>A</code>, consider instead <code>Matrix(A)</code>, <code>Array(A)</code>, <code>SparseMatrixCSC(A)</code>, or <code>sparse(A)</code>. On sparse arrays <code>S</code>, consider instead <code>Vector(S)</code>, <code>Matrix(S)</code>, or <code>Array(S)</code> as appropriate. On factorizations <code>F</code>, consider instead <code>Matrix(F)</code>, <code>Array(F)</code>, <code>AbstractMatrix(F)</code>, or <code>AbstractArray(F)</code>. On implicit orthogonal factors <code>Q</code>, consider instead <code>Matrix(Q)</code> or <code>Array(Q)</code>; for implicit orthogonal factors that can be recovered in square or truncated form, see the deprecation message for square recovery instructions. On <code>Symmetric</code>, <code>Hermitian</code>, or <code>AbstractTriangular</code> matrices <code>A</code>, consider instead <code>Matrix(S)</code>, <code>Array(S)</code>, <code>SparseMatrixCSC(S)</code>, or <code>sparse(S)</code>. On <code>Symmetric</code> matrices <code>A</code> particularly, consider instead <code>LinAlg.copytri!(copy(parent(A)), A.uplo)</code>. On <code>Hermitian</code> matrices <code>A</code> particularly, consider instead <code>LinAlg.copytri!(copy(parent(A)), A.uplo, true)</code>. On <code>UpperTriangular</code> matrices <code>A</code> particularly, consider instead <code>triu!(copy(parent(A)))</code>. On <code>LowerTriangular</code> matrices <code>A</code> particularly, consider instead <code>tril!(copy(parent(A)))</code> (<a href="https://github.com/JuliaLang/julia/issues/24250">#24250</a>).</p></li><li><p><code>speye</code> has been deprecated in favor of <code>I</code>, <code>sparse</code>, and <code>SparseMatrixCSC</code> constructor methods (<a href="https://github.com/JuliaLang/julia/issues/24356">#24356</a>).</p></li><li><p>Calling <code>union</code> with no arguments is deprecated; construct an empty set with an appropriate element type using <code>Set{T}()</code> instead (<a href="https://github.com/JuliaLang/julia/issues/23144">#23144</a>).</p></li><li><p>Vectorized <code>DateTime</code>, <code>Date</code>, and <code>format</code> methods have been deprecated in favor of dot-syntax (<a href="https://github.com/JuliaLang/julia/issues/23207">#23207</a>).</p></li><li><p><code>Base.cpad</code> has been removed; use an appropriate combination of <code>rpad</code> and <code>lpad</code> instead (<a href="https://github.com/JuliaLang/julia/issues/23187">#23187</a>).</p></li><li><p><code>ctranspose</code> and <code>ctranspose!</code> have been deprecated in favor of <code>adjoint</code> and <code>adjoint!</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/23235">#23235</a>).</p></li><li><p><code>filter</code> and <code>filter!</code> on dictionaries now pass a single <code>key=&gt;value</code> pair to the argument function, instead of two arguments (<a href="https://github.com/JuliaLang/julia/issues/17886">#17886</a>).</p></li><li><p><code>rol</code>, <code>rol!</code>, <code>ror</code>, and <code>ror!</code> have been deprecated in favor of specialized methods for <code>circshift</code>/<code>circshift!</code> (<a href="https://github.com/JuliaLang/julia/issues/23404">#23404</a>).</p></li><li><p><code>Base.SparseArrays.SpDiagIterator</code> has been removed (<a href="https://github.com/JuliaLang/julia/issues/23261">#23261</a>).</p></li><li><p>The function <code>cfunction</code>, has been deprecated in favor of a macro form <code>@cfunction</code>. Most existing uses can be upgraded simply by adding a <code>@</code>. The new syntax now additionally supports allocating closures at runtime, for dealing with C APIs that don&#39;t provide a separate <code>void* env</code>-type callback argument. (<a href="https://github.com/JuliaLang/julia/issues/26486">#26486</a>)</p></li><li><p><code>diagm(v::AbstractVector, k::Integer=0)</code> has been deprecated in favor of <code>diagm(k =&gt; v)</code> (<a href="https://github.com/JuliaLang/julia/issues/24047">#24047</a>).</p></li><li><p><code>diagm(x::Number)</code> has been deprecated in favor of <code>fill(x, 1, 1)</code> (<a href="https://github.com/JuliaLang/julia/issues/24047">#24047</a>).</p></li><li><p><code>diagm(A::SparseMatrixCSC)</code> has been deprecated in favor of <code>spdiagm(sparsevec(A))</code> (<a href="https://github.com/JuliaLang/julia/issues/23341">#23341</a>).</p></li><li><p><code>diagm(A::BitMatrix)</code> has been deprecated, use <code>diagm(0 =&gt; vec(A))</code> or <code>BitMatrix(Diagonal(vec(A)))</code> instead (<a href="https://github.com/JuliaLang/julia/issues/23373">#23373</a>, <a href="https://github.com/JuliaLang/julia/issues/24047">#24047</a>).</p></li><li><p><code>â¯</code> (written as <code>\mscre&lt;TAB&gt;</code> or <code>\euler&lt;TAB&gt;</code>) is now the only (by default) exported name for Euler&#39;s number, and the type has changed from <code>Irrational{:e}</code> to <code>Irrational{:â¯}</code> (<a href="https://github.com/JuliaLang/julia/issues/23427">#23427</a>).</p></li><li><p>The mathematical constants <code>Ï</code>, <code>pi</code>, <code>â¯</code>, <code>e</code>, <code>Î³</code>, <code>eulergamma</code>, <code>catalan</code>, <code>Ï</code> and <code>golden</code> have been moved from <code>Base</code> to a new module; <code>Base.MathConstants</code>. Only <code>Ï</code>, <code>pi</code> and <code>â¯</code> are now exported by default from <code>Base</code> (<a href="https://github.com/JuliaLang/julia/issues/23427">#23427</a>).</p></li><li><p><code>eu</code> (previously an alias for <code>â¯</code>) has been deprecated in favor of <code>â¯</code> (or <code>MathConstants.e</code>) (<a href="https://github.com/JuliaLang/julia/issues/23427">#23427</a>).</p></li><li><p><code>GMP.gmp_version()</code>, <code>GMP.GMP_VERSION</code>, <code>GMP.gmp_bits_per_limb()</code>, and <code>GMP.GMP_BITS_PER_LIMB</code> have been renamed to <code>GMP.version()</code>, <code>GMP.VERSION</code>, <code>GMP.bits_per_limb()</code>, and <code>GMP.BITS_PER_LIMB</code>, respectively. Similarly, <code>MPFR.get_version()</code>, has been renamed to <code>MPFR.version()</code> (<a href="https://github.com/JuliaLang/julia/issues/23323">#23323</a>). Also, <code>LinAlg.LAPACK.laver()</code> has been renamed to <code>LinAlg.LAPACK.version()</code> and now returns a <code>VersionNumber</code>.</p></li><li><p><code>select</code>, <code>select!</code>, <code>selectperm</code> and <code>selectperm!</code> have been renamed respectively to <code>partialsort</code>, <code>partialsort!</code>, <code>partialsortperm</code> and <code>partialsortperm!</code> (<a href="https://github.com/JuliaLang/julia/issues/23051">#23051</a>).</p></li><li><p>The <code>Range</code> abstract type has been renamed to <code>AbstractRange</code> (<a href="https://github.com/JuliaLang/julia/issues/23570">#23570</a>).</p></li><li><p><code>map</code> on dictionaries previously operated on <code>key=&gt;value</code> pairs. This behavior is deprecated, and in the future <code>map</code> will operate only on values (<a href="https://github.com/JuliaLang/julia/issues/5794">#5794</a>).</p></li><li><p><code>map</code> on sets previously returned a <code>Set</code>, possibly changing the order or number of elements. This behavior is deprecated and in the future <code>map</code> will preserve order and number of elements (<a href="https://github.com/JuliaLang/julia/issues/26980">#26980</a>).</p></li><li><p>Previously, broadcast defaulted to treating its arguments as scalars if they were not arrays. This behavior is deprecated, and in the future <code>broadcast</code> will default to iterating over all its arguments. Wrap arguments you wish to be treated as scalars with <code>Ref()</code> or a 1-tuple. Package developers can choose to allow a non-iterable type <code>T</code> to always behave as a scalar by implementing <code>broadcastable(x::T) = Ref(x)</code> (<a href="https://github.com/JuliaLang/julia/issues/26212">#26212</a>).</p></li><li><p>Automatically broadcasted <code>+</code> and <code>-</code> for <code>array + scalar</code>, <code>scalar - array</code>, and so-on have been deprecated due to inconsistency with linear algebra. Use <code>.+</code> and <code>.-</code> for these operations instead (<a href="https://github.com/JuliaLang/julia/issues/22880">#22880</a>, <a href="https://github.com/JuliaLang/julia/issues/22932">#22932</a>).</p></li><li><p><code>flipbits!(B)</code> is deprecated in favor of using in-place broadcast to negate each element: <code>B .= .!B</code> (<a href="https://github.com/JuliaLang/julia/issues/27067">#27067</a>).</p></li><li><p><code>isleaftype</code> is deprecated in favor of the simpler predicates <code>isconcretetype</code> and <code>isdispatchtuple</code>. Concrete types are those that might equal <code>typeof(x)</code> for some <code>x</code>; <code>isleaftype</code> included some types for which this is not true. Those are now categorized more precisely as &quot;dispatch tuple types&quot; and &quot;!has<em>free</em>typevars&quot; (not exported). (<a href="https://github.com/JuliaLang/julia/issues/17086">#17086</a>, <a href="https://github.com/JuliaLang/julia/issues/25496">#25496</a>)</p></li><li><p><code>contains(eq, itr, item)</code> is deprecated in favor of <code>any</code> with a predicate (<a href="https://github.com/JuliaLang/julia/issues/23716">#23716</a>).</p></li><li><p><code>spdiagm(x::AbstractVector)</code> has been deprecated in favor of <code>sparse(Diagonal(x))</code> alternatively <code>spdiagm(0 =&gt; x)</code> (<a href="https://github.com/JuliaLang/julia/issues/23757">#23757</a>).</p></li><li><p><code>spdiagm(x::AbstractVector, d::Integer)</code> and <code>spdiagm(x::Tuple{&lt;:AbstractVector}, d::Tuple{&lt;:Integer})</code> have been deprecated in favor of <code>spdiagm(d =&gt; x)</code> and <code>spdiagm(d[1] =&gt; x[1], d[2] =&gt; x[2], ...)</code> respectively. The new <code>spdiagm</code> implementation now always returns a square matrix (<a href="https://github.com/JuliaLang/julia/issues/23757">#23757</a>).</p></li><li><p><code>spones(A::AbstractSparseArray)</code> has been deprecated in favor of <code>LinAlg.fillstored!(copy(A), 1)</code> (<a href="https://github.com/JuliaLang/julia/issues/25037">#25037</a>).</p></li><li><p>Constructors for <code>LibGit2.UserPasswordCredentials</code> and <code>LibGit2.SSHCredentials</code> which take a <code>prompt_if_incorrect</code> argument are deprecated. Instead, prompting behavior is controlled using the <code>allow_prompt</code> keyword in the <code>LibGit2.CredentialPayload</code> constructor (<a href="https://github.com/JuliaLang/julia/issues/23690">#23690</a>).</p></li><li><p><code>gradient</code> is deprecated and will be removed in the next release (<a href="https://github.com/JuliaLang/julia/issues/23816">#23816</a>).</p></li><li><p>The timing functions <code>tic</code>, <code>toc</code>, and <code>toq</code> are deprecated in favor of <code>@time</code> and <code>@elapsed</code> (<a href="https://github.com/JuliaLang/julia/issues/17046">#17046</a>).</p></li><li><p>Methods of <code>findfirst</code>, <code>findnext</code>, <code>findlast</code>, and <code>findprev</code> that accept a value to search for are deprecated in favor of passing a predicate (<a href="https://github.com/JuliaLang/julia/issues/19186">#19186</a>, <a href="https://github.com/JuliaLang/julia/issues/10593">#10593</a>).</p></li><li><p><code>find</code> functions now operate only on booleans by default. To look for non-zeros, use <code>x-&gt;x!=0</code> or <code>!iszero</code> (<a href="https://github.com/JuliaLang/julia/issues/23120">#23120</a>).</p></li><li><p>The ability of <code>reinterpret</code> to yield <code>Array</code>s of different type than the underlying storage has been removed. The <code>reinterpret</code> function is still available, but now returns a <code>ReinterpretArray</code>. The three argument form of <code>reinterpret</code> that implicitly reshapes has been deprecated (<a href="https://github.com/JuliaLang/julia/issues/23750">#23750</a>).</p></li><li><p><code>bits</code> has been deprecated in favor of <code>bitstring</code> (<a href="https://github.com/JuliaLang/julia/issues/24281">#24281</a>, <a href="https://github.com/JuliaLang/julia/issues/24263">#24263</a>).</p></li><li><p><code>num2hex</code> and <code>hex2num</code> have been deprecated in favor of <code>reinterpret</code> combined with <code>parse</code>/<code>hex</code> (<a href="https://github.com/JuliaLang/julia/issues/22088">#22088</a>).</p></li><li><p><code>copy!</code> is deprecated for <code>AbstractSet</code> and <code>AbstractDict</code>, with the intention to re-enable it with a cleaner meaning in a future version (<a href="https://github.com/JuliaLang/julia/issues/24844">#24844</a>).</p></li><li><p><code>copy!</code> (resp. <code>unsafe_copy!</code>) is deprecated for <code>AbstractArray</code> and is renamed <code>copyto!</code> (resp. <code>unsafe_copyto!</code>); it will be re-introduced with a different meaning in a future version (<a href="https://github.com/JuliaLang/julia/issues/24808">#24808</a>).</p></li><li><p><code>a:b</code> is deprecated for constructing a <code>StepRange</code> when <code>a</code> and <code>b</code> have physical units (Dates and Times). Use <code>a:s:b</code>, where <code>s = Dates.Day(1)</code> or <code>s = Dates.Second(1)</code>.</p></li><li><p><code>trues(A::AbstractArray)</code> and <code>falses(A::AbstractArray)</code> are deprecated in favor of <code>trues(size(A))</code> and <code>falses(size(A))</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/24595">#24595</a>).</p></li><li><p><code>workspace</code> is discontinued, check out <a href="https://github.com/timholy/Revise.jl">Revise.jl</a> for an alternative workflow (<a href="https://github.com/JuliaLang/julia/issues/25046">#25046</a>).</p></li><li><p><code>cumsum</code>, <code>cumprod</code>, <code>accumulate</code>, their mutating versions, and <code>diff</code> all now require a <code>dim</code> argument instead of defaulting to using the first dimension unless there is only one dimension (<a href="https://github.com/JuliaLang/julia/issues/24684">#24684</a>, <a href="https://github.com/JuliaLang/julia/issues/25457">#25457</a>).</p></li><li><p>The <code>sum_kbn</code> and <code>cumsum_kbn</code> functions have been moved to the <a href="https://github.com/JuliaMath/KahanSummation.jl">KahanSummation</a> package (<a href="https://github.com/JuliaLang/julia/issues/24869">#24869</a>).</p></li><li><p><code>isnumber</code> has been renamed to <code>isnumeric</code> (<a href="https://github.com/JuliaLang/julia/issues/25021">#25021</a>).</p></li><li><p><code>isalpha</code> has been renamed to <code>isletter</code> (<a href="https://github.com/JuliaLang/julia/issues/26932">#26932</a>).</p></li><li><p><code>is_assigned_char</code> and <code>normalize_string</code> have been renamed to <code>isassigned</code> and <code>normalize</code>, and moved to the new <code>Unicode</code> standard library module. <code>graphemes</code> has also been moved to that module (<a href="https://github.com/JuliaLang/julia/issues/25021">#25021</a>).</p></li><li><p>Sparse array functionality has moved to the <code>SparseArrays</code> standard library module (<a href="https://github.com/JuliaLang/julia/issues/25249">#25249</a>).</p></li><li><p>Linear algebra functionality, and specifically the <code>LinAlg</code> module has moved to the <code>LinearAlgebra</code> standard library module (<a href="https://github.com/JuliaLang/julia/issues/25571">#25571</a>).</p></li><li><p><code>@printf</code> and <code>@sprintf</code> have been moved to the <code>Printf</code> standard library (<a href="https://github.com/JuliaLang/julia/issues/23929">#23929</a>,<a href="https://github.com/JuliaLang/julia/issues/25056">#25056</a>).</p></li><li><p>The <code>Libdl</code> module has moved to the <code>Libdl</code> standard library module (<a href="https://github.com/JuliaLang/julia/issues/25459">#25459</a>).</p></li><li><p>The aliases <code>Complex32</code>, <code>Complex64</code> and <code>Complex128</code> have been deprecated in favor of <code>ComplexF16</code>, <code>ComplexF32</code> and <code>ComplexF64</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/24647">#24647</a>).</p></li><li><p><code>Base.parentindexes</code> and <code>SharedArrays.localindexes</code> have been renamed to <code>parentindices</code> and <code>localindices</code>, respectively. Similarly, the <code>indexes</code> field in the <code>SubArray</code> type has been renamed to <code>indices</code> without deprecation (<a href="https://github.com/JuliaLang/julia/issues/25088">#25088</a>).</p></li><li><p><code>Associative</code> has been deprecated in favor of <code>AbstractDict</code> (<a href="https://github.com/JuliaLang/julia/issues/25012">#25012</a>).</p></li><li><p><code>Void</code> has been renamed back to <code>Nothing</code> with an alias <code>Cvoid</code> for use when calling C with a return type of <code>Cvoid</code> or a return or argument type of <code>Ptr{Cvoid}</code> (<a href="https://github.com/JuliaLang/julia/issues/25162">#25162</a>).</p></li><li><p><code>Nullable{T}</code> has been deprecated and moved to the Nullables package (<a href="https://github.com/JuliaLang/julia/issues/23642">#23642</a>). Use <code>Union{T, Nothing}</code> instead, or <code>Union{Some{T}, Nothing}</code> if <code>nothing</code> is a possible value (i.e. <code>Nothing &lt;: T</code>). <code>isnull(x)</code> can be replaced with <code>x === nothing</code> and <code>unsafe_get</code>/<code>get</code> can be dropped or replaced with <code>coalesce</code>. <code>NullException</code> has been removed.</p></li><li><p><code>unshift!</code> and <code>shift!</code> have been renamed to <code>pushfirst!</code> and <code>popfirst!</code> (<a href="https://github.com/JuliaLang/julia/issues/23902">#23902</a>)</p></li><li><p><code>ipermute!</code> has been deprecated in favor of <code>invpermute!</code> (<a href="https://github.com/JuliaLang/julia/issues/25168">#25168</a>).</p></li><li><p><code>CartesianRange</code> has been renamed <code>CartesianIndices</code> (<a href="https://github.com/JuliaLang/julia/issues/24715">#24715</a>).</p></li><li><p><code>sub2ind</code> and <code>ind2sub</code> are deprecated in favor of using <code>CartesianIndices</code> and <code>LinearIndices</code> (<a href="https://github.com/JuliaLang/julia/issues/24715">#24715</a>).</p></li><li><p><code>getindex(F::Factorization, s::Symbol)</code> (usually seen as e.g. <code>F[:Q]</code>) is deprecated in favor of dot overloading (<code>getproperty</code>) so factors should now be accessed as e.g. <code>F.Q</code> instead of <code>F[:Q]</code> (<a href="https://github.com/JuliaLang/julia/issues/25184">#25184</a>).</p></li><li><p><code>search</code> and <code>rsearch</code> have been deprecated in favor of <code>findfirst</code>/<code>findnext</code> and <code>findlast</code>/<code>findprev</code> respectively, in combination with curried <code>isequal</code> and <code>in</code> predicates for some methods (<a href="https://github.com/JuliaLang/julia/issues/24673">#24673</a>).</p></li><li><p><code>search(buf::IOBuffer, delim::UInt8)</code> has been deprecated in favor of either <code>occursin(delim, buf)</code> (to test containment) or <code>readuntil(buf, delim)</code> (to read data up to <code>delim</code>) (<a href="https://github.com/JuliaLang/julia/issues/26600">#26600</a>).</p></li><li><p><code>ismatch(regex, str)</code> has been deprecated in favor of <code>contains(str, regex)</code> (<a href="https://github.com/JuliaLang/julia/issues/24673">#24673</a>).</p></li><li><p><code>matchall</code> has been deprecated in favor of <code>collect(m.match for m in eachmatch(r, s))</code> (<a href="https://github.com/JuliaLang/julia/issues/26071">#26071</a>).</p></li><li><p><code>similar(::Associative)</code> has been deprecated in favor of <code>empty(::Associative)</code>, and <code>similar(::Associative, ::Pair{K, V})</code> has been deprecated in favour of <code>empty(::Associative, K, V)</code> (<a href="https://github.com/JuliaLang/julia/issues/24390">#24390</a>).</p></li><li><p><code>findin(a, b)</code> has been deprecated in favor of <code>findall(in(b), a)</code> (<a href="https://github.com/JuliaLang/julia/issues/24673">#24673</a>).</p></li><li><p><code>module_name</code> has been deprecated in favor of a new, general <code>nameof</code> function. Similarly, the unexported <code>Base.function_name</code> and <code>Base.datatype_name</code> have been deprecated in favor of <code>nameof</code> methods (<a href="https://github.com/JuliaLang/julia/issues/25622">#25622</a>).</p></li><li><p>The module <code>Random.dSFMT</code> is renamed <code>Random.DSFMT</code> (<a href="https://github.com/JuliaLang/julia/issues/25567">#25567</a>).</p></li><li><p><code>Random.RandomDevice(unlimited::Bool)</code> (on non-Windows systems) is deprecated in favor of <code>Random.RandomDevice(; unlimited=unlimited)</code> (<a href="https://github.com/JuliaLang/julia/issues/25668">#25668</a>).</p></li><li><p>The generic implementations of <code>strides(::AbstractArray)</code> and <code>stride(::AbstractArray, ::Int)</code>  have been deprecated. Subtypes of <code>AbstractArray</code> that implement the newly introduced strided  array interface should define their own <code>strides</code> method (<a href="https://github.com/JuliaLang/julia/issues/25321">#25321</a>).</p></li><li><p><code>module_parent</code>, <code>Base.datatype_module</code>, and <code>Base.function_module</code> have been deprecated in favor of <code>parentmodule</code> ([#TODO]).</p></li><li><p><code>rand(t::Tuple{Vararg{Int}})</code> is deprecated in favor of <code>rand(Float64, t)</code> or <code>rand(t...)</code>; <code>rand(::Tuple)</code> will have another meaning in the future (<a href="https://github.com/JuliaLang/julia/issues/25429">#25429</a>, <a href="https://github.com/JuliaLang/julia/issues/25278">#25278</a>).</p></li><li><p><code>randjump</code>, which produced an array, is deprecated in favor of the scalar version <code>Future.randjump</code> used with <code>accumulate</code> (<a href="https://github.com/JuliaLang/julia/issues/27746">#27746</a>).</p></li><li><p>The <code>assert</code> function (and <code>@assert</code> macro) have been documented that they are not guaranteed to run under various optimization levels and should therefore not be used to e.g. verify passwords.</p></li><li><p><code>ObjectIdDict</code> has been deprecated in favor of <code>IdDict{Any,Any}</code> (<a href="https://github.com/JuliaLang/julia/issues/25210">#25210</a>).</p></li><li><p><code>gc</code> and <code>gc_enable</code> have been deprecated in favor of <code>GC.gc</code> and <code>GC.enable</code> (<a href="https://github.com/JuliaLang/julia/issues/25616">#25616</a>).</p></li><li><p><code>Base.@gc_preserve</code> has been deprecated in favor of <code>GC.@preserve</code> (<a href="https://github.com/JuliaLang/julia/issues/25616">#25616</a>).</p></li><li><p><code>print_shortest</code> has been discontinued, but is still available in the <code>Base.Grisu</code> submodule (<a href="https://github.com/JuliaLang/julia/issues/25745">#25745</a>).</p></li><li><p><code>scale!</code> has been deprecated in favor of <code>mul!</code>, <code>lmul!</code>, and <code>rmul!</code> (<a href="https://github.com/JuliaLang/julia/issues/25701">#25701</a>, <a href="https://github.com/JuliaLang/julia/issues/25812">#25812</a>).</p></li><li><p>The <code>remove_destination</code> keyword argument to <code>cp</code>, <code>mv</code>, and the unexported <code>cptree</code> has been renamed to <code>force</code> (<a href="https://github.com/JuliaLang/julia/issues/25979">#25979</a>).</p></li><li><p><code>contains</code> has been deprecated in favor of a more general <code>occursin</code> function, which takes its arguments in reverse order from <code>contains</code> (<a href="https://github.com/JuliaLang/julia/issues/26283">#26283</a>).</p></li><li><p><code>Regex</code> objects are no longer callable. Use <code>occursin</code> instead (<a href="https://github.com/JuliaLang/julia/issues/26283">#26283</a>).</p></li><li><p>The methods of <code>range</code> based on positional arguments have been deprecated in favor of keyword arguments (<a href="https://github.com/JuliaLang/julia/issues/25896">#25896</a>).</p></li><li><p><code>linspace</code> has been deprecated in favor of <code>range</code> with <code>stop</code> and <code>length</code> keyword arguments (<a href="https://github.com/JuliaLang/julia/issues/25896">#25896</a>).</p></li><li><p><code>LinSpace</code> has been renamed to <code>LinRange</code> (<a href="https://github.com/JuliaLang/julia/issues/25896">#25896</a>).</p></li><li><p><code>logspace</code> has been deprecated to its definition (<a href="https://github.com/JuliaLang/julia/issues/25896">#25896</a>).</p></li><li><p><code>endof(a)</code> has been renamed to <code>lastindex(a)</code>, and the <code>end</code> keyword in indexing expressions now lowers to either <code>lastindex(a)</code> (in the case with only one index) or <code>lastindex(a, d)</code> (in cases where there is more than one index and <code>end</code> appears at dimension <code>d</code>) (<a href="https://github.com/JuliaLang/julia/issues/23554">#23554</a>, <a href="https://github.com/JuliaLang/julia/issues/25763">#25763</a>).</p></li><li><p><code>DateTime()</code>, <code>Date()</code>, and <code>Time()</code> have been deprecated, instead use <code>DateTime(1)</code>, <code>Date(1)</code> and <code>Time(0)</code> respectively (<a href="https://github.com/JuliaLang/julia/issues/23724">#23724</a>).</p></li><li><p>The fallback method <code>^(x, p::Integer)</code> is deprecated. If your type relied on this definition, add a method such as <code>^(x::MyType, p::Integer) = Base.power_by_squaring(x, p)</code> (<a href="https://github.com/JuliaLang/julia/issues/23332">#23332</a>).</p></li><li><p><code>DevNull</code>, <code>STDIN</code>, <code>STDOUT</code>, and <code>STDERR</code> have been renamed to <code>devnull</code>, <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/25786">#25786</a>).</p></li><li><p><code>wait</code> and <code>fetch</code> on <code>Task</code> now resemble the interface of <code>Future</code>.</p></li><li><p><code>showcompact(io, x...)</code> has been deprecated in favor of <code>show(IOContext(io, :compact =&gt; true), x...)</code> (<a href="https://github.com/JuliaLang/julia/issues/26080">#26080</a>). Use <code>sprint(show, x..., context=:compact =&gt; true)</code> instead of <code>sprint(showcompact, x...)</code>.</p></li><li><p><code>isupper</code>, <code>islower</code>, <code>ucfirst</code> and <code>lcfirst</code> have been deprecated in favor of <code>isuppercase</code>, <code>islowercase</code>, <code>uppercasefirst</code> and <code>lowercasefirst</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/26442">#26442</a>).</p></li><li><p><code>signif</code> has been deprecated in favor of the <code>sigdigits</code> keyword argument to <code>round</code>.</p></li><li><p><code>Base.IntSet</code> has been deprecated in favor of <code>Base.BitSet</code> (<a href="https://github.com/JuliaLang/julia/issues/24282">#24282</a>).</p></li><li><p><code>setrounding</code> has been deprecated for <code>Float32</code> and <code>Float64</code>, as the behaviour was too unreliable (<a href="https://github.com/JuliaLang/julia/issues/26935">#26935</a>).</p></li><li><p><code>gamma</code>, <code>lgamma</code>, <code>beta</code>, <code>lbeta</code> and <code>lfact</code> have been moved to <a href="https://github.com/JuliaMath/SpecialFunctions.jl">SpecialFunctions.jl</a> (<a href="https://github.com/JuliaLang/julia/issues/27459">#27459</a>, <a href="https://github.com/JuliaLang/julia/issues/27473">#27473</a>).</p></li><li><p><code>atan2</code> is now a 2-argument method of <code>atan</code> (<a href="https://github.com/JuliaLang/julia/issues/27248">#27248</a>).</p></li><li><p>The functions <code>eigs</code> and <code>svds</code> have been moved to the <code>Arpack.jl</code> package (<a href="https://github.com/JuliaLang/julia/issues/27616">#27616</a>).</p></li><li><p><code>vecdot</code> and <code>vecnorm</code> are deprecated in favor of <code>dot</code> and <code>norm</code>, respectively (<a href="https://github.com/JuliaLang/julia/issues/27401">#27401</a>).</p></li><li><p><code>clipboard</code> has been moved to the <code>InteractiveUtils</code> standard library package (along with other utilities mostly used at the interactive prompt, such as <code>edit</code> and <code>less</code>) (<a href="https://github.com/JuliaLang/julia/issues/27635">#27635</a>).</p></li><li><p><code>ndigits(n, b, [pad])</code> is deprecated in favor of <code>ndigits(n, base=b, pad=pad)</code> (<a href="https://github.com/JuliaLang/julia/issues/27908">#27908</a>).</p></li><li><p><code>squeeze</code> is deprecated in favor of <code>dropdims</code>.</p></li><li><p><code>srand</code> is deprecated in favor of the unexported <code>Random.seed!</code> (<a href="https://github.com/JuliaLang/julia/issues/27726">#27726</a>).</p></li><li><p><code>realmin</code>/<code>realmax</code> are deprecated in favor of <code>floatmin</code>/<code>floatmax</code> (<a href="https://github.com/JuliaLang/julia/issues/28302">#28302</a>).</p></li><li><p><code>sortrows</code>/<code>sortcols</code> have been deprecated in favor of the more general <code>sortslices</code>.</p></li><li><p><code>nextpow2</code>/<code>prevpow2</code> have been deprecated in favor of the more general <code>nextpow</code>/<code>prevpow</code> functions.</p></li></ul><h2><a class="nav-anchor" id="Command-line-option-changes-1" href="#Command-line-option-changes-1">Command-line option changes</a></h2><ul><li><p>New option <code>--warn-overwrite={yes|no}</code> to control the warning for overwriting method definitions. The default is <code>no</code> (<a href="https://github.com/JuliaLang/julia/issues/23002">#23002</a>).</p></li><li><p>New option <code>--banner={yes,no}</code> allows suppressing or forcing the printing of the startup banner, overriding the default behavior (banner in REPL, no banner otherwise). The <code>--quiet</code> option implies <code>--banner=no</code> even in REPL mode but can be overridden by passing <code>--quiet</code> together with <code>--banner=yes</code> (<a href="https://github.com/JuliaLang/julia/issues/23342">#23342</a>).</p></li><li><p>The option <code>--precompiled</code> has been renamed to <code>--sysimage-native-code</code> (<a href="https://github.com/JuliaLang/julia/issues/23054">#23054</a>).</p></li><li><p>The option <code>--compilecache</code> has been renamed to <code>--compiled-modules</code> (<a href="https://github.com/JuliaLang/julia/issues/23054">#23054</a>).</p></li></ul><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../manual/getting-started/"><span class="direction">Next</span><span class="title">Getting Started</span></a></footer></article></body></html>
